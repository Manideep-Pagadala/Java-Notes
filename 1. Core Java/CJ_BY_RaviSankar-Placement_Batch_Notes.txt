javaravishanker@gmail.com

What is the advantage of writing constructor in our class ?
------------------------------------------------------------
If we don't write a constructor in our program then variable initialization and variable re-initialization both are done in two different lines.

If we write constructor in our program then variable initialization and variable re-initialization both are done in the same line i.e at the time of Object creation.

[Diagram 06-MAY-24] 
----------------------------------------------------------------

Constructor :
-------------
If the name of the class and name of the method both are exactly same and, It should not contain any return type then it is called Constructor.

*The main purpose of constructor to initialize the instance variable of the class. (Initializing the object)

Every class must contain at least one constructor either added by compiler (default constructor) or written by user.

The access modifier of default constructor depends upon the access modifier of the class.

Explicitly, a constructor never containing any return type including void also but implicitly it returns current class object (this keyword)
as shown in the program 
package com.ravi.constructor_demo;

class Employee
{
	public Employee()
	{		
		
	}
	
	public void m1()
	{
		System.out.println("m1 method");
	}	
}


public class ConstructorReturnValue {

	public static void main(String[] args) 
	{
		new Employee().m1();
	}

}

A constructor may contain return keyword but not return keyword with value.

public class Test 
{
	public Test()
	{
	  return ;   //valid	
	}

	public static void main(String[] args) 
	{
		 Test t1 = new Test();
	}
}


A constructor is automatically called and executed at the time of creating the object.

public class Demo
{
   public Demo()
    {
    }
}

Demo d1 = new Demo(); //Here only Constructor will invoked
     d1.Demo(); //No need to call explicitly
   
A constructor is called once per object that means if we create two objects then constructor will be called 2 times.
-------------------------------------------------------------------
Types Of Constructor :
-----------------------
Constructors are of 3 types :

1) Default Constructor.
2) No Argument OR Parameter less OR Non Parameterized OR Zero Argument Constrcutor.
3) Parameterized Constructor.

1) Default Constructor :
------------------------
The constructor added by compiler to help java programmer to create the object is called Default constructor.

Student.java
-------------
public class Student
{
}

javac Student.java (Compilation)

Student.class
-------------
public class Student
{
   public Student() //default Constructor added by compiler
   {
   }
}
------------------------------------------------------------------
2) No Argument Constructor :
----------------------------
2) No Argument Constructor :
----------------------------
A constructor written by user without parameter is called as No Argument constructor.
Default constructor and no argument constructor looks like same but default menas added by compiler and no argument written by user.

public class Employee
{
   private int employeeNumber;
   public Employee() //No Argument Constructor
   {
     employeeNumber = 123;
   }
}

In this no argument approach, all the objects will be initialized with same value so it is not a recommended way because all objects must contain different value.

2 Files :
---------
Person.java
------------
package com.ravi.constructor_demo;

public class Person 
{
	private int personId; // Data Hiding
	private String personName; // Data Hiding

	public Person() 
	{
		personId = 111;
		personName = "Scott";
	}

	@Override
	public String toString() {
		return "Person [personId=" + personId + ", personName=" + personName + "]";
	}

}


NoArgument.java
-----------------
package com.ravi.constructor_demo;


public class NoArgument {

	public static void main(String[] args) 
	{
		Person scott = new Person();
		System.out.println(scott);
		
		Person smith = new Person();
		System.out.println(smith);

	}

}

In the above program we have two objects scott and smith but both the objects are initialized with scott data which is not recommended so we 
introduced parameterized constructor.
-----------------------------------------------------------------
Role of instance variable and static varible while object creation
------------------------------------------------------------------
instance variable = Multiple copies will be created for each and every object.

static variable = Single copy will be created and it is sharable by all the objects.

Note :- static variabls are used to save the memory.

Program on instance variable :
-------------------------------

package com.ravi.constructor_demo;

public class Test 
{
    int x = 100;
    
	public static void main(String[] args) 
	{
		Test t1 = new Test();		
		Test t2 = new Test();
		++t1.x; //101
		--t2.x; //99
		
		System.out.println(t1.x);
		System.out.println(t2.x);

	}

}
------------------------------------------------------------------
//Program on static variable
package com.ravi.constructor_demo;

public class Test 
{
    static int x = 100;
    
	public static void main(String[] args) 
	{
		Test t1 = new Test();		
		Test t2 = new Test();
		++t1.x; //101
		++t2.x; //102
		
		System.out.println(t1.x);
		System.out.println(t2.x);

	}

}
-----------------------------------------------------------------
When we should declare a variable as an instance variable and when we should declare a variable as a static variable

instance variable = If the value of the variable is different with respect to objects 

static variable = If the value of the variable is common with respect to all the obejcts

Example :
public class Student
{
   int rollNumber;
   String studentName;
   String studentAddress;
   static String collegeName = "JNTU";
   static String courseName = "Java";
}
-----------------------------------------------------------------------
Parameterized Constructor :
---------------------------
If we pass one or more argument to the constructor then it is called parameterized constructor. By using parameterized constructor we can initialize all our objects with different value.

public class Customer
{
   int cid;
   String cname;

   public Customer(int cid, String cname) //Parameterized Constructor
   {
    this.cid = cid;
    this.cname = cname;
   }
}
-----------------------------------------------------------------
2 files :
---------
Dog.java
---------
package com.ravi.constructor_demo;

//BLC (Business Logic class)
public class Dog {
	private String dogColor;
	private double dogHeight;
	private String dogName;

	public Dog(String dogColor, double dogHeight, String dogName) {
		super();
		this.dogColor = dogColor;
		this.dogHeight = dogHeight;
		this.dogName = dogName;
	}

	
	
	
	public void setDogHeight(double dogHeight) {
		this.dogHeight = dogHeight;
	}




	@Override
	public String toString() {
		return "Dog [dogColor=" + dogColor + ", dogHeight=" + dogHeight + ", dogName=" + dogName + "]";
	}

	
	
}


ParameterizedConstructor.java(ELC)
-----------------------------------
package com.ravi.constructor_demo;

public class ParameterizedConstructor {

	public static void main(String[] args) 
	{
	    Dog d1 = new Dog("Grey", 3.5, "Tiger");
	    System.out.println(d1);
	    
	    
	    Dog d2 = new Dog("Black", 4.4, "Tommy");
	    System.out.println(d2);
	}

}
------------------------------------------------------------------
setter :- To modify the existing object data (Write opertion)
getter :- To read private data value outside of the BLC class
-----------------------------------------------------------------
Encapsulation (Data must be accessible via methods)
----------------------------------------------------
* Encapsulation :
---------------
Binding the data member with its associated function/method in a single unit is called encapsulation.

In other words we can say "Grouping the related things together is called Encapsulation". [Laptop]

In encapsulation data must be tightly coupled with associated function.

It provides us security because we can't access the data directly, data must be accessible via methods only.

We can achieve encapsulation in our program by using following

a) Declare all the data members as private (Tightly encapsulated class)
b) Define getters and setters (Or any kind of method) for each instance variable to perform read and write operation.

Note :
-----
If we declare all the instance variables with private access modifier then it is called tightly encapsulated class.

On the other hand if some variables are declared with private access modifier and other variables are not declared with private access modifier then it is called loosely encapsulated class.


class Student
{
   private int rollNumber;

   public void setRollNumber(int rollNumber)
   {
     //Validation 
     if(rollNumber <=0)
     {
         System.err.println("Invalid roll number");
     }
     else
     {
        this.rollNumber = rollNumber;
     }
   }
}


Student s1 = new Student();
        s1.rollNumber = -101; //Invalid [data is private]
------------------------------------------------------------------
08-05-2024
-----------
Pass be value:
---------------
Java always works with pass by value only.

package com.ravi.paas_by_value;

d
---------------------------------------------------------------------
package com.ravi.paas_by_value;

class Employee
{
	private double salary = 60000;

	public double getSalary() 
	{
		return salary;
	}

	public void setSalary(double salary) 
	{
		this.salary = salary;
	}
	
}


public class PassByValue1 
{
	public static void main(String[] args) 
	{
       Employee e1 = new Employee();
       updateSalary(e1);
       System.out.println(e1.getSalary());
       
	}
	
	public static void updateSalary(Employee emp)
	{
		emp.setSalary(80000);
	}


}
----------------------------------------------------------------------
package com.ravi.paas_by_value;

class Employee
{
	private double salary = 60000;

	public double getSalary() 
	{
		return salary;
	}

	public void setSalary(double salary) 
	{
	        //Validation
		if(salary <= 0)
		{
			System.out.println("Invalid Salary");
		}
		else
		{
		this.salary = salary;
		}
	}
	
}


public class PassByValue1 
{
	public static void main(String[] args) 
	{
       Employee e1 = new Employee(); //1000x
       updateSalary(e1);
       System.out.println(e1.getSalary());
       
	}
	
	public static void updateSalary(Employee emp)
	{
		emp.setSalary(-10000);
		emp = new Employee(); //2000x
		emp.setSalary(120000);
	}

}
---------------------------------------------------------------------
Garbage Collector :
-------------------
In C++, It is the responsibility of the programmer to allocate as well as to de-allocate the memory otherwise the corresponding memory will be blocked and we will get OutOfMemoryError.

In Java, Programmer is responsible to allocate the memory, memory de-allocation will be automatically done by garbage collector.

Garbage Collector will scan the heap area, identify which objects are not in use (The objects which does not contain any references) and it will delete those objects which are not in use.
---------------------------------------------------------------------
How many ways we can make an object eligible for GC :
-----------------------------------------------------
There are 3 ways we can make an object eligible for GC.

1) Assigning null literal to reference variable :
   Employee e1 = new Employee(111,"Ravi");
            e1 = null;

2) Creating an Object inside a method :

   public void createObject()
   {
      Employee e2 = new Employee();
   }
Here we are creating Employee object inside the method so, once the method execution is over then e2 will be deleted from the Stack Frame and the employee object will become eligible for GC.

3) Assigning new Object to the old existing reference variable:
   
   Employee e3 = new Employee();
   e3 = new Employee();

Earlier e3 variable was poting to Employee object after that a new Employee Object is created which is pointing to another memory location so the first object is eligible for GC.
-----------------------------------------------------------------
HEAP and STACK diagram for CustomerDemo.java
---------------------------------------------

javac CustomerDemo.java (Compilation)
java CustomerDemo (Execution)

Once we execute our java program then JVM gets some memory from the O.S., that memory is divided into two sections

1) HEAP memory :- All objects and object realted data
2) STACK memory :- All the methods are executed in the Stack memory

Note :- Whenever we call a method in java then one stack frame is created for that particular method.

class Customer
{
	private String name;
	private int id;

	public Customer(String name , int id) //constructor
	{
		super();
		this.name=name;
		this.id=id;
	}

	public void setId(int id)  //setter  
	{
		this.id=id;
	}

	public int getId() //getter
	{
		return this.id;
	}
}

public class CustomerDemo
{
	public static void main(String[] args) 
	{
		int val = 100;

		Customer c = new Customer("Ravi",2);

        m1(c);   
		
		//GC [Only 1 object is eligible i.e 3000x]

		System.out.println(c.getId());
	}

	public static void m1(Customer cust)  //cust = c
	{
		cust.setId(5);

	    cust = new Customer("Rahul",7);

		cust.setId(9);
		System.out.println(cust.getId());
	}
}  

//9  5
-----------------------------------------------------------------
09-05-2024
-----------
HEAP and STACK diagram for Test.java
--------------------------------------
public class Test 
{
	Test t;
	int val;

	public Test(int val)  
	{
		this.val = val;
	}

	public Test(int val, Test t)
	{
		this.val = val;
		this.t = t;
	}

	public static void main(String[] args) 
	{
		Test t1 = new Test(100);
		
		Test t2 = new Test(200,t1);

		Test t3 = new Test(300,t1);

		Test t4 = new Test(400,t2);

		t2.t = t3;  
		t3.t = t4; 
		t1.t = t2.t; 
		t2.t = t4.t; 

	System.out.println(t1.t.val);
	System.out.println(t2.t.val);
	System.out.println(t3.t.val);
	System.out.println(t4.t.val);
	}
	
}  
------------------------------------------------------------------
HEAP and STACK diagram for Employee.java
-----------------------------------------
public class Employee
{
	int id = 100;
	
	public static void main(String[] args) 
	{
		int val = 200;

		Employee e1 = new Employee();     

		e1.id = val;

		update(e1);	  
		
		System.out.println(e1.id);

        Employee e2 = new Employee(); 

		e2.id = 500;
        
		switchEmployees(e2,e1); //3000x , 1000x

		  //GC [2 objects 2000x and 4000x both are eligible for GC]

			System.out.println(e1.id);
		    System.out.println(e2.id);
	    } 
		
	 public static void update(Employee e)  
	 {
        e.id = 500;
		e = new Employee();
		e.id = 400;
		System.out.println(e.id);
	 }

	 public static void switchEmployees(Employee e1, Employee e2)
	  {
		 int temp = e1.id;
		 e1.id = e2.id; //500
		 e2 = new Employee();
		 e2.id = temp;
	  }
   }

-----------------------------------------------------------------
HEAP and STACK diagram for Sample.java
---------------------------------------
public class Sample
{	
	private Integer i1 = 900;

	public static void main(String[] args) 
	{
		Sample s1 = new Sample();    
		                              
		Sample s2 = new Sample();       

	    Sample s3 = modify(s2); 

		s1 = null;

      //GC [4 objects 1000x,2000x,5000x and 6000x are eligible 4 GC]

		System.out.println(s2.i1);		
	}
    public static Sample modify(Sample s)
	{
		s.i1=9;
		s = new Sample();
		s.i1= 20;  
        System.out.println(s.i1);
		s=null;
		return s;
	}
}
------------------------------------------------------------------
HEAP and STACK Diagram for Beta.java
-------------------------------------
class Alpha
{
	int val;
	static int sval = 200;
	static Beta b = new Beta();

	public Alpha(int val)
	{
      this.val = val;
	}
}

public class Beta     
{
	public static void main(String[] args) 
	{
		Alpha am1 = new Alpha(9);
		Alpha am2 = new Alpha(2);

		Alpha []ar = fill(am1, am2); 

		ar[0] = am1; 
        System.out.println(ar[0].val); 
        System.out.println(ar[1].val);
	}

	public static Alpha[] fill(Alpha a1, Alpha a2)
	{
		a1.val = 15;   

        Alpha fa[] = new Alpha[]{a2, a1}; 

		return fa;
	}
}
-----------------------------------------------------------------
Passing an Object reference to the Constructor (Copy Constructor):
-----------------------------------------------------------------
We can pass an object reference to the constructor so we can copy the contant of one object to another object.

Program on Object reference passing to constructor :
-----------------------------------------------------

3 files :
---------
Employee.java
---------------
package com.ravi.object_ref_const;

public class Employee 
{
	private int employeeNumber;
	private String employeeName;

	public Employee(int employeeNumber, String employeeName) {
		super();
		this.employeeNumber = employeeNumber;
		this.employeeName = employeeName;
	}

	public int getEmployeeNumber() {
		return employeeNumber;
	}

	public void setEmployeeNumber(int employeeNumber) {
		this.employeeNumber = employeeNumber;
	}

	public String getEmployeeName() {
		return employeeName;
	}

	public void setEmployeeName(String employeeName) {
		this.employeeName = employeeName;
	}

	
}

Manager.java
------------
package com.ravi.object_ref_const;

public class Manager {
	private int managerId;
	private String managerName;

	public Manager(Employee emp) {
		this.managerId = emp.getEmployeeNumber();
		this.managerName = emp.getEmployeeName();
	}

	@Override
	public String toString() {
		return "Manager [managerId=" + managerId + ", managerName=" + managerName + "]";
	}

}



CopyConstructor.java
-----------------------
package com.ravi.object_ref_const;

public class CopyConstructor {

	public static void main(String[] args) 
	{
		Employee e1 = new Employee(111,"Scott");
		
		Manager m1 = new Manager(e1);
		System.out.println(m1);
		
	}

}

Note : In the above program we initialized the Manager object properties using Employee object propertirs.
-----------------------------------------------------------------
10-05-2024
-----------
In this program we want to copy the content of same object to another object.

Player.java
------------
package com.ravi.copy_constructor;

public class Player 
{
  private String name1, name2;

	public Player(String name1, String name2) 
	{
		super();
		this.name1 = name1;
		this.name2 = name2;
	}
  
	public Player(Player p) // p = p1
	{
		this.name1 = p.name2;
		this.name2 = p.name1;
	}

	@Override
	public String toString() {
		return "Player [name1=" + name1 + ", name2=" + name2 + "]";
	}
  
  
}

Main.java
---------
package com.ravi.copy_constructor;

public class Main {

	public static void main(String[] args) 
	{
		Player p1 = new Player("Abhishek","head");
		System.out.println(p1);
		
		Player p2 = new Player(p1);
		System.out.println(p2);

	}

}

Note :- Here we copied the data of Player object and assign to another player object data.
-----------------------------------------------------------------
Instance block :
----------------
It is a special block which is automatically executed at the time of creating the object.

It is mainly used to initialize the instance variable of the class so it is also known as Instance Initializer.

Whenever we create the object then constructor is executed, in the same class if any instance block is available then it will automatically placed in the 2nd line of the constructor.

The first two lines of any constructor is reserved for the followings
  1) super() OR this()
  2) Instance block OR non static block

If we have multiple instance blocks then it will executed according to the order [Top To Bottom] and after executing all the instance blocks then only the body of the constructor will be executed.

If a user is writing instance block in the body of constructor then compiler will not perform ant action(will not add in the 2nd line)

An instance block never contains return keyword.

package com.ravi.copy_constructor;  //AB CD

class Alpha
{
	{
		System.out.println("A");
	}
	
	Alpha()
	{
		super();
		System.out.println("B");
	}
}

class Beta extends Alpha
{
	{
		System.out.println("C");
	}
	
	Beta()
	{
		super();
		System.out.println("D");
	}
}

public class InstanceBlock 
{
	public static void main(String[] args) 
	{
		new Beta(); //Anonymous OR Nameless object

	}

}
------------------------------------------------------------------
package com.ravi.copy_constructor;

class Foo
{
	int x;
	public Foo()
	{
		x = 400;
		System.out.println(x);
	}
	
	{
		x = 100;
		System.out.println(x);
	}
	{
		x = 200;
		System.out.println(x);
	}
	{
		x = 300;
		System.out.println(x);
	}
}


public class InstanceBlockDemo2 {

	public static void main(String[] args) {
		new Foo();
	}

}
-----------------------------------------------------------------
package com.ravi.copy_constructor;

class Demo
{
	public Demo()
	{
		System.out.println("No Argument Constructor...");
		
		{
			System.out.println("Instance Block");
		}
	}
}

public class InstanceBlockDemo3 {

	public static void main(String[] args) 
	{
		new Demo();
	}

}
----------------------------------------------------------------
package com.ravi.copy_constructor;

class Sample
{
	 int x = 100;
	
	
	{
		return; //error
	}
}

public class InstanceBlockDemo4 {

}
-----------------------------------------------------------------
private Constructor :
---------------------
A constructor can be declared as private. We should declare private constructor due to following 2 reasons :

1) Singleton class
2) If we declare only static variables and static method (Math and Arrays classes are having private constructor)
----------------------------------------------------------------
Relationship between the classes :
-----------------------------------
Two types of relationship 

1) IS-A Relation (We can achieve using Inheritance)
2) HAS-A Relation (We can achieve using Association)

Inheritance :
--------------
Inheritance (IS-A Relation) :
--------------------------------
Deriving a new class (child class) from existing class (parent class) in such a way that the new class will acquire all the properties and features (except private) from the existing class is called inheritance.

It is one of the most imporatnt feature of OOPs which provides "CODE REUSABILITY".

Using inheritance mechanism the relationship between the  classes is parent and child. According to Java the parent class is called super class and the child class is called sub class.

In java we provide inheritance using 'extends' keyword.

*By using inheritance all the feature of super class is by default available to the sub class so the sub class need not to start the process from begning onwards.

Inheritance provides IS-A relation between the classes. IS-A relation is tightly coupled relation (Blood Relation) so if we modify the super class content then automatically sub class content will also modify.

Inheritance provides us hierarchical classification of classes, In this hierarchy if we move towards upward direction more generalized properties will occur, on the other hand if we move towards downwand more specialized properties will occur.
----------------------------------------------------------------
Types of Inheritance in java :
------------------------------
Java supports 5 types of inheritance :

 1) Single level Inheritance 
 2) Multi level Inheritance
 3) Hierarchical Inheritance
 4) Multiple Inheritance (Not supported using class)
 5) Hybrid Inheritance (Combination of two)


----------------------------------------------------------------
Case 1 :
--------
package com.ravi.copy_constructor;

class Parent
{
	Parent()
	{
		System.out.println("No Argument constructor of Parent");
	}
}
class Child extends Parent
{
    Child()
    {
    	System.out.println("No Argument constructor of child");
    }
}

public class InheritanceDemo {

	public static void main(String[] args) 
	{
		new Child();

	}

}
---------------------------------------------------------------
Case 2 :
--------
package com.ravi.copy_constructor;

class Parent
{
	Parent(String str)
	{
		System.out.println("Parameterized constructor of Parent :"+str);
	}
}
class Child extends Parent
{
    Child()
    {
    	super("NIT");
    	System.out.println("No Argument constructor of child");
    }
}

public class InheritanceDemo {

	public static void main(String[] args) 
	{
		new Child();

	}

}
----------------------------------------------------------------
Case 3 :
---------
package com.ravi.copy_constructor;

class Parent
{
	public Parent()
	{
		
		System.out.println("No Argument constructor of Parent");
	}
	
	Parent(String str)
	{
		this();
		System.out.println("Parameterized constructor of Parent :"+str);
	}
}
class Child extends Parent
{
    Child()
    {
    	super("Nit"); 
    	System.out.println("No Argument constructor of child");
    }
}

public class InheritanceDemo {

	public static void main(String[] args) 
	{
		new Child();

	}

}
----------------------------------------------------------------
Case 4 :
---------
package com.ravi.copy_constructor;

class Parent
{
	public Parent()
	{		
		this("NIT");
		System.out.println("No Argument constructor of Parent");
	}
	
	Parent(String str)
	{
		
		System.out.println("Parameterized constructor of Parent :"+str);
	}
}
class Child extends Parent
{
    Child()
    {
    	System.out.println("No Argument constructor of child");
    }
}

public class InheritanceDemo {

	public static void main(String[] args) 
	{
		new Child();

	}

}
---------------------------------------------------------------
11-05-2024
----------
package com.ravi.super_demo;

class A
{
	public A()
	{
		System.out.println("A");
	}
}
class B extends A
{}

class C extends B
{
	public C()
	{
		System.out.println("C");
	}
}


public class Main {

	public static void main(String[] args) 
	{
		new C();

	}

}
---------------------------------------------------------------
Program on Hierarchical Inheritance :
--------------------------------------
4 files :
---------
Shape.java
----------
package com.ravi.super_demo;

public class Shape 
{
  protected int x;
  
  public Shape(int x)
  {
	  this.x = x;
	  System.out.println("x value is :"+x);
  }
}

Circle.java
------------
package com.ravi.super_demo;

public class Circle extends Shape
{
   protected final double PI = 3.14;
   
   public Circle(int radius)  
   {                          
	   super(radius);
   }
   
   public void areaOfCircle()
   {
	   double areaOfCircle = PI * x*x;
	   System.out.println("Area of Circle is :"+areaOfCircle);
   }
   
}





Rectangle.java
---------------
package com.ravi.super_demo;

public class Rectangle extends Shape
{
   protected int breadth;
   public Rectangle(int length, int breadth)
   {
	   super(length);
	   this.breadth = breadth;
   }
   
   public void areaOfRectangle()
   {
	   double areaOfRectangle = x * this.breadth;
	   System.out.println(areaOfRectangle);
   }
}


ShapeDemo.java
--------------
package com.ravi.super_demo;

import java.util.InputMismatchException;
import java.util.Scanner;

public class ShapeDemo {

	public static void main(String[] args) 
	{
	  Scanner sc = new Scanner(System.in);
	  System.out.println("Enter the radius of the Circle :");
	  try(sc)
	  {
		  int radius = sc.nextInt();
		  Circle c = new Circle(radius);
		  c.areaOfCircle();

	  }
	  catch(InputMismatchException e)
	   {
			 System.err.println("Please provide numeric value only"); 
	   }
	  
	   Rectangle r = new Rectangle(12, 90);
	   r.areaOfRectangle();
	}

}
--------------------------------------------------------------
What is variable shadowing ?
-----------------------------
If the name of instance variable and local /Parameter variable both are same then inside the method the local /Parameter variable will hide instance variable that is known as Variable Shadow as shown in the program below.


package com.ravi.super_demo;

class Student
{
	int studentId = 100;
	String studentName = "Scott";
	
	public void show()
	{
		int studentId = 200;
		String studentName = "Smith";
		
		System.out.println(studentId);
		System.out.println(studentName);
	}
	
}

public class VariableShadow {

	public static void main(String[] args)
	{
		new Student().show();

	}

}
--------------------------------------------------------------
this keyword Program :
----------------------
2 files :
----------
Customer.java
--------------
package com.ravi.super_demo;

public class Customer {
	private int customerId;
	private String customerName;

	public Customer(int customerId, String customerName)
	{
		this.customerId = customerId;
		this.customerName = customerName;
	}

	@Override
	public String toString() {
		return "Customer [customerId=" + this.customerId + ", customerName=" + this.customerName + "]";
	}

}

CustomerDemo.java
------------------
package com.ravi.super_demo;

public class CustomerDemo {

	public static void main(String[] args) {
		
		Customer c1 = new Customer(1, "Ravi");
		System.out.println(c1);

	}

}
---------------------------------------------------------------
Program on Multilevel inhertiatance :
-------------------------------------
package com.ravi.multilevel;

class Student
{
	protected int studentNumber;
	protected String studentName;
	protected String studentAddress;
	
	public Student(int studentNumber, String studentName, String studentAddress) {
		super();
		this.studentNumber = studentNumber;
		this.studentName = studentName;
		this.studentAddress = studentAddress;
	}

	@Override
	public String toString() {
		return "Student [studentNumber=" + studentNumber + ", studentName=" + studentName + ", studentAddress="
				+ studentAddress + "]";
	}	
	
	
	
}
class Science extends Student
{
	protected int physics;
	protected int chemistry;
	
	public Science(int studentNumber, String studentName, String studentAddress, int physics, int chemistry) {
		super(studentNumber, studentName, studentAddress);
		this.physics = physics;
		this.chemistry = chemistry;
	}

	@Override
	public String toString() {
		return super.toString()+"Science [physics=" + physics + ", chemistry=" + chemistry + "]";
	}
	
	
}

class PCM extends Science
{
	protected int math;

	public PCM(int studentNumber, String studentName, String studentAddress, int physics, int chemistry, int math) {
		super(studentNumber, studentName, studentAddress, physics, chemistry);
		this.math = math;
	}

	@Override
	public String toString()
	{
		return super.toString()+"PCM [math=" + math + "]";
	}

	
}

public class MultilevelDemo {

	public static void main(String[] args) 
	{
		PCM p = new PCM(1, "Raj", "Ameerpet", 50, 60, 90);
		System.out.println(p);

	}

}
----------------------------------------------------------------
HOW MANY WAYS WE CAN INITIALIZE THE OBJECT PROPERTIES ?
-------------------------------------------------------

The following are the ways to initialize the object properties :
----------------------------------------------------------------
public class Test
{
   int x,y;
}


1) At the time of declaration :

   Example :
   
  public class Test
   {
      int x = 10;
      int y = 20;
   }

   Test t1 = new Test();   [x = 10  y = 20]
   Test t2 = new Test();   [x = 10  y = 20]

Here the drawback is all objects will be initialized with same value.
-----------------------------------------------------------------------

2) By using Object Reference :

   public class Test
   {
      int x,y;
   }
   
   Test t1 = new Test();   t1.x=10;   t1.y=20;
   Test t2 = new Test();   t2.x=30;   t2.y=40;

   Here we are getting different values with respect to object but here the program becomes more complex.
---------------------------------------------------------------
3) By using methods :

   A) First Approach (Method without Parameter)
   ----------------------------------------------
   public class Test
   {
      int x,y;

      public void setData()  
      {                        
         x = 100;  y = 200;
      }
   }

    Test t1 = new Test();  t1.setData();  [x = 100   y = 200]
    Test t2 = new Test();  t2.setData();  [x = 100   y = 200]
    
    All the objects will be initialized with same value.

    B) Second Approach (Method with Parameter)
    -------------------------------------------
     public class Test
     {
      int x,y;

      public void setData(int x, int y)  
      {                        
         this.x = x;
	 this.y = y;
      }
   }

    Test t1 = new Test();  t1.setData(12,78);  [x = 12   y = 78]
    Test t2 = new Test();  t2.setData(15,29);  [x = 15   y = 29]

    Here the Drawback is initialization and re-initialization both are done in two different lines so Constructor introduced.
----------------------------------------------------------------------
4) By using Constructor 

   A) First Approach (No Argument Constructor)
   --------------------------------------------
   public class Test
   {
      int x,y;

      public Test()  //All the objects will be initialized with
      {                                             same value
         x = 100;  y = 200;
      }
   }

    Test t1 = new Test();    [x = 100   y = 200]
    Test t2 = new Test();    [x = 100   y = 200]
    

    B) Second Approach (Parameterized Constructor)
    -----------------------------------------------
     public class Test
     {
      int x,y;

      public Test(int x, int y)  
      {                        
         this.x = x;
	 this.y = y;
      }
   }

    Test t1 = new Test(12,78);    [x = 12   y = 78]
    Test t2 = new Test(15,29);    [x = 15   y = 29]

    This is the best way to initialize our instance variable because variable initialization and variable re-initialization both will be done in the same line as well as all the objects will be initialized with different values. 

    C) Third Approach (Copy Constructor)
    --------------------------------------

       public class Manager
       {
          private int managerId;
	  private String managerName;
          
	  public Manager(Employee emp)
	  {
	    this.managerId = emp.getEmployeeId();
	    this.managerName = emp.getEmployeeName();
          }
       }

Here with the help of Object reference (Employee class) we are 
initializing the properties of Manager class. (Copy Constructor)

        d) By using instance block (Instance Initializer)
	-------------------------------------------------
	
	public class Test
	{
	   int x,y;

           public Test()
	   {
	      System.out.println(x); //100
	      System.out.println(y); //200
	   }

           //Instance block
	   {
	       x = 100; 
	       y = 200;
	   }

------------------------------------------------------------------
5) By using super keyword :

   class Super
   {
     int x,y;

     public Super(int x , int y)
     {
        this.x = x;
	this.y = y;
     }
   }
   class Sub extends Super
   {
      Sub()
      {
         super(100,200); //Initializing the properties of super class
      }
   }

   new Sub();
---------------------------------------------------------------
HAS-A Relation :
-----------------
Program on Association :
-------------------------
3 files :
----------
Student.java
-------------
package com.ravi.association_demo;

import java.util.Objects;

public class Student {
	private int studentNumber;
	private String studentName;
	private int studentMarks;

	public Student(int studentNumber, String studentName, int studentMarks) {
		super();
		this.studentNumber = studentNumber;
		this.studentName = studentName;
		this.studentMarks = studentMarks;
	}

	@Override
	public String toString() {
		return "Student [studentNumber=" + studentNumber + ", studentName=" + studentName + ", studentMarks="
				+ studentMarks + "]";
	}

	public int getStudentNumber() {
		return studentNumber;
	}

	public void setStudentNumber(int studentNumber) {
		this.studentNumber = studentNumber;
	}

	public String getStudentName() {
		return studentName;
	}

	public void setStudentName(String studentName) {
		this.studentName = studentName;
	}

	public int getStudentMarks() {
		return studentMarks;
	}

	public void setStudentMarks(int studentMarks) {
		this.studentMarks = studentMarks;
	}

	@Override
	public int hashCode() {
		return Objects.hash(studentMarks, studentName, studentNumber);
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Student other = (Student) obj;
		return studentMarks == other.studentMarks && Objects.equals(studentName, other.studentName)
				&& studentNumber == other.studentNumber;
	}
	
	
	

}

Trainer.java
--------------
package com.ravi.association_demo;

import java.util.Scanner;

public class Trainer 
{
   public static void viewStudentProfile(Student obj)
   {
	   Scanner sc = new Scanner(System.in);
	   System.out.print("Enter Student Id :");
	   int no = sc.nextInt();
	   
	   if(no == obj.getStudentNumber())
	   {
		   System.out.println(obj);
	   }
	   else
	   {
		   System.err.println("Sorry id is not matching");
	   }
	   
   }
}

AssociationDemo.java
---------------------
package com.ravi.association_demo;

public class AssociationDemo {

	public static void main(String[] args) 
	{
		Student s1 = new Student(1, "Raj", 90);
		
		Trainer.viewStudentProfile(s1);
	}

}
-------------------------------------------------------------
Composition(Strong reference) :
--------------------------------
3 files :
----------
Engine.java
-------------
package com.ravi.composition;

public class Engine {
	private String engineType;
	private long horsePower;

	public Engine(String engineType, long horsePower) {
		super();
		this.engineType = engineType;
		this.horsePower = horsePower;
	}

	@Override
	public String toString() {
		return "Engine [engineType=" + engineType + ", horsePower=" + horsePower + "]";
	}

	
	
}

Car.java
----------
package com.ravi.composition;

public class Car
{
	private String carName;
	private int carModel;
	private final Engine engine; // HAS-A relation

	public Car(String carName, int carModel) 
	{
		super();
		this.carName = carName;
		this.carModel = carModel;
		this.engine = new Engine("Battery", 1500);
		
	}

	@Override
	public String toString() {
		return "Car [carName=" + carName + ", carModel=" + carModel + ", engine=" + engine + "]";
	}
	
	
	

}

CompositionDemo.java
---------------------

package com.ravi.composition;

public class CompositionDemo {

	public static void main(String[] args) 
	{
		Car kia = new Car("Kia EV", 2024);
		System.out.println(kia);

	}

}
---------------------------------------------------------------
Aggregation(Weak Reference) :
-----------------------------
3 files :
----------
College.java
------------
package com.ravi.aggregation;

public class College {
	private String collegeName;
	private String collegeLocation;

	public College(String collegeName, String collegeLocation) {
		super();
		this.collegeName = collegeName;
		this.collegeLocation = collegeLocation;
	}

	@Override
	public String toString() {
		return "College [collegeName=" + collegeName + ", collegeLocation=" + collegeLocation + "]";
	}

	
}

Student.java
-------------
package com.ravi.aggregation;

public class Student {
	private int studentId;
	private String studentName;
	private String studentAddress;
	private College college; // HAS-A Relation

	public Student(int studentId, String studentName, String studentAddress, College college) 
	{
		super();
		this.studentId = studentId;
		this.studentName = studentName;
		this.studentAddress = studentAddress;
		this.college = college;
	}

	@Override
	public String toString() {
		return "Student [studentId=" + studentId + ", studentName=" + studentName + ", studentAddress=" + studentAddress
				+ ", college=" + college + "]";
	}
	
	
	

}

AggregationDemo.java
---------------------
package com.ravi.aggregation;

public class AggregationDemo {

	public static void main(String[] args)
	{
		College clg = new College("VIT", "Vellore");
		
		clg = new College("JNTU","Hyderabad");
		
		Student s1 = new Student(1, "Scott", "Hyderabad", clg);
		System.out.println(s1);
		
		Student s2 = new Student(2,"Smith","Bangalore", clg);
		System.out.println(s2);

	}

}
---------------------------------------------------------------
Record class in java :
-----------------------
public abstract class Record extends Object.

It is a new feature introduced from java 17.(In java 14 preview version)

As we know only objects are moving in the network from one place to another place so we need to write BLC class with nessacery requirements to make BLC class as a Data carrier class.

Records are immutable data carrier so, now with the help of record we can send our immutable data from one application to another application.

It is also known as DTO (Data transfer object) OR POJO classes.

It is mainly used to concise our code as well as remove the boiler plate code.

In record, automatically constructor will be generated which is known as canonical constructor and the variables which are known as components are by default final.

In order to validate the outer world data, we can write our own constructor which is known as compact constructor.

Record will automatically generate the implemenation of toString(), equals(Object obj) and hashCode() method.

we can define static variable, static method and static block in record.

We can't define instance variable, instance block but instance method we can write.

We cann't extend or inherit records because by default every record is implicilty final. It is extending from java.lang.Reocrd class

We can implement an interface by using record.

We don't have setter facility in record because by default components are final.
--------------------------------------------------------------

EmployeeRecord.java
--------------------
package com.ravi.recorddemo;

//Canonical Constructor        //Components (final)
public record EmployeeRecord(int empId, String empName) 
{
		
	
   //Compact constructor
   public EmployeeRecord
   {
	 if(empId <=0)
	 {
		 System.err.println("Invalid Id...");
	 }
	 
   }


	
}
EmployeeClass.java
-------------------
package com.ravi.recorddemo;

import java.util.Objects;

public class EmployeeClass {
	private int employeeId;
	private String employeeName;

	public EmployeeClass(int employeeId, String employeeName) {
		super();
		this.employeeId = employeeId;
		this.employeeName = employeeName;
	}

	@Override
	public String toString() {
		return "EmployeeClass [employeeId=" + employeeId + ", employeeName=" + employeeName + "]";
	}

	public int getEmployeeId() {
		return employeeId;
	}

	public void setEmployeeId(int employeeId) {
		this.employeeId = employeeId;
	}

	public String getEmployeeName() {
		return employeeName;
	}

	public void setEmployeeName(String employeeName) {
		this.employeeName = employeeName;
	}

	@Override
	public int hashCode() {
		return Objects.hash(employeeId, employeeName);
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		EmployeeClass other = (EmployeeClass) obj;
		return employeeId == other.employeeId && Objects.equals(employeeName, other.employeeName);
	}
	
	

}

Main.java
---------
package com.ravi.recorddemo;

public class Main {

	public static void main(String[] args) 
	{
		//Class and record comparison
		
		EmployeeClass ec1 = new EmployeeClass(1, "Raj");
		EmployeeClass ec2 = new EmployeeClass(1, "Raj");
		System.out.println(ec1);
		System.out.println(ec1==ec2);
		System.out.println(ec1.equals(ec2));
		System.out.println(ec1.getEmployeeId());
		System.out.println(".................");
		EmployeeRecord er1 = new EmployeeRecord(2, "Scott");
		EmployeeRecord er2 = new EmployeeRecord(2, "Scott");
		System.out.println(er1);
		System.out.println(er1==er2);
		System.out.println(er1.equals(er2));
		System.out.println(er1.empId());
		
	}

}
---------------------------------------------------------------
15-05-2024
-----------
Polymorphism :
--------------
Poly means "many" and morphism means "forms".

It is a Greek word whose meaning is "same object having different behavior".

In our real life a person or a human being can perform so many task, in the same way in our programming languages a method or a constructor can perform so many task.

Eg:-

void add(int a, int b)

void add(int a, int b, int c)

void add(float a, float b)

void add(int a, float b)


Polymorphism can be divided into two types :

1) Static polymorphism OR Compile time polymorphism OR Early binding

2) Dynamic Polymorphism OR Runtime polymorphism OR Late binding

1) Static Polymorphism :
------------------------
The polymorphism which exist at the time of compilation is called Static OR compile time polymorphism.

In static polymorphism, compiler has very good idea that which method is invoked depending upon METHOD PARAMETER.

Here the binding of the method is done at compilation time so, it is known as early binding.

We can achieve static polymorphism by using Method Overloading concept.

Example of static polymorphism : Method Overloading.


2) Dynamic Polymorphism OR Runtime Polymorphism
------------------------------------------------
The polymorphism which exist at runtime is called Dynamic polymorphim Or Runtime Polymorphism.

*Here compiler does not have any idea about method calling, at runtime JVM will decide which method will be invoked depending upon CLASS TYPE Object.

Here method binding is done at runtime so, it is also called Late Binding.

We can achieve dynamic polymorphism by using Method Overriding.

Example of Dynamic Polymorphism : Method Overriding
---------------------------------------------------------------
Method Overloading :
---------------------
Method Overloading :
--------------------
Writing two or more methods in the same class or even in the super and sub class in such a way that the method name must be same but the argument must be different.

While Overloading a method we can change the return type of the method.

If parameters are same but only method return type is different then it is not an overloaded method.

Method overloading is possible in the same class as well as super and sub class.

While overloading the method the argument must be different otherwise there will be ambiguity problem.

IQ
---
Can we overload the main method/static method ?

Yes, we can overload the main method OR static method but the execution of the program will start from main method which accept String [] array as a parameter.

Note :- The advantage of method overloading is same method name we can reuse for different functionality for refinement of the method.

Note :- In System.out.println() or System.out.print(int x), print() and println() methods are best example for Method Overloading.

2 files :
----------
Addition.java
--------------
//Program on Constructor Overloading
package com.ravi.constructor_overloading;

public class Addition 
{
   public Addition(int x, int y)
   {		   
	   System.out.println("Sum of two integer is :"+(x+y));
   }
   
   public Addition(int x, int y, int z)
   {  
	   System.out.println("Sum of three integer is :"+(x+y+z));
   }
   
   public Addition(float x, float y)
   {	  
	   System.out.println("Sum of two float is :"+(x+y));
   }
}

Main.java
----------
package com.ravi.constructor_overloading;

public class Main {

	public static void main(String []  args) 
	{
		new Addition(2.3f, 7.8F);		
		new Addition(10, 20, 30);
		new Addition(12,90);
	}

}
---------------------------------------------------------------
2 files :
----------
Addition.java
-------------
package com.ravi.constructor_overloading1;

public class Addition 
{
   public Addition(int x, int y)
   {	  
	   super();
	   System.out.println("Sum of two integer is :"+(x+y));
   }
   
   public Addition(int x, int y, int z)
   {
	   this(100,200);
	   System.out.println("Sum of three integer is :"+(x+y+z));
   }
   
   public Addition(float x, float y)
   {	
	   this(10,20,30);
	   System.out.println("Sum of two float is :"+(x+y));
   }
}


Main.java
---------

package com.ravi.constructor_overloading1;

public class Main {

	public static void main(String []  args) 
	{
		new Addition(2.3f, 7.8F);		
		
	}

}
----------------------------------------------------------------
instance block role with constructor :
---------------------------------------
Our instance block will be placed in the constructor which contains super(), if we have multiple constructor and all the constructors are executed according to constructor chaining then compiler will placed instance block to only one constructor which contians super()

Addition.java
--------------
package com.ravi.constructor_overloading2;

public class Addition 
{
   public Addition()
   {
	  this(10); 
	  System.out.println("No Argument Constructor");
   }
   
   public Addition(int x)
   {
	   this(100,200);
	   System.out.println("One Argument Constructor :"+x);
	   
   }
   public Addition(int x, int y)
   {
	   super();
	   System.out.println("Two Argument Constructor :"+x+":"+y);
   }
   
   {
		System.out.println("Instance Block");
   }
}

package com.ravi.constructor_overloading2;

public class Test {

	public static void main(String[] args) 
	{
		new Addition();
			
	}
}
---------------------------------------------------------------
Var-Args :
------------
It was introduced from JDK 1.5 onwards.

It stands for variable argument. It is an array variable which can hold 0 to n number of parameters of same type or different type by using Object class.

It is represented by exactly 3 dots (...) so it can accept any number of argument (0 to nth) that means now we need not to define method body again and again, if there is change in method parameter value.

var-args must be only one and last argument.

We can use var-args as a method parameter only.
----------------------------------------------------------------
Program that describes var args can hold 0 to n number of parameters :

package com.ravi.var_args;

class Demo
{
	public void input(int ...x)
	{
		System.out.println("Method Executed");
	}
}


public class VarArgsDemo1 
{
	public static void main(String[] args)
	{
		Demo d = new Demo();
		d.input();
		d.input(3);
		d.input(5,10);
		d.input(5,10,30);

	}

}
---------------------------------------------------------------
Program that describes we can fetch the value from var args to perform addition operation.

package com.ravi.var_args;

class Demo
{
	public void input(int ...x) //100  200   300   400
	{		
		int sum = 0;
		
		for(int y : x)
		{
		   sum = sum + y;	
		}
		System.out.println("Sum of parameters :"+sum);
		
	}
}


public class VarArgsDemo1 
{
	public static void main(String[] args)
	{
		Demo d = new Demo();
		d.input();
		d.input(3);
		d.input(5,10);
		d.input(5,10,30);
		d.input(100,200,300,400);

	}

}
---------------------------------------------------------------
var args must be only one and last argument

2 files :
----------
package com.ravi.var_args2;

public class Test {
	// All commented codes are invalid
	
	  
	/*
	 * public void accept(float ...x, int ...y) { }
	 * 
	 * public void accept(int ...x, int y) { }
	 * 
	 * public void accept(int...x, int ...y) {}
	 */
	 

	public void accept(int x, int... y) // valid
	{
		System.out.println("x value is :" + x);
		for (int z : y) {
			System.out.println(z);
		}
	}
}


package com.ravi.var_args2;

public class Main {

	public static void main(String[] args) 
	{
		Test t1 = new Test();
		t1.accept(100, 200,300,400,500);
	}
}
---------------------------------------------------------------
//Var args can hold hetrogeneous types of data also

package com.ravi.var_args;

class Demo
{
	public void input(Object ...x) 
	{		
		for(Object y : x)
		{
			System.out.println(y);
		}
		System.out.println("..................");
	}
}


public class VarArgsDemo1 
{
	public static void main(String[] args)
	{
		Demo d = new Demo();
		d.input(10);
		d.input("Ravi","NIT",new String("32"),34.89, true);
		d.input(false, 12, 45.89, 45.6f);

	}

}
---------------------------------------------------------------
16-05-2024
-----------
Ambiguity issue while overloading a method :
--------------------------------------------
At the time of method overloading if method call is ambigious then compiler willselect the method based on the following rules :

1) Most specific type (Compiler will select the specific data type)

double > float  
float > long
long > int 
int > char
int > short


------------------------------------------------------------------
package com.ravi.overloading_ambiguity;

class Test
{
	 public void accept(double ...d)
	 {
		 System.out.println("double type");
	 }
	 public void accept(float ...f)
	 {
		 System.out.println("float type");
	 }
}

public class MethodOverloading 
{
	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept();
	}

}

Note :- Here float will be executed because float is more specific type
------------------------------------------------------------------
package com.ravi.overloading_ambiguity;

class Test
{
	 public void accept(int ...d)
	 {
		 System.out.println("int type");
	 }
	 public void accept(float ...f)
	 {
		 System.out.println("float type");
	 }
}

public class MethodOverloading 
{
	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept();
	}

}

Note :- Here int will be executed because int is more specific type
-----------------------------------------------------------------
package com.ravi.overloading_ambiguity;

class Test
{
	 public void accept(int ...d)
	 {
		 System.out.println("int type");
	 }
	 public void accept(char ...f)
	 {
		 System.out.println("char type");
	 }
}

public class MethodOverloading 
{
	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept();
	}

}

Note :- Here char will be executed because char is more specific type
-----------------------------------------------------------------
package com.ravi.overloading_ambiguity;

class Test
{
	 public void accept(short ...d)
	 {
		 System.out.println("short type");
	 }
	 public void accept(char ...f)
	 {
		 System.out.println("char type");
	 }
}

public class MethodOverloading 
{
	public static void main(String[] args) 
	{
		Test t1 = new Test();
		t1.accept();
	}

}

Here we don't have any numeric relation between char and short so compiler is unable to select
------------------------------------------------------------------
package com.ravi.overloading_ambiguity;

class Test
{
	 public void accept(short ...d)
	 {
		 System.out.println("short type");
	 }
	 public void accept(byte ...f)
	 {
		 System.out.println("byte type");
	 }
}

public class MethodOverloading 
{
	public static void main(String[] args) 
	{
		Test t1 = new Test();
		t1.accept();
	}

}

Note :- Here byte will be executed because byte is more specific type
----------------------------------------------------------------
Rule 2 :
--------
While ambiguity compiler provides more priority to the nearest data type or nearest class.

package com.ravi.overloading_ambiguity;

class Test
{
	 public void accept(short s)
	 {
		 System.out.println("short type");
	 }
	 public void accept(byte b)
	 {
		 System.out.println("byte type");
	 }
}

public class MethodOverloading 
{
	public static void main(String[] args) 
	{
		Test t1 = new Test();
		//t1.accept(9);  //9 is int type so compilation error
		t1.accept((byte)9);
		t1.accept((short)90);
	}

}
------------------------------------------------------------------
package com.ravi.overloading_ambiguity;

class Test
{
	 public void accept(int s)
	 {
		 System.out.println("int type");
	 }
	 public void accept(long b)
	 {
		 System.out.println("long type");
	 }
}

public class MethodOverloading 
{
	public static void main(String[] args) 
	{
		Test t1 = new Test();  t1.accept(10);
	}

}
-----------------------------------------------------------------
package com.ravi.overloading_ambiguity;

class Test
{
	 public void accept(float s)
	 {
		 System.out.println("float type");
	 }
	 public void accept(double b)
	 {
		 System.out.println("double type");
	 }
}

public class MethodOverloading 
{
	public static void main(String[] args) 
	{
		Test t1 = new Test();  t1.accept(10);
	
	}

}

-----------------------------------------------------------------
package com.ravi.overloading_ambiguity;

class Test
{
	 public void accept(String s)
	 {
		 System.out.println("String type");
	 }
	 public void accept(Object b)
	 {
		 System.out.println("Object type");
	 }
}

public class MethodOverloading 
{
	public static void main(String[] args) 
	{
		Test t1 = new Test();  t1.accept("NIT");
	
	}

}

Here String is the nearest type.
-----------------------------------------------------------------
package com.ravi.overloading_ambiguity;

class Alpha
{
	
}
class Beta extends Alpha
{
	
}

class Test
{
	 public void accept(Alpha s)
	 {
		 System.out.println("Alpha type");
	 }
	 public void accept(Beta b)
	 {
		 System.out.println("Beta type");
	 }
}

public class MethodOverloading 
{
	public static void main(String[] args) 
	{
		Test t1 = new Test();  t1.accept(null);
	
	}

}

Here Beta will be executed.
-----------------------------------------------------------------
package com.ravi.overloading_ambiguity;

class Test
{
	 public void accept(Number s)
	 {
		 System.out.println("Number type");
	 }
	 public void accept(Integer b)
	 {
		 System.out.println("Integer type");
	 }
}

public class MethodOverloading 
{
	public static void main(String[] args) 
	{
		Test t1 = new Test();  t1.accept(null);
	
	}

}

Here Integer will be executed.
-----------------------------------------------------------------
package com.ravi.overloading_ambiguity;

class Test
{
	 public void accept(Double s)
	 {
		 System.out.println("Double type");
	 }
	 public void accept(Integer b)
	 {
		 System.out.println("Integer type");
	 }
}

public class MethodOverloading 
{
	public static void main(String[] args) 
	{
		Test t1 = new Test();  t1.accept(null);
	
	}

}

Here Compilation error, compiler is unable to decide which one is nearest type
----------------------------------------------------------------
Rule 3 :
--------
While ambiguity, compiler provides the priority on the following basis 
      [WAV -> Widening -> Auto boxing -> Var args]

package com.ravi.overloading_ambiguity;

class Test
{
	 public void accept(long s)
	 {
		 System.out.println("Widening type");
	 }
	 public void accept(Integer b)
	 {
		 System.out.println("Autoboxing type");
	 }
}

public class MethodOverloading 
{
	public static void main(String[] args) 
	{
		Test t1 = new Test();  
		t1.accept(29);	
	}
}

Compiler will provide priority to widening.
-----------------------------------------------------------------
package com.ravi.overloading_ambiguity;

class Test
{
	 public void accept(int ...s)
	 {
		 System.out.println("Var args type");
	 }
	 public void accept(Integer b)
	 {
		 System.out.println("Autoboxing type");
	 }
}

public class MethodOverloading 
{
	public static void main(String[] args) 
	{
		Test t1 = new Test();  
		t1.accept(29);	
	}
}
------------------------------------------------------------------
package com.ravi.overloading_ambiguity;

class Test
{
	 public void accept(int x, long y)
	 {
		 System.out.println("int-long");
	 }
	 public void accept(long x, int y)
	 {
		 System.out.println("long-int");
	 }
}

public class MethodOverloading 
{
	public static void main(String[] args) 
	{
		Test t1 = new Test();  
		t1.accept(29,29);	
	}
}

Compilation error
-----------------------------------------------------------------
* Method Overriding :
---------------------
Writing two or more methods in the super and sub class in such a way that method signature(method name along with method parameter) of both the methods must be same in the super and sub classes. 

While working with method overriding generally we can't change the return type of the method but from JDK 1.5 onwards we can change the return type of the method in only one case that is known as Co-Variant.

Without inheritance method overriding is not possible that means if there is no inheritance there is no method overriding.

What is the advantage of Method Overriding ?
-------------------------------------------
The advantage of Method Overriding is, each class is specifying its own specific behavior.

package com.nit.overriding;

class Animal
{
	public void eat()
	{
		System.out.println("Generic Animal is eating");
	}
}
class Dog extends Animal
{
	@Override
	public void eat()
	{
		System.out.println("Dog animal is eating");
	}
	
	
}


public class MethodOverridingDemo 
{
	public static void main(String[] args) 
	{
		Animal a = new Dog();
		a.eat(); 
	}

}
-----------------------------------------------------------------
package com.nit.overriding;

class Super
{
	private void show()
	{
		System.out.println("Private method of super class");
	}
}

class Sub extends Super
{
	
	public void show()  //own method of sub class not an overridden Method
	{
		System.out.println("public method of sub class");
	}
}
public class MethodOverridingDemo1 {

	public static void main(String[] args) 
	{
		new Sub().show();

	}

}

Note : private method of super class is not visible (not available) in the sub class so we can't override
------------------------------------------------------------------
Role of access modifier while overriding the method :
------------------------------------------------------
At the time of overriding the method, we can't reduce the visibility mode.

The access modifier of sub class method must be equal ot greater
then the access modifier of super class method.

The accessibility level of public > protected > default.

package com.nit.overriding;

class Super
{
	public void show()
	{
		System.out.println("Private method of super class");
	}
}

class Sub extends Super
{
	
	protected void show()  //error we can't reduce the visibility
	{
		System.out.println("public method of sub class");
	}
}
public class MethodOverridingDemo1 {

	public static void main(String[] args) 
	{
		new Sub().show();

	}

}
---------------------------------------------------------------
Variable Shadow :
-----------------
If the super class variable name and sub class variable name both are same, if we take the reference of super class then it will search and execute the variable from super class because variables are not overridden in java.

package com.nit.overriding;

class Bird
{
	String name = "Generic Bird";
	
    public String fly()
    {
    	return "Generic bird is flying";
    }	
}

class Koyal extends Bird
{
	String name = "Koyal Bird";
	
    public String fly()
    {
    	return "Koyal bird is flying";
    }	
}

public class MethodOverridingDemo2 {

	public static void main(String[] args) 
	{
		Bird b = new Koyal();
		
		System.out.println(b.name +" :  "+b.fly());
	}

}
---------------------------------------------------------------
Co-variant 
-----------
In general we cann't change the return type of method while overriding a method. if we try to change it will generate compilation error as shown in the program below.

class Super
{
	public  void show()
	{
	}
}
class Sub extends Super
{
	public  int show()
	{
		return 0;
	}
}


public class CoVariant 
{	
	public static void main(String[] args) 
	{ 
	 
	}
	
}

We will get compilation error, return type int is not compatible with void.
-----------------------------------------------------------------
But from JDK 1.5 onwards we can change the return type of the method in only one case that the return type of both the METHODS(SUPER AND SUB CLASS METHODS) MUST BE IN INHERITANCE RELATIONSHIP (IS-A relation ship so it is compatible) called Co-Variant as shown in the program below.

Note :- Co-variant will not work with primitive data type, it will work only with classes
------------------------------------------------------------------
class Alpha
{
}
class Beta extends Alpha
{
}

class Super
{
	public Alpha show()
	{
		System.out.println("Alpha");
		return null;
	}
}
class Sub extends Super
{
	public  Beta show()
	{
		System.out.println("Beta");
		return null;
	}
}


public class CoVariant 
{	
	public static void main(String[] args) 
	{ 
	   Super s = new Sub();
	   s.show();
	}
	
}
----------------------------------------------------------------

class Super
{
	public Super show()
	{
		System.out.println("Alpha");
		return this;
	}
}
class Sub extends Super
{
	public  Sub show()
	{
		System.out.println("Beta");
		return this;
	}
}


public class CoVariant 
{	
	public static void main(String[] args) 
	{ 
	   Super s = new Sub();
	   s.show();
	}
	
}
--------------------------------------------------------------
package com.ravi.oop;

class A{}
class B extends A{}

class Animal
{
	public A roam()
	{
		System.out.println("Generic Animal is roaming");
		return new A();
	}
}
class Dog extends Animal
{
	public B roam()
	{
		System.out.println("Dog Animal is roaming");
		return new B();
	}
}

public class CoVariantReturn {

	public static void main(String[] args)
	{
		Animal a = new Dog();
		A a1 = a.roam();
		System.out.println(a1);
	}

}

Note :- The return type of co-variant method is super class type so we can avoid ClassCastException.

---------------------------------------------------------------
17-05-2024
-----------
Method Hiding :
--------------
Case 1 :
---------
private method of a super class is not available to sub class so if we write the method with same signature then it is not an overridden method, Actually it is written by sub class, we can't write @Override annotation.

package com.ravi.oop;


class Animal
{
	private void sleep()
	{
		
	}
}
class Dog extends Animal
{
	
	public void sleep()  //own method of Dog class
	{
		
	}
}

public class CoVariantReturn {

	public static void main(String[] args)
	{
		
	}

}
---------------------------------------------------------------
Case 2 :
---------
static method of a super class is by default available to all the sub classes which are inherit from super class.

package com.ravi.oop;

class Animal
{
	public static void sleep()
	{
		System.out.println("Generic Animal is sleeping");
	}
}
class Dog extends Animal
{	
	
}

public class CoVariantReturn {

	public static void main(String[] args)
	{
		Dog.sleep();
		
		Dog d1 = new Dog();
		d1.sleep();
	}
}
---------------------------------------------------------------
case 3 :
---------
We can't override static method with non static method because static method belongs to class where as non static method belongs to object.
If we try to override we will get compilation error, Overridden method is static

class Super
{
	public static void m1()
	{
		System.out.println("Static method of super class");
	}
}
class Sub extends Super
{	
	public void m1()  
	{
		System.out.println("Static method of super class");
	    
	}
}

public class Test 
{	
	public static void main(String[] args) 
	{ 
	   
	}
	
}
---------------------------------------------------------------
case 4 :
---------
We can't override non-static method with static method because static method belongs to class where as non static method belongs to object.
If we try to override we will get compilation error, Overriding method is static

class Super
{
	public  void m1()
	{
		System.out.println("Static method of super class");
	}
}
class Sub extends Super
{	
	public static void m1()  
	{
		System.out.println("Static method of super class");
	    
	}
}

public class Test 
{	
	public static void main(String[] args) 
	{ 
	   
	}
	
}
---------------------------------------------------------------
Case 5 :
--------
Whenever we write same static method in the super and sub class 
then how we will come to know that it is method hiding not method oevrriding.

class Super
{
	public static void m1()
	{
		System.out.println("Static method of super class");
	}
}
class Sub extends Super
{	
	public static int m1()  
	{
		System.out.println("Static method of sub class");
	    return 0;
	}
}

public class Test 
{	
	public static void main(String[] args) 
	{ 
	   
	}
	
}
---------------------------------------------------------------
Case 6 :
--------
If we write static methods in the super and sub class with same signature and return type then it looks like method is overridden but actually it is method hiding, here sub class method hides super class method so it is not overriding.

We can't write @Override annotation on static method.

class Super
{
	public static void m1()
	{
		System.out.println("Static method of super class");
	}
}
class Sub extends Super
{	
	public static void m1()  
	{
		System.out.println("Static method of sub class");
	}
}

public class Test 
{	
	public static void main(String[] args) 
	{ 
	   Super s = new Sub();
	   s.m1();
	}
	
}
---------------------------------------------------------------
final keyword :
---------------
It is used to provide some kind of restriction to the program.

final keyword we can use 3 ways 

 1) To declare a class as a final (Inheritance is not possible)
 2) Method as a final(Overriding is not possible)
 3) To declare a variable OR field as final (Re-assignment is not possible)

--------------------------------------------------------------
package com.ravi.oop;

sealed class Bird permits Parrot,Sparrow
{
	public void roam()
	{
		System.out.println("Generic Bird is roaming");
	}
}
non-sealed class Parrot extends Bird
{
	public void roam()
	{
		System.out.println("Parrot Bird is roaming");
	}
}

final class Sparrow extends Bird
{
	public void roam()
	{
		System.out.println("Sparrow Bird is roaming");
	}
}

public class SealedDemo 
{
	public static void main(String[] args) 
	{
	   Bird b = null;
	   b = new Parrot(); b.roam();   //Dynamic Method Dispatch
	   b = new Sparrow(); b.roam();  //Dynamic Method Dispatch

	}

}

if we want to inherit from sealed class we need to become permitted class.
--------------------------------------------------------------
What is blank final variable :
-------------------------------
A blank final variable is variable which is declared as final but not initialized at the time of declaration.

final int A;  //Blank final variable

A blank final variable can't be iniatialized by default constructor.

public class Test 
{	
	final int A;
	public static void main(String[] args) 
	{ 
	   Test t1 = new Test();
	   System.out.println(t1.A);
	}
	
}


A blank final variable must be initialized by the user till the completion of constructor body in the following places :

   a) At the time of declaration
   b) Inside the instanec block
   c) In the body of constructor

A blank final variable we can't initialize inside a method.

A blank final variable also have default values.

A blank final variable must be initialized in all the constructor available in the class.
--------------------------------------------------------------
package com.ravi.oop;

class Foo
{
	final int A ;
	
	Foo()
	{
		A = 200;
	}
}


public class BlankFinal {

	public static void main(String[] args) 
	{
	  System.out.println(new Foo().A);	
	}

}
---------------------------------------------------------------
package com.ravi.oop;

class Sample
{
	final int A;
	
	{
		m1();
		A = 12;
	}
	
	public void m1()
	{
		System.out.println(A);
	}
}


public class BalnlFinalVariableDefault {

	public static void main(String[] args) 
	{
	System.out.println(new Sample().A);
	}

}
---------------------------------------------------------------
Object class methods :
----------------------
1) public java.lang.Class getClass() : Will give you runtime 
                                        class name

2) public native int hashCode() : To provide unique id for 
                                   every object, if hashcode 
				   of two objects are same still may be same object or different object

           String str = "A";
	   Integer i = 65;
	   
	   System.out.println(str.hashCode());  
	   System.out.println(i.hashCode());


            String str1 = "india";
	   String str2 = new String("india");
	   
	   System.out.println(str1.hashCode()+" : "+str2.hashCode()); //Same hashcode
---------------------------------------------------------------
public boolean equals(Object obj) :
---------------------------------------
It is predefined method of Object class.

It is mainly used to compare two objects besed on the memory address just like == opeartor because internally, It uses == opeartor only.


--------------------------------------------------------------
//Calling object class equals(Object obj) method for comparison 
   of Product object.  

package com.ravi.oop;

class Product
{
	private int productId;
	private String productName;
	
	public Product(int productId, String productName) 
	{
		super();
		this.productId = productId;
		this.productName = productName;
	}
}

public class EqualsComparison {

	public static void main(String[] args) 
	{
		Product p1 = new Product(111, "Camera");
		Product p2 = new Product(111, "Camera");
		
		System.out.println(p1==p2); //false
		System.out.println(p1.equals(p2)); //false

	}

}

Here we will get false and false because Object class equals() method is meant for memory reference comparison because internally it uses == operator only.
---------------------------------------------------------------
If we want to change the behaviour of object class equals(Object method) then we should override equals(Object obj) for CONTENT COMPARISON.

package com.ravi.oop;

class Product
{
	private int productId;
	private String productName;
	
	public Product(int productId, String productName) 
	{
		super();
		this.productId = productId;
		this.productName = productName;
	}
	
	
	  @Override 
	  public boolean equals(Object obj) //obj = p2
	  {
		//1st object data
	    int pid1 = this.productId;
	    String pname1 = this.productName;
	    
	    //2nd object data
	    Product p2 = (Product) obj;
	    int pid2 = p2.productId;
	    String pname2 = p2.productName;
	    
	    if(pid1 == pid2 && pname1.equals(pname2))
	    {
	    	return true;
	    }
	    else
	    {
	    	return false;
	    }
	    
	  }
	 
	
	
	
}

public class EqualsComparison {

	public static void main(String[] args) 
	{
		Product p1 = new Product(111, "Camera");
		Product p2 = new Product(111, "Camera");
		
		System.out.println(p1==p2); //false
		System.out.println(p1.equals(p2)); //false

	}

}
---------------------------------------------------------------
instanceof operator :
----------------------
It is an operator.
It retuns true/false.
While working with instanceof operator in between reference variable and class/interface type, we must have IS-A relation otherwise we will get compilation error


package com.ravi.oop;

class Product
{
	private int productId;
	private String productName;
	
	public Product(int productId, String productName) 
	{
		super();
		this.productId = productId;
		this.productName = productName;
	}
	
	
	  @Override 
	  public boolean equals(Object obj) //obj = p2
	  {
		if(obj instanceof Product)
		{
			Product p2 = (Product) obj;
			
			if(this.productId == p2.productId && this.productName.equals(p2.productName))
			{
				return true;
			}
			else
			{
				return false;
			}
		}
		else
		{
			System.err.println("Comparison is not possible");
			return false;
		}
	    
	  }
}

public class EqualsComparison {

	public static void main(String[] args) 
	{
		Product p1 = new Product(111, "Camera");
		Product p2 = new Product(111, "Camera");
		Customer c1 = new Customer(111, "Raj");
		
		
		//System.out.println(p1.equals(p2)); 
		System.out.println(p1.equals(c1));

	}

}

record Customer(int id, String name)
{
	
}

Here instanceof ensures comparison between same type of object.
---------------------------------------------------------------
Abstract class and abstract methods :
-------------------------------------------
A class that does not provide complete implementation (partial implementation) is defined as an abstract class.

An abstract method is a common method which is used to provide easiness to the programmer because the programmer faces complexcity to remember the method name.

An abstract method observation is very simple because every abstract method contains abstract keyword, abstract method does not contain any method body and at the end there must be a terminator i.e ; (semicolon)

In java whenever action is common but implementations are different then we should use abstract method, Generally we declare abstract method in the super class and its implementation must be provided in the sub classes.

if a class contains at least one method as an abstract method then we should compulsory declare that class as an abstract class.

Once a class is declared as an abstract class we can't create an object for that class.

*All the abstract methods declared in the super class must be overridden in the sub classes otherwise the sub class will become as an abstract class hence object can't be created for the sub class as well.

In an abstract class we can write all abstract method or all concrete method or combination of both the method. 

It is used to acheive partial abstraction that means by using abstract classes we can acheive partial abstraction(0-100%).

*An abstract class may or may not have abstract method but an abstract method must have abstract class.

Note :- We can't declare an abstract method as final, private and static (illegal combination of modifiers)

We can't declare abstract class as a final class.
-------------------------------------------------------------------
package com.ravi.abstract_demo;

abstract class Shape
{
	public abstract void draw();
}
class Rectangle extends Shape
{
	@Override
	public void draw() 
	{
		System.out.println("Drawing Rectangle");		
	}
	
}
class Square extends Shape
{
	@Override
	public void draw() 
	{
		System.out.println("Drawing Square");		
	}	
}

public class AbstractDemo 
{
	public static void main(String[] args)
	{
		Shape s1;
		
		s1 = new Rectangle();  s1.draw();
		s1 = new Square(); s1.draw();

	}

}

------------------------------------------------------------------
package com.ravi.abstract_demo;

abstract class Car
{
	protected int speed = 100;
	
	public Car()
	{
		System.out.println("Car class constructor");
	}
	
	public void carDetails()
	{
		System.out.println("It is a Honda Car");
	}
	
	
	public abstract void run();
	
}

class Honda extends Car
{
	@Override
	public void run() 	
	{
		System.out.println("Running Safely");		
	}	
}

public class AbstractDemo2 
{
	public static void main(String[] args) 
	{
		Car c = new Honda();
		c.carDetails();
		c.run();
		System.out.println(c.speed);

	}

}

Abstract class constructor will be excuted with the help of sub class object through super keyword.
-------------------------------------------------------------------
Anonymous inner class using concrete method:
--------------------------------------------
class Super
{
	public void show()
	{
		System.out.println("Show method of super class");
	}
}
public class Test 
{		
	public static void main(String[] args) 
	{ 
	   Super sub = new Super()
		{
		   @Override
		
	      public void show()
	      {
		    System.out.println("Show method of Sub class");
	      }
		};
		sub.show();
	}
	
}

Anonymous inner class using abstract method:
--------------------------------------------
package com.ravi.abstract_demo;

abstract class Car
{
	protected int speed = 100;
	
	public Car()
	{
		System.out.println("Car class constructor");
	}
	
	public void carDetails()
	{
		System.out.println("It is a Honda Car");
	}
	
	
	public abstract void run();
	
}

class Honda extends Car
{
	@Override
	public void run() 	
	{
		System.out.println("Running Safely");		
	}	
}

public class AbstractDemo2 
{
	public static void main(String[] args) 
	{
		Car c = new Honda();
		c.carDetails();
		c.run();
		System.out.println(c.speed);

	}

}
--------------------------------------------------------------------
package com.ravi.abstract_demo;

abstract class Alpha
{
	public abstract void show();
	public abstract void demo();
}
abstract class Beta extends Alpha
{
	@Override
	public void show()
	{
		System.out.println("Show method implmented in Beta class");
	}
}
class Gamma extends Beta
{
	@Override
	public void demo()
	{
		System.out.println("Demo method implmented in Beta class");
	}
}




public class AbstractDemo4 {

	public static void main(String[] args) 
	{
		Gamma g = new Gamma();
		g.show(); g.demo();

	}

}

Abstract method of super class must be overidden in the sub class 
-------------------------------------------------------------------
//Abstract class and abstract method with Array

package com.ravi.abstract_demo;

abstract class Animal
{
	public abstract void checkup();
}

class Lion extends Animal
{
	@Override
	 public void checkup()
	{
		System.out.println("Lion Checkup");
	}
}
class Bird extends Animal
{
	@Override
	 public void checkup()
	{
		System.out.println("Bird Checkup");
	}
}

class Dog extends Animal
{
	@Override
	 public void checkup()
	{
		System.out.println("Dog Checkup");
	}
}



public class AbstractDemo5 {

	public static void main(String[] args) 
	{
		Lion []lions = {new Lion(), new Lion(),new Lion() };
		
		Bird [] birds = {new Bird(), new Bird()};
		
		Dog [] dogs = {new Dog(), new Dog(), new Dog()};
		
		checkAnimal(lions);
		checkAnimal(dogs);
		checkAnimal(birds);
		
		
	}
	
	public static void checkAnimal(Animal [] animals)
	{
		for(Animal animal : animals)
		{
			animal.checkup();
		}
	}

}
--------------------------------------------------------------------
What is the advantage of writing constructor in the abstract class, even we can't create an object for abstract class.

Even though we can't create an object for abstract class but we can write constructor inside the abstract class to initialize the properties of abstract class by using super keyword inside sub class.

Abstract class can have properties (state OR Data) and we can initialize also without object creation.
--------------------------------------------------------------------
20-05-2024
-----------
interface (JDK 1.7)
--------------------
interface upto java 1.7
------------------------
An interface is a keyword in java which is similar to a class.It defines working functionality of the class.

Upto JDK 1.7 an interfcae contains only abstract method that means there is a guarantee that inside an interfcae we don't have concrete or general or instance methods.

From java 8 onwards we have a facility to write default and static methods.

By using interface we can achieve 100% abstraction concept because it contains only abstract methods.

In order to implement the member of an interface, java software people has provided implements keyword.

All the methods declared inside an interface is by default public and abstract so at the time of overriding we should apply public access modifier to sub class method.

All the variables declared inside an interface is by default public, static and final.

We should override all the abstract methods of interface to the sub classes otherwise the sub class will become as an abstract class hence object can't be created.

We can't create an object for interface, but reference can be created.

By using interfcae we can acheive multiple inheritance in java.

We can achieve loose coupling using inetrface.

Note :- inside an interface we can't declare any blocks (instance, static), instance variables (No properties) as well as we can't write constructor inside an interface.
-------------------------------------------------------------------
InterfaceDemo1.java
-------------------
package com.ravi.interface_demo;

interface Moveable
{
	int SPEED = 100;  //public + static + final
	void move();     //public + abstract
}

class Car implements Moveable
{
	
	@Override
	public void move() 
	{
		// SPEED = 120; -> Invalid
		System.out.println("Honda car is moving with "+SPEED+ " speed");
	}	
}

public class InterfaceDemo1 
{
	public static void main(String[] args)
	{
		Moveable m = new Car();
		m.move();
        System.out.println("Moveable Speed is :"+Moveable.SPEED);
		
		
	}

}

------------------------------------------------------------------
Program that describes, we can achieve loosely coupled application using interface :

Program on loose coupling :
----------------------------
Loose Coupling :- If the degree of dependency from one class object to another class is very low then it is called loose coupling.

Tightly coupled :- If the degree of dependency of one class to another class is very high then it is called Tightly coupled.

According to IT industry standard we should always prefer loose coupling so the maintenance of the project will become easy.

6 files :
----------
HotDrink.java(I)
-----------------
package com.ravi.loose_coupling;

public interface HotDrink 
{
   void prepare();
 
}


Tea.java(C)
-----------
package com.ravi.loose_coupling;

public class Tea implements HotDrink 
{
	@Override
	public void prepare() 
	{
		System.out.println("Preapring Tea");
	}

}


Coffee.java
------------
package com.ravi.loose_coupling;

public class Coffee implements HotDrink
{
	@Override
	public void prepare() 
	{
		System.out.println("Preapring Coffee");
	}
}


Horlicks.java
-------------
package com.ravi.loose_coupling;

public class Horlicks implements HotDrink
{
	@Override
	public void prepare() 
	{
		System.out.println("Preapring Horlicks");
	}
}


Restaurant.java
----------------
package com.ravi.loose_coupling;

public class Restaurant 
{
  public static void acceptObject(HotDrink hd)
  {
	  hd.prepare();
  }
}


LooseCoupling.java
------------------
package com.ravi.loose_coupling;

public class Main {

	public static void main(String[] args) 
	{
		Restaurant.acceptObject(new Tea());
		Restaurant.acceptObject(new Coffee());
        Restaurant.acceptObject(new Horlicks());
	}

}
------------------------------------------------------------------
Multiple Inheritance using intreface :
--------------------------------------
package com.ravi.interface_demo;

interface A
{
	public void m1();
}
interface B
{
	public void m1();
}
class Implementer implements A,B
{
	@Override
	public void m1()
	{
		System.out.println("Multiple Inheritance");
	}
}
public class MultipleInheritance {

	public static void main(String[] args) 
	{
		new Implementer().m1();
	}
}
----------------------------------------------------------------
21-05-2024
----------
New Features of Java (interface from java 1.8 onwards)
------------------------------------------------------
Limitation of abstract method :
           OR
Maintenance problem with interface in an Industry upto JDK 1.7
--------------------------------------------------------------
The major maintenance problem with interface is, if we add any new abstract method at the later stage of development inside an existing interface then all the implementer classes have to override that abstract method otherwise the  implementer class will become as an abstract class so it is one kind of boundation.

We need to provide implementation for all the abstract methods available inside an interface whether it is required or not?

To avoid this maintenance problem java software people introduced default method inside an interface.

What is default Method inside an interface?
------------------------------------------------
default method is just like concrete method which contains method body and we can write inside an interface from java 8 onwards.

default method is used to  provide  specific implementation for the implementer classes which are implmenting from interface because we can override default method inside the sub classes to provide our own specific implementation.

*By using default method there is no boundation to override the default method in the sub class, if we really required it then we can override to provide my own implementation.

by default, default method access modifier is public so at the time of overriding we should use public access modifier.
----------------------------------------------------------------
4 files :
----------
Vehicle.java(I)
----------------
package com.ravi.interface_new_features;

public interface Vehicle
{
   void run();
   void horn();
   
   default void digitalMeter()
   {
	   System.out.println("Digital Meter Facility");
   }
}


Car.java(C)
-----------
package com.ravi.interface_new_features;

public class Car implements Vehicle
{
	@Override
	public void run() 
	{
		System.out.println("Car is running");		
	}

	@Override
	public void horn() 
	{
		System.out.println("Car has horn");		
	}

	@Override
	public  void digitalMeter()
	{
		System.out.println("Car has Digital meter");
	}
}

Bike.java(C)
-------------
package com.ravi.interface_new_features;

public class Bike implements Vehicle
{
	@Override
	public void run() 
	{
		System.out.println("Bike is running");		
	}
	
	@Override
	public void horn() 
	{
		System.out.println("Bike has horn");		
	}

}

InterfaceDemo.java
--------------------
package com.ravi.interface_new_features;

public class InterfaceDemo {

	public static void main(String[] args) 
	{
		Vehicle v;
		v = new Car(); v.run(); v.horn(); v.digitalMeter();
		v = new Bike(); v.run(); v.horn();
	}

}
-----------------------------------------------------------------
Note :- abstract method is a common method which is used to provide easiness to the programmer so, by looking the abstract method we will get confirmation that this is common behavior for all the sub classes and it must be implemnted in all the sub classes.
-----------------------------------------------------------------
The following program explains that default methods are having low priority than normal methods (Concrete Method). class is having more power than interface.

4 files :
---------
A.java(I)

package com.ravi.interface_new_features;

public interface A 
{
  public default void m1()
  {
	  System.out.println("M1 method of interface A");
  }
}

B.java
-------
package com.ravi.interface_new_features;

public class B 
{
	  public void m1()
	  {
		  System.out.println("M1 method of class B");
	  }
}

C.java
------
package com.ravi.interface_new_features;

public class C extends B implements A
{

}

Main.java
---------
package com.ravi.interface_new_features;

public class Main {

	public static void main(String[] args) 
	{
		C c1 = new C();
		c1.m1();
	}

}
------------------------------------------------------------------
Multiple inheritance using default method :
-------------------------------------------
Multiple inheritance is possible in java by using default method inside an interface, here we need to use super keyword to differenciate the super interface methods.

4 files :
----------
I.java(I)
---------
package com.ravi.interface_new_features;

public interface I 
{
  public default void m1()
  {
	  System.out.println("m1 method of interface I");
  }
}

J.java(I)
----------
package com.ravi.interface_new_features;

public interface J 
{
	public default void m1()
	  {
		  System.out.println("m1 method of interface J");
	  }
}


Implementer.java(C)
-------------------
package com.ravi.interface_new_features;

public class Implementer implements I,J
{
	@Override
	public void m1() 
	{
	   I.super.m1();
	   J.super.m1();
	   System.out.println("Overridden Method");	
	}

}


ELC.java(C)
------------
package com.ravi.interface_new_features;

public class ELC {

	public static void main(String[] args) 
	{
	   new Implementer().m1();	
	}

}
------------------------------------------------------------------
What is static method inside an interface?
------------------------------------------
We can define static method inside an interface from java 1.8 onwards.

static method is only available inside the interface where it is defined that means we cannot invoke static method from the implementer classes.

It is used to provide common functionality which we can apply/invoke from any BLC/ELC class.

By default static method of an inetrafce contains public  access
modifier.

2 files :
---------
Calculate.java(I)
----------------
package com.ravi.static_demo;

public interface Calculate 
{
   static double doSum(int x, int y)
   {
	   return (x+y);
   }
   
   static double getSquare(int x)
   {
	   return (x*x);
   }
   
   
}

Main.java(C)
-------------
package com.ravi.interface_new_features;

import com.ravi.static_demo.Calculate;

public class Main {

	public static void main(String[] args) 
	{
		double result = Calculate.doSum(12, 24);
		System.out.println("Sum is :"+result);
		
		result = Calculate.getSquare(12);
		System.out.println("Square is :"+result);
	}

}

Both .java files are available in different package.
-----------------------------------------------------------------
From java 1.8v we can also main method inside interface and it will be executed.

public interface Calculate 
{
  public static void main(String[] args) 
  {
	 System.out.println("Interface Main Metheod");
  }  
   
}
-----------------------------------------------------------------
Interface Static Method:
------------------------
   a) Accessible using the interface name.
   b) Cannot be overridden by implementing classes.(Not Available)
   c) Can be called using the interface name only.

Class Static Method:
--------------------
   a) Accessible using the class name.
   b) Can be hidden (not overridden) in subclasses by redeclaring a static method with the same signature.
   c) Can be called using the super class, sub class name as well as sub class object also as shown in the program below.

-----------------------------------------------------------------
Anonymous inner class :
------------------------
We can implement an interface using anonymous inner class.

package com.ravi.anonymous;

interface Vehicle
{
	void run();
}

public class AnonymousDemo 
{
	public static void main(String[] args) 
	{
		Vehicle car = new Vehicle()
		{
			@Override
			public void run() 
			{
				System.out.println("Car is running");				
			}
			
		};
		
		Vehicle bike = new Vehicle()
		{
			@Override
			public void run() 
			{
				System.out.println("Bike is running");				
			}
			
		};
		
		car.run();
		bike.run();

	}

}
-----------------------------------------------------------------
What is a Functional Interface ?
--------------------------------
An interface which contains only one abstract method (SAM = Single abstract method) is called Functional interface.

We can provide @FunctionalInterface annoation to restrict our user to take more than one abstract method.

A functional interface may contain number of default and static method but it must have only 1 abstract method.

package com.ravi.anonymous;

@FunctionalInterface
interface RBI {
	void loan();
}

public class FunctionalInterfaceDemo {
	public static void main(String[] args) {
		RBI icici = new RBI()
		{

			@Override
			public void loan()
			{
				System.out.println("Providing loan @ 8.9%");
			}

		};
		
		RBI hdfc = new RBI()
		{

			@Override
			public void loan()
			{
				System.out.println("Providing loan @ 9.9%");
			}

		};
		
		icici.loan();  hdfc.loan();
	}
}
-----------------------------------------------------------------
22-05-2024
-----------
Lambda Expression :
----------------------
It is a new feature introduced in java from JDK 1.8 onwards.
It is an anonymous function i.e function without any name.
In java it is used to enable functional programming.
It is used to concise our code as well as we can remove boilerplate code.
It can be used with functional interface only.
If the body of the Lambda Expression contains only one statement then curly braces are optional.
We can also remove the variables type while defining the Lambda Expression parameter.
If the lambda expression method contains only one parameter then we can remove () symbol also.

In lambda expression return keyword is optional but if we use return keyword then {} are compulsory.

Independently Lamda Expression is not a statement.

It requires a target variable i.e functional interface reference only.

Lamda target can't be class or abstract class, it will work with functional interface only.
------------------------------------------------------------------
package com.ravi.lambda;

@FunctionalInterface
interface Callable
{
	void call();
}


public class LambdaDemo1 
{
	public static void main(String[] args) 
	{
		Callable c = () -> System.out.println("Calling the method");
		c.call();
	}

}
------------------------------------------------------------------
package com.ravi.lambda;

interface Calculate
{
	void doSum(int x, int y);
}


public class LambdaDemo2 {

	public static void main(String[] args) 
	{
		Calculate c1 = (c,d)-> System.out.println(c+d);
		c1.doSum(100, 200);
	}

}
------------------------------------------------------------------
package com.ravi.lambda;

interface Length
{
	int getLength(String str);
}


public class LambdaDemo3 {

	public static void main(String[] args) 
	{
		Length l =  str -> str.length();
		
		System.out.println(l.getLength("India"));
		
	}

}
------------------------------------------------------------------
package com.ravi.lambda;

public class LambdaDemo4 
{
	public static void main(String[] args) 
	{
		Runnable r1 = ()-> System.out.println(Thread.currentThread().getName());
		r1.run();
		
		Thread t1 = new Thread(r1);
		t1.start();
		
		Thread t2 = new Thread(()-> System.out.println(Thread.currentThread().getName()));
        t2.start();
	}

}
-----------------------------------------------------------------
What is type parameter in java ? 
--------------------------------
It is a technique through which we can make our application indepenedent of data type. It is represented by <T>

In java we can pass Wrapper classes as well as User-defined class to this type parameter.

We cannot pass any primitive type to this type parameter. 


package com.ravi.lambda;

class Accept<T>
{
	private T x;

	public Accept(T x)  //Student x 
	{
		super();
		this.x = x;
	}

	public T getX() 
	{
		return this.x;
	}
	
}


public class TypeParameterDemo {

	public static void main(String[] args) 
	{
	   Accept<Integer> intType = new Accept<>(90);	
	   System.out.println("Integer type :"+intType.getX());
	   
	   Accept<Double> doubleType = new Accept<>(34.90);
	   System.out.println("Double type :"+doubleType.getX());
	   
	   Accept<Student> studentType = new Accept<>(new Student(111, "A"));
	   System.out.println("Student type :"+studentType.getX());
	}

}

record Student(int id, String name)
{
	
}
----------------------------------------------------------------
Working with predefined functional interfaces :
-----------------------------------------------
In order to work in day to day programming, to write concise coding we can use predined functional interfaces.

All these predefined functional interfaces are available in java.util.function sub package.

1) Predicate<T>
2) Consumer<T>
3) Function<T,R>
4) Supplier<T>
5) BiPredicate<T,U>
6) BiConsumer<T,U>
7) BiFunction<T,R,U>

Predicate<T> functional interface  :
-------------------------------------------
It is a predefined functional interface available in java.util.function sub package.

It contains an abstract method test() which takes type parameter <T> and returns boolean value. The main purpose of this interface to test one argument boolean expression.

@FunctionalInterface
public interface Predicate<T>   
{
  boolean test(T x);
}


Note :- Here T is a "type parameter" and it can accept any type of User defined class as well as  Wrapper class like Integer, Float, Double and so on.

We can't pass primitive type.

------------------------------------------------------------------
package com.ravi.lambda;

import java.util.Scanner;
import java.util.function.Predicate;

public class PredicateDemo {

	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		//Verify number is even or odd
		Predicate<Integer> p1 =  num -> num%2==0;
		System.out.println("12 is even ?"+p1.test(12));
		System.out.println("13 is even ?"+p1.test(13));
		
		//Verify my name starts with A or not
		Predicate<String> p2 = str -> str.startsWith("A");
		System.out.print("Enter your Name :");
		String name = sc.nextLine();
		System.out.println(name +" starts with A ?"+p2.test(name));
		
		
		//Verify whether I am Ravi or not
		Predicate<String> p3 = str -> str.equals("Ravi");
		System.out.print("Enter your Name :");
		name = sc.nextLine();
		System.out.println("Are u ravi :"+p3.test(name));
		
		
		
		
	}

}

Note :- we can apply Predicate<T> where return type must be boolean type and accepting only one argument.
------------------------------------------------------------------
Consumer<T> functional interface :
-----------------------------------------
It is a predefined functional interface available in java.util.function sub package.

It contains an abstract method accept() and returns nothing. It is used to accept the parameter value or consume the value.

@FunctionalInterface
public interface Consumer<T>
{
    void accept(T x);
}

package com.ravi.funation_interface_demo;

import java.util.function.Consumer;

public class ConsumerDemo1 {

	public static void main(String[] args) 
	{
		Consumer<Integer> c1 = x -> System.out.println(x);
		c1.accept(12);
		
		Consumer<Boolean> c2 = x -> System.out.println(x);
		c2.accept(true);
		
		Consumer<Product> c3 = prod -> System.out.println(prod);
		c3.accept(new Product(111, "Mobile"));
	}

}

record Product(Integer id, String name)
{
	
}
-------------------------------------------------------------------
Function<T,R> functional interface :
-------------------------------------
Function<T,R> functional interface :
-----------------------------------------
Type Parameters:
T - the type of the input to the function.
R - the type of the result of the function.

It is a predefined functional interface available in java.util.function sub package.

It provides an abstract method apply that accepts one argument(T) and produces a result(R).

Note :- The type of T(input) and the type of R(Result) both will be decided by the user.

@FunctionalInterface
public interface Function<T,R>
{
   public abstract R apply(T x);        
}

package com.ravi.funation_interface_demo;

import java.util.function.Function;

public class FunctionDemo1 {

	public static void main(String[] args) 
	{
		//Cube of a number 
		Function<Integer, Integer> fn1 =  num -> (num*num*num);
		System.out.println(fn1.apply(2));
		
		
		//Finding the length of my city
		Function<String,Integer> fn2 =str -> str.length();
		System.out.println(fn2.apply("Hyderabad"));
		
		
		//My name starts with R or not
		Function<String,Boolean> fn3 = str -> str.startsWith("R");
		System.out.println(fn3.apply("Raj"));
				
	}

}
-----------------------------------------------------------------
Supplier<T> prdefined functional interface :
--------------------------------------------
It is a predefined functional interface available in java.util.function sub package. 

It provides an abstract method get() which does not take any argument but produces/supply a value of type T.

@FunctionalInterface
public interface Supplier<T>
{
   T get();
}

package com.ravi.funation_interface_demo;

import java.util.function.Supplier;

public class SupplierDemo {

	public static void main(String[] args) 
	{
		Supplier<String> s1 = () -> 40+40+"NIT"+45+44;
		System.out.println(s1.get());
	}

}


package com.ravi.funation_interface_demo;

import java.util.Scanner;
import java.util.function.Supplier;

record Player(int id, String name)
{
	
}

public class SupplierDemo2 {

	public static void main(String[] args) 
	{
		Supplier<Player> s1 =() ->		
		{
		  Scanner sc = new Scanner(System.in);
		  System.out.print("Enter Player id :");
		  int id = sc.nextInt();  //123 \n
		  System.out.print("Enter Player Name :");
		  String name = sc.nextLine(); //Buffer Problem
		  name = sc.nextLine();
		  return new Player(id,name);	  
		 
		};
		
		System.out.println(s1.get());
	}

}
-------------------------------------------------------------------
---------------
BiPredicate<T,U> functional interface :
-----------------------------------
It is a predefined functional interface available in java.util.function sub package.

It is a functional interface in Java that represents a predicate (a boolean-valued function) OF TWO ARGUMENTS.

The BiPredicate interface has method named test, which takes two parameters and returns a boolean value, basically this BiPredicate is same with the Predicate, instead, it takes 2 arguments for the test.

@FunctionalInterface
public interface BiPredicate<T, U> 
{
    boolean test(T t, U u);
}

Type Parameters:

T - the type of the first argument to the predicate
U - the type of the second argument the predicate
-----------------------------------------------------------------
import java.util.function.*;
public class Lambda11 
{
	public static void main(String[] args)   
    {
        BiPredicate<String, Integer> filter = (x, y) -> 
		{
            return x.length() == y;  
        };

        boolean result = filter.test("Ravi", 4);
        System.out.println(result);  

        result = filter.test("Hyderabad", 10);
        System.out.println(result);
	}
}
-----------------------------------------------------------------
import java.util.function.BiPredicate;

public class Lambda12
{
  public static void main(String[] args) 
  {
    // BiPredicate to check if the sum of two integers is even
    BiPredicate<Integer, Integer> isSumEven = (a, b) -> (a + b) % 2 == 0;

        System.out.println(isSumEven.test(2, 3));    
        System.out.println(isSumEven.test(5, 7));   
    }
}
-------------------------------------------------------------------
BiConsumer<T, U> functional interface :
---------------------------------------
It is a predefined functional interface available in java.util.function sub package.

It is a functional interface in Java that represents an operation that accepts two input arguments and returns no result.

It takes a method named accept, which takes two parameters and performs an action without returning any result.

@FunctionalInterface
public interface BiConsumer<T, U> 
{
    void accept(T t, U u);
}
-----------------------------------------------------------------
import java.util.function.BiConsumer;

public class Lambda13
{
   public static void main(String[] args) 
   {
     BiConsumer<Integer, String> updateVariables =  (num, str) -> 
		 {
            num = num * 2;
            str = str.toUpperCase();
            System.out.println("Updated values: " + num + ", " + str);
        };

        
        int number = 15;
        String text = "nit";

        updateVariables.accept(number, text);

        // Values after the update (note that the original values are unchanged)
        System.out.println("Original values: " + number + ", " + text);
    }
}
------------------------------------------------------------------
BiFunction<T, U, R> Functional interface :   
---------------------------------
It is a predefined functional interface available in java.util.function sub package.

It is a functional interface in Java that represents a function that accepts two arguments and produces a result.

The BiFunction interface has a method named apply that takes two arguments and returns a result.

@FunctionalInterface
public interface BiFunction<T, U, R> 
{
    R apply(T t, U u);
}
-------------------------------------------------------------------
import java.util.function.BiFunction;

public class Lambda14
{
  public static void main(String[] args) 
  {
        // BiFunction to concatenate two strings
    BiFunction<String, String, String> concatenateStrings = (str1, str2) -> str1 + str2;

        String result = concatenateStrings.apply("Hello", " Java");
        System.out.println(result);  


      // BiFunction to find the length two strings
    BiFunction<String, String, Integer> concatenateLength = (str1, str2) -> str1.length() + str2.length();

        Integer result1 = concatenateLength.apply("Hello", "Java");
        System.out.println(result1);  


  }
}
----------------------------------------------------------------
Interface from java 9v version
-------------------------------
Yes, From java 9 onwards we can also write private static and private non-static methods inside an interface.

These private methods will improve code re-usability inside interfaces.

For example, if two default methods needed to share common and confidential code, a private method would allow them to do so, but without exposing that private method to it s implementing classes.

Using private methods in interfaces have four rules :

1) private interface method cannot be abstract.
2) private method can be used only inside interface.
3) private static method can be used inside other static and non-static interface methods.
4) private non-static methods cannot be used inside private static methods.

package com.ravi.funation_interface_demo;

interface Moveable
{
	void m1();
	
	default void m2()
	{
		System.out.println("Default method");
		m4();
		m5();
	}
	
	static void m3()
	{
		System.out.println("static method");
		m4();
		
	}
	
	private static void m4()
	{
		System.out.println("Private static method");
	}
	
	private  void m5()
	{
		System.out.println("Private non-static method");
	}
}

class Implementer implements Moveable
{
	@Override
	public void m1()
	{
	  System.out.println("m1 method implemented");		
	}
	
}


public class InterfaceJava9 {

	public static void main(String[] args) 
	{
		Implementer i = new Implementer();
		i.m1();
		i.m2();
		Moveable.m3();

	}

}
------------------------------------------------------------------
*What is marker interface in java ?
-----------------------------------
An interface which does not contain any method and field is called marker interface. In other words, an empty interface is known as marker interface or tag interface.

*It describes run-time type information about objects, so the JVM have additional information about the object. [like object is clonable OR object is serializable OR Object is RandomAccess]

Example :
----------
public interface Drawable  //Marker interface
{
}

Note :-In java we have Clonable, Serializable and RandomAccess are predefined marker interface.


interface Cloneable //Marker interface
{


}


class Student implements Cloneable
{

}


Cloneable c = new Student();

if(c instanceof Student)
{
   //then perform the cloning information.
}

24-05-2024
-----------

** Serialization and De-serialization :
---------------------------------------
It is a technique through which we can store the object data in a file. Storing the object data into a file is called Serialization on the other hand Reading the object data from a file is called De-serialization.

In order to perform serialization, a class must implements Serializable interfcae, predefined marker interface in java.io package.

Java.io package has also provided a predfined class called ObjectOutputStream to perform serialization i.e writing Object data to a file using writeObject() method.

where as ObjectInputStream is also a predefined class available in java.io package through which we can read the Object data from a file using readObject(). The return type of readObject() is Object.

While reading the object data from the file, if the object is not available in the file then it will throw an execption java.io.EOFException. (End of file Exception)

If we want that some of our field (variable) will not serialized then we should declare that variables with transient keyword so, we will get the defualt value for the variables.

Program on Serialization and De-serialization
----------------------------------------------
3 files :
---------
Employee.java
--------------
package com.ravi.serialization_deserialization;

import java.io.Serializable;
import java.time.LocalDate;
import java.util.Scanner;

@SuppressWarnings("serial")
public class Employee implements Serializable 
{
	private  Integer employeeId;
	private  String employeeName;
	private Double employeeSalary;
	private LocalDate dateOfJoining; // HAS-A Relation

	public Employee(Integer employeeId, String employeeName, Double employeeSalary, LocalDate dateOfJoining) {
		super();
		this.employeeId = employeeId;
		this.employeeName = employeeName;
		this.employeeSalary = employeeSalary;
		this.dateOfJoining = dateOfJoining;
	}

	@Override
	public String toString() {
		return "Employee [employeeId=" + employeeId + ", employeeName=" + employeeName + ", employeeSalary="
				+ employeeSalary + ", dateOfJoining=" + dateOfJoining + "]";
	}
	
	public static Employee getEmployeeObjeect()
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter the Employee Id :");
		int id = sc.nextInt();
		
		System.out.print("Enter the Employee Name :");
		String name = sc.nextLine();
		name = sc.nextLine();
		
		System.out.print("Enter the Employee Salary :");
		double salary = sc.nextDouble();
		
		LocalDate date = LocalDate.now();
		
		return new Employee(id, name, salary, date);
		
		
	}
	

}

SerializationDemo.java
-----------------------
package com.ravi.serialization_deserialization;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.util.Scanner;

public class SerializationDemo 
{
	public static void main(String[] args) throws IOException 
	{
		var fos = new FileOutputStream("C:\\new\\Employee.txt");
		var oos = new ObjectOutputStream(fos);
		Scanner sc = new Scanner(System.in);
		
		try(fos; oos; sc)
		{
			System.out.print("How many object u want to write :");
			int noOfObjects = sc.nextInt();
			
			for(int i=1; i<=noOfObjects; i++)
			{
				Employee empObject = Employee.getEmployeeObjeect();
				oos.writeObject(empObject);
			}
			
			
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}
        System.out.println("Object data stored successfully..");
	}

}

package com.ravi.serialization_deserialization;

import java.io.EOFException;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.ObjectInputStream;

public class Deserialization {

	public static void main(String[] args) throws IOException, ClassNotFoundException 
	{
		var fin = new FileInputStream("C:\\new\\Employee.txt");
		var ois = new ObjectInputStream(fin);
		
		try(fin;ois)
		{
			Employee emp = null;
			
			while((emp = (Employee)ois.readObject()) !=null)
			{
				System.out.println(emp);
			}
		}
		catch(EOFException e)
		{
			System.err.println("End if file reached");
		}		
	}
}
---------------------------------------------------------------
Object cloning in java :
----------------------------
Object cloning is the process of creating an exact copy of an existing object in the memory.

Object cloning can be done by the following process :

1) Creating Shallow copy 

2) Creating Deep copy

3) Using clone() method of java.lang.Object class

4) Passing Object reference to the Constructor.

Shallow Copy :
-----------------
In shallow copy, we create a new reference variable which will point to same old existing object so if we make any changes through any of the reference variable then original object content will be modified.

Here we have one object and multiple reference variables.

Hashcode of the object will be same.
----------------------------------------------------------------
package com.ravi.clone_method;

class Student
{
	int id;
	String name;
	
	@Override
	public String toString() 
	{
		return "Id is :" + id + "\nName is :" + name ;
	}
	
}
public class ShallowCopy 
{
	public static void main(String[] args) 
	{
		Student s1 = new Student();
		s1.id = 111;
		s1.name = "Ravi";
        
		System.out.println(s1);
		
		System.out.println("After Shallow Copy");
		
		Student s2 = s1; //shallow copy
		s2.id = 222;
		s2.name = "Shankar";
		
		System.out.println(s1);
		System.out.println(s2);
		
		System.out.println(s1.hashCode());
		System.out.println(s2.hashCode());
	}

}
----------------------------------------------------------------
Deep Copy :
--------------
In deep copy, We create a copy of object in a different memory location. This is called a Deep copy. 

Here objects are created in two different memory locations so if we modify the content of one object it will not reflect another object.

package com.ravi.clone_method;

class Employee
{
	int id;
	String name;
	
	@Override
	public String toString() 
	{
		return "Employee [id=" + id + ", name=" + name + "]";
	}	
}

public class DeepCopy 
{
	public static void main(String[] args)
	{
		Employee e1 = new Employee();
		e1.id = 111;
		e1.name = "Ravi";
		
		Employee e2 = new Employee();
		e2.id = e1.id;
		e2.name = e1.name;
		
		System.out.println(e1 +" : "+e2);
		
		e2.id = 222;
		e2.name = "shankar";
		System.out.println(e1 +" : "+e2);
		
		System.out.println(e1.hashCode() +" : "+e2.hashCode());
	}

}
---------------------------------------------------------------
Steps to create duplicate object by using clone() method of Object class

1) A class must implements from Cloneable interface as well as 
   should overide clone() method from Object class.

2) At the time of calling clone() method we need to handle the 
   code (try-catch OR throws)

3) clone() method return type is Object so, downcasting is required. It creates a duplicate object which follws deep copy.


protected native Object clone() throws CloneNotSupportedException
---------------------------------------------------------------
Object cloning in Java is the process of creating an exact copy of the original object. In other words, it is a way of creating a new object by copying all the data and attributes from the original object. 

The clone method of Object class creates an exact copy of an object.

In order to use clone() method , a class must implements Clonable interface because we can perform cloning operation on Cloneable objects only [JVM must have additional information].

We can say an object is a Cloneable object if the corresponding class implements Cloneable interface.

It throws a checked Exception i.e CloneNotSupportedException

Note :- clone() method is not the part of Clonable interface[marker interface], actually it is the method of Object class.

clone() method of Object class follow deep copy concept so hashcode will be different.
---------------------------------------------------------------
package com.ravi.clone_method;

class Customer implements Cloneable
{
	int id;
	String name;
	
		
	@Override
	protected Object clone() throws CloneNotSupportedException 
	{
		return super.clone();
	}
	
	

	@Override
	public String toString()
	{
		return "Customer [id=" + id + ", name=" + name + "]";
	}	
}

public class CloneMethod 
{
	public static void main(String[] args) throws CloneNotSupportedException 
    {
		Customer c1 = new Customer();	
		c1.id = 222;
		c1.name = "Rahul";
		
		Customer c2 = (Customer) c1.clone(); //deep copy
		c2.id = 333;
		c2.name = "Rohit";
		
		System.out.println(c1);
		System.out.println(c2);
		
		System.out.println(c1.hashCode());
		System.out.println(c2.hashCode());
		
		
	}

}
--------------------------------------------------------------
****What is difference between abstract class and interface ?
---------------------------------------------------------------
The following are the differences between abstract class and interface.

1) An abstract class can contain instance variables but interface variables are by default public , static and final.

2) An abstract class can have state (properties) of an object but interface can't have state of an object.

3) An abstract class can contain constructor but inside an interface we can't define constructor.

4) An abstract class can contain instance and static blocks but inside an interface we can't define any blocks.

5) Abstract class can't refer Lambda expression but using Functional interface we can refer Lambda Expression.	

6) We can write concrete method inside an abstract class but inside an interface we can't write concrete public method, only abstract , default, static and private methods are allowed.

---------------------------------------------------------------
25-05-2024
----------
Exception Handling :
---------------------
What is an execption ?
----------------------
An execption is a runtime error.

An execption is an abnormal situation or un-expected situation in a noraml execution flow.

An exception encounter due to dependency, if one part of the program is dependent to another part then there might be a chance of getting Exception.

AN EXCEPTION ALSO ENCOUNTER DUE TO WRONG INPUT GIVEN BY THE USER.
---------------------------------------------------------------
Exception Hierarchy :
--------------------
This Exception hierarchy is available in the diagram (Exception_Hierarchy.png)

Note :- As a developer we are responsibe to handle the Exception. System admin is responsibe to handle the error because we cannot recover from error.
------------------------------------------------------------------
Exception Criteria :
---------------------
1) java.lang.ArithmeticException
   Whenever we divide a number by 0 (an int value) then we will 
   get java.lang.ArithmeticException.

   Example :   System.out.println(10/0);	

2) java.lang.ArrayIndexOutOfBoundsException
   Whenever we try to acees the index of Array but if the index is
   not available (out of bound) then we will get ArrayIndexOutOfBoundsException.

   int arr[] = {10,20,30};
   System.out.println(arr[3]);

3) java.lang.NumberFormatException
   Whenever we try to convert String value into corresponding 
   integer but the String value is not in a proper format
   then we will get java.lang.NumberFormatException

   String str = "Ravi";
   int no = Integer.parseInt(str);

4) java.lang.NullPointerException
   If a reference variable is pointing to null and from that reference variable, if we call any non static method then we will get
   java.lang.NullPointerException

   String str = null;
   System.out.println(str.length());

5) java.lang.NegativeArraySizeException
   The size of the array must not be negative.

   int []arr = new int[-9];

6) java.util.InputMismatchException
   If we take the input but the user and input is not in a proper format then we will get java.util.InputMismatchException

   Scanner sc = new Scanner(System.in);
   System.out.println("Enter Your Age :");
   int age = sc.nextInt();  //input is eleven
   System.out.println("Age is :"+age);
-----------------------------------------------------------------
WAP tp describe that Exception is the super class of all the execption we have in java.

package com.ravi.exception;

public class Test {

	public static void main(String[] args) 
	{
		Exception e1 = new ArithmeticException();
		System.out.println(e1);
		
		Exception e2 = new ArithmeticException("Error Message");
		System.out.println(e2);

	}

}

Format of Exception :
----------------------
Package Name + Class Name : Error Message
-----------------------------------------------------------------
WAP that describes that whenever an exception encounter in the program then program will be terminated in the middle.

package com.ravi.exception;

import java.util.Scanner;

public class ExceptionDemo 
{
	public static void main(String[] args) 
	{
		System.out.println("Main method started..");
		Scanner sc = new Scanner(System.in);
		
		System.out.print("Enter the value of x :");
		int x = sc.nextInt();
		
		System.out.print("Enter the value of y :");
		int y = sc.nextInt();
		
		int res = x/y; //[if y value is 0 then program will halt]
		System.out.println("Result is :"+res);
		
		System.out.println("Main method ended..");
		sc.close();


	}

}

Note :- In the above program if the value of y will be 0 then our program will halt in the middle, it is called abnormal termination so, JVM is having default exception handler, which will terminate the program and provide the appropriate message.
-----------------------------------------------------------------
OOP has provided the folllowing keyword to work with exception

1) try block
2) catch block
3) finally block (try with resourses)
4) throw
5) throws

try block :
-----------
Whenever our statement is error suspecting statement OR Risky statement then we should write that statement inside the try block.

try block must be followed either by catch block or finally block or both.

*try block is responsible to trace our code line by line, if any execption encounter then TRY BLOCK WILL CREATE APPROPRIATE EXECPTION OBJECT WITH THE HELP OF JVM, AND THROW THIS EXCEPTION OBJECT to the nearest catch block.

After the execption in the try block, the remaining code of try block will not be executed because control will directly transfer to the catch block.

In between try and catch block we cannot write any kind of statement.

catch block :
--------------
The main purpose of catch block to handle the exception which is thrown by try block.

catch block will only executed if there is an exception in the try block.
package com.ravi.exception;

import java.util.Scanner;

public class ExceptionDemo 
{
	public static void main(String[] args) 
	{
		System.out.println("Main method started..");
		Scanner sc = new Scanner(System.in);
		
		try
		{
			System.out.print("Enter the value of x :");
			int x = sc.nextInt();
			
			System.out.print("Enter the value of y :");
			int y = sc.nextInt();
			
			int res = x/y; //[if y value is 0 then program will halt]
			System.out.println("Result is :"+res);
			System.out.println("End of try");
		}
		catch(Exception e)
		{
			System.out.println("Inside catch");
			System.err.println(e);
		}
		System.out.println("Main method ended..");
		sc.close();


	}

}

Note :- The above program in the protection of try-catch so, even we have an exception (y=0) but program will be terminated normally.
-----------------------------------------------------------------
Program to describe try block is responsible to cretea the exception object and throw the exception object to the nearest catch block.

package com.ravi.exception;

public class ThrowingException {

	public static void main(String[] args) 
	{
		try
		{
			//System.out.println(10/0);
			
			throw new ArithmeticException();
			
		}
		catch(Exception e)
		{
			System.err.println("Divide by zero problem");
		}

	}

}
------------------------------------------------------------------
package com.ravi.exception;

import java.util.Scanner;

public class CustomerDemo 
{
	public static void main(String[] args) 
	{
		System.out.println("Welcome Client, Welcome to my application");
		
		Scanner sc = new Scanner(System.in);
        try
        {
        	System.out.print("Enter the value of x :");
            int x = sc.nextInt();
            System.out.print("Enter the value of y :");
            int y = sc.nextInt();
            
            int result = x/y;
            System.out.println("Result is :"+result);
        }
        catch(Exception e)
        {
        	System.err.println("Please don't put zero here");
        }
        System.out.println("Thank you for Visiting my application");
        sc.close();
	}

}

The main purpose of Exception Handling to provide user-friendly message to the client.
------------------------------------------------------------------
Throwable class method :
------------------------
Throwable class has provided the following three methods :

1) public String getMessage() :- It will provide only error message.

2) public void printStackTrace() :-  It will provide the complete details regarding exception like exception class name, exception message, exception class location, exception method name and exception line number.

3) public String toString() :- It will convert the exception into
                               String representation.

package com.ravi.exception;

public class ThrowingException {

	public static void main(String[] args) 
	{
		try
		{
			System.out.println(10/0);			
		}
		catch(Exception e)
		{
			System.err.println(e.getMessage());
			System.out.println("........................");
			e.printStackTrace();
			System.out.println("...............");
			System.out.println(e.toString());
		}

	}

}
------------------------------------------------------------------
Working with Specific Exception :
---------------------------------
While working with exception, in the corresponding catch block we can take Exception (super class) which can handle any type of Exception.

On the other hand we can also take specific type of exception (ArithmetiException, NullPointerException and so on) which will handle only one type i.e specific type of exception.
-----------------------------------------------------------------
package com.ravi.basic;

import java.util.InputMismatchException;
import java.util.Scanner;

public class SpecificException 
{
	public static void main(String[] args) 
	{
		System.out.println("Main started");
		
		Scanner sc = new Scanner(System.in);
		
		try
		{			
			System.out.print("Enter your Roll :");
			int roll = sc.nextInt();
			System.out.println("Your Roll is :"+roll);
		}
		catch(InputMismatchException e)
		{
			System.err.println("Input is not in proper format");
		}
		sc.close();
		System.out.println("Main ended");
	}
}
-------------------------------------------------------------------
27-05-2024
-----------
Working with Infinity and Not a number(NaN) :
---------------------------------------------
10/0    -> Infinity (Java.lang.ArithmeticException)
10/0.0  -> Infinity  (POITIVE_INFINITY)

0/0     -> Undefined (Java.lang.ArithmeticException)
0/0.0   -> Undefined  (NaN)


While working with Integral literal in both the cases i.e Infinity (10/0) and Undefined (0/0) we will get java.lang.ArithmeticException because java software people has not provided any final, static variable support to deal with Infinity and Undefined so we will get java.lang.ArithmeticException and program will halt in the middle.

On the other hand while working with floating point literal in the both cases i.e Infinity (10/0.0) and Undefined (0/0.0) we have final, static variable support so the program will not be terminated in the middle which are as follows

10/0.0 = POSITIVE_INFINITY
-10/0.0 = NEGATIVE_INFINITY
0/0.0 = NaN

package com.ravi.basic;

public class InfinityFloatingPoint 
{	
	public static void main(String[] args) 
	{
	   System.out.println("Main Started");
	   System.out.println(10/0.0); 
	   System.out.println(-10/0.0); 
	   System.out.println(0/0.0);   
	   System.out.println(10/0); 
	   System.out.println("Main Ended");
	}

}
-------------------------------------------------------------------
Working with multiple try catch :
---------------------------------
According to our application requirement we can provide multiple try-catch in my application to work with multiple execptions.


package com.ravi.basic;
public class MultipleTryCatch 
{
	public static void main(String[] args) 
	{
	  System.out.println("Main method started!!!!");
	  
	  try
	  {
		  int arr[] = {10,20,30};
		  System.out.println(arr[3]);
	  }
	  catch(ArrayIndexOutOfBoundsException e)
	  {
		  System.err.println("Array index is out of limit!!!");
	  }
	  
	  try
	  {
		 String str = null;
		 System.out.println(str.length());
	  }
	  catch(NullPointerException e)
	  {
		  System.err.println("ref variable is pointing to null");
	  } 
	  
	  System.out.println("Main method ended!!!!");	
	}
}

Here the limitation we will get all the exception message at a time so for user it is difficult to deal with all the exceptions at a time.
-------------------------------------------------------------------
* Single try with multiple catch block :
-----------------------------------------
According to industry standard we should write try with multiple catch block so we can provide proper information for each and every exception.

While working with multiple catch block always the super class catch block must be last catch block.

From java 1.7 this multiple catch block we can also represent by using | symbol.

If try block is having more than one exception then always try block will handle only first exception because control will transfer to the nearest catch block.

package com.ravi.basic;
public class MultyCatch 
{
	public static void main(String[] args) 
	{
		System.out.println("Main Started...");		
		try
		{
			int c = 10/0;			
			System.out.println("c value is :"+c);	
			
			int []x = {12,78,56};
			System.out.println(x[3]);			
		}		
		
		catch(ArrayIndexOutOfBoundsException e1)
		{
			System.err.println("Array is out of limit...");
		}
		catch(ArithmeticException e1)
		{
			System.err.println("Divide By zero problem...");
		}
		catch(Exception e1)
		{
			System.out.println("General");
		}	
						
		System.out.println("Main Ended...");
	}
}
-------------------------------------------------------------------
package com.ravi.basic;

public class MultyCatch1 
{
	public static void main(String[] args) 
	{
		System.out.println("Main method started!!!");
		try
		{
		   String str1 = "null";
		   System.out.println(str1.toUpperCase());
		   
		   String str2 = "Ravi";
		   int x = Integer.parseInt(str2);
		   System.out.println("Number is :"+x);
		}
		catch(NumberFormatException | NullPointerException  e)
		{
			e.printStackTrace();
		}

		System.out.println("Main method ended!!");
	}

}
-------------------------------------------------------------------
finally block :
---------------- 
finally is a block which is meant for Resource handling purposes.

According to Software Engineering, the resources are memory creation, buffer creation, opening of a database, working with files, working with network resourses and so on.

Whenever the control will enter inside the try block always the finally block would be executed.

We should write all the closing statements inside the finally block because irrespective of exception finally block will be executed every time.

If we use the combination of try and finally then only the resources will be handled but not the execption, on the other hand if we use try-catch and finally then execption and resourses both will be handled.

We should always write all the closing statements inside finally block.
-------------------------------------------------------------------
package com.ravi.basic;

public class FinallyBlock 
{
	public static void main(String[] args) 
	{
		System.out.println("Main method started");
		
		try
		{			
			System.out.println(10/0);			
		}
		
		finally
		{	
			System.out.println("Finally Block");
		}
		
		System.out.println("Main method ended");
	}

}

Note :- In the above program finally block will be executed, even we have an exception in the try block.
----------------------------------------------------------------
package com.ravi.basic;

public class FinallyWithCatch 
{
	public static void main(String[] args) 
	{	
		
		try
		{			
		    int []x = new int[-2];	//We can't pass negative size of an array in negative
		    x[0] = 12;
		    x[1] = 15;
		    System.out.println(x[0]+" : "+x[1]);
		   
		}
		catch(NegativeArraySizeException e)
		{		
			System.err.println("Array Size is in negative value...");
		}
		finally
		{
		   System.out.println("Resources will be handled here!!");		   
		}
		System.out.println("Main method ended!!!");
	}
}
-------------------------------------------------------------------
Limitation of finally block :
-----------------------------
The following are the limitations of finally block :

1) User is responsible to close the resources manually.
2) Due to finally block the length of the code will be increased.
3) While using finally block we should declare all our resources 
   outside of the try block otherwise the resourses will become 
   block level variable.

package com.ravi.basic;

import java.util.InputMismatchException;
import java.util.Scanner;

public class FinallyLimitation 
{
	public static void main(String[] args) 
	{
		Scanner sc = null;
		try
		{
			sc = new Scanner(System.in);
			System.out.print("Enter your Employee Number :");
			int eid = sc.nextInt();
			System.out.println(eid);			
		}
		catch(InputMismatchException e)
		{
			System.err.println("Input is not in a proper format");
		}
		finally
		{
			sc.close();
			System.out.println("Scanner resource handled");
		}
	}

}
------------------------------------------------------------------
try with resources :
--------------------
To avoid all the limitation of finally block, Java software people introduced a separate concept i.e try with resources from java 1.7 onwards.

Case 1:
-------
try(resource1 ; resource2)  //Only the resources will be handled
{
}

Case 2 :
----------
//Resources and Exception both will be  handled
try(resource1 ; resource2) 
{                          
}
catch(Exception e)
{
}

Case 3 :
----------
//Resources and Exception both will be  handled
Resourse resource1 = new Resource();

try(resource1) //java 9 onwards
{                          
}
catch(Exception e)
{
}



There is a predefined interface available in java.lang package called AutoCloseable which contains predefined abstract method i.e close() which throws Exception.

There is another predefined interface available in java.io package called Closeable, this Closeable interface is the sub interface for Auto Closeable interface.

public interface java.lang.AutoCloseable
{
   public abstract void close() throws Exception;
}

public interface java.io.Closeable extends java.lang.AutoCloseable
{
   void close() throws IOException;
}

Whenever we pass any resourse class as part of try with resources then that class must implements either Closeable or AutoCloseable interface so, try with resourses will automatically call the respective class
close() method even an exception is encountered in the try block.

try(ResourceClass rc = new ResourceClass())  
{                                              
}                                               
catch(Exception e)                             
{                                          

}

//This ResourceClass must implements either Closeable or AutoCloseable interface so, try block will automatically call the close() method.


The following program explains how to call close() method for both the resourse classes i.e DatabaseResourse and FileResourse which are implementing java.lang.AutoCloseable and java.io.Closeable respectively.

3 files :
----------
DatabaseResourse.java
----------------------
package com.ravi.resourses;

public class DatabaseResourse implements AutoCloseable
{
	@Override
	public void close() throws Exception 
	{
		System.out.println("Database resourse closed successfully");
		
	}

}


FileResourse.java
------------------
package com.ravi.resourses;

import java.io.Closeable;
import java.io.IOException;

public class FileResourse implements Closeable
{
	@Override
	public void close() throws IOException 
	{
		System.out.println("File resourse closed successfully");		
	}

}

ELC.java
---------
package com.ravi.resourses;

public class ELC {

	public static void main(String[] args)  throws Exception
	{
		DatabaseResourse dr = new DatabaseResourse();
		FileResourse fr = new FileResourse();
		
		try(dr; fr)
		{
			System.out.println(10/0);
		}
	}

}
------------------------------------------------------------------

package com.ravi.try_with_resource_1;

import java.util.InputMismatchException;
import java.util.Scanner;

public class TryWithResource
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		try(sc)
		{			
			System.out.print("Enter your Age :");
			int age = sc.nextInt();
			System.out.println("Your Age is :"+age);
		}
		catch(InputMismatchException e)
		{
			System.err.println("Input Mismatched Exception");
			
		}
		System.out.println("Reached Destination");
	}
}
-------------------------------------------------------------------
Nested try block :
------------------
If we write a try block inside another try block then it is called Nested try block.

try  //Outer try             
{
  statement1;
     try  //Inner try
     {
        statement2;
     }
     catch(Exception e) //Inner catch
     {
     }

}
catch(Exception e) //Outer Catch
{
}

The execution of inner try block depends upon outer try block that means if we have an exception in the Outer try block then inner try block will not be executed.

package com.ravi.basic;

public class NestedTryBlock 
{
	public static void main(String[] args) 
	{		
	      try  //outer try
	      {
	    	    String x = "India";
	    	    System.out.println("It's length is :"+x.length());
	    	        
		    	  try  //inner try
		    	  {
		    		 String y = "NIT"; 
		    		 int z = Integer.parseInt(y);
		    		 System.out.println("z value is :"+z);	    				    		  
		    	  }
		    	  catch(NumberFormatException e)
		    	  {
		    		System.err.println("Number is not in a proper format");  
		    	  }
	      }
	      catch(NullPointerException e)
	      {
	    	  System.err.println("Null pointer Problem"); 	    	 
	      }	      
	}
}
------------------------------------------------------------------
Writing try-catch inside catch block :
---------------------------------------
We can write try-catch inside catch block but this try-catch block will be exceuted if the catch block will execute that means if we have an exception in the try block.

package com.ravi.basic;

import java.util.InputMismatchException;
import java.util.Scanner;

public class TryWithCatchInsideCatch 
{	
	public static void main(String[] args)
	{
		Scanner sc = new Scanner(System.in);
		
		try(sc )
		{			
			System.out.print("Enter your Roll number :");
			int roll = sc.nextInt();
			System.out.println("Your Roll is :"+roll);			
			
		}	
		catch(InputMismatchException e)
		{
			System.err.println("Provide Valid input!!");
			
			try
			{
				System.out.println(10/0);
			}
			catch(ArithmeticException e1)
			{
			  System.err.println("Divide by zero problem");	
			}
			
		}
	}

}
-------------------------------------------------------------------
try-catch with return statement
-------------------------------
If we write try-catch block inside a method and that method is returning some value then we should write return statement in both the places i.e inside the try block as well as inside the catch block.

We can also write return statement inside the finally block only, if the finally block is present. After this return statement we cannot write any kind of statement. (Unrechable)

Always finally block return statement having more priority then try-catch return statement.


public  class Test 
{
	public static void main(String[] args) 
	{     
	     System.out.println(accept()); 
	}

	public static int accept()
	{
		try
		{

			return 10;
		}
		catch (Exception e)
		{
			e.printStackTrace();
			return 20;
		}
		finally
		{
			return 30;
		}
		//System.out.println("Hello");
	}
}
-------------------------------------------------------------------
Initialization of a variable in try and catch :
-----------------------------------------------
A local variable must be initialized inside try block as well as catch block OR at the time of declaration.

If we initialize inside the try block only then from catch block we cannot access local variable value, Here initialization is compulsory inside catch block.

public  class Test 
{
	public static void main(String[] args) 
	{     
	   int i;
	   try
	   {

		  i=100;
		  System.out.println(i);
	   }
	   catch (Exception e)
	   {
		   i=100;
		   System.out.println(i);
	   }
	}
	
}
------------------------------------------------------------------
**Difference between Checked Exception and Unchecked Exception :
----------------------------------------------------------------
Checked Exception :
----------------------
In java some exceptions are very common exceptions are called Checked excption here compiler takes very much care and wanted the clarity regarding the exception by saying that, by using this code you may face some problem at runtime and you did not report me how would you handle this situation at runtime are called Checked exception, so provide either try-catch or declare the method as throws.

All the checked exceptions are directly sub class of java.lang.Exception

Eg:
---
FileNotFoundException, IOException, InterruptedException,ClassNotFoundException, SQLException, CloneNotSupportedException and so on

Unchecked Exception :-
--------------------------
The exceptions which are rarely occurred in java and for these kinds of exception compiler does not take any care are called unchecked exception.

Unchecked exceptions are directly entertain by JVM because they are rarely occurred in java.

All the un-checked exceptions are sub class of RuntimeException

Eg:
---
ArithmeticException, ArrayIndexOutOfBoundsException, NullPointerException, NumberFormatException, ClassCastException, ArrayStoreException and so on.
-----------------------------------------------------------------
Some Bullet points regarding Checked and Unchecked :
-----------------------------------------------------
Checked Exception :
------------------
  1) Common Exception
  2) Compiler takes care (Will not compile the code)
  3) Handling is compulsory (try-catch OR throws)
  4) Directly the sub class of java.lang.Exception

Unchecked Exception :
----------------------
  1) Rare Exception
  2) Comiler will not take any care
  3) Handling is not Compulsory
  4) Sub class of RuntimeException
-------------------------------------------------------------------
When to provide try-catch or declare the method as throws :-
-------------------------------------------------------------------
We should provide try-catch if we want to handle the exception by own as well as if we want to provide user-defined messages to the client but on the other hand we should declare the method as throws when we are not interested to handle the exception and try to send it to the JVM for handling purpose. 

Note :- It is always better to use try catch so we can provide appropriate user defined messages to our client.
-----------------------------------------------------------------
*Why compiler takes very much care regarding the checked Exception ?
------------------------------------------------------------------
As we know Checked Exceptions are very common exception so in case of checked exception "handling is compulsory" because checked Exception depends upon other resources as shown below.

IOException  (we are depending upon System Keyboard OR Files )
FileNotFoundException(We are depending upon the file)
InterruptedException (Thread related problem)
ClassNotFoundException (class related problem)
SQLException (SQL related or database related problem)
CloneNotSupportedException (Object is the resourse)
------------------------------------------------------------------
Difference between throw and throws :
--------------------------------------
* What is the difference between throw and throws :
----------------------------------------------------
throw :
--------
In case of predefined exception, try block is responsible to create the exception object and throw the exception object to the nearest catch block but it works with predefined exception only implicitly.

If a user wants to throw an exception based on his own requirement and specification by using userdefined exception then we should write throw keyword to throw the user defined exception object explicitly. (throw new InvalidMarksException())

THROWING THE EXCEPTION OBJCET EXPLICITLY.

throws :- 
---------
In case of checked Exception if a user is not interested to handle the exception and wants  to throw the exception to JVM, wants to skip from the current situation then we should declare the method as throws.
It is mainly used to work with Checked Exception.
-------------------------------------------------------------------
Some important rules regarding checked Exception :
--------------------------------------------------
a) If the try block does not throw any checked exception then in the corresponding catch block we can't handle checked exception.It will generate compilation error i.e "exception never thrown from the corresponding try statement"

Example :-

try
{
  //try block is not throwing any checked Exception
}
catch(IOException e) //Error
{

}

CatchingCheckedWithoutThrow.java

package com.ravi.method_related_rule;

import java.io.IOException;

public class CatchingCheckedWithoutThrow 
{
	public static void main(String[] args) 
	{
		try
		{
			//throw new IOException();
		}
		catch(IOException e)  //error
		{
			System.err.println("Input Output Exception");
		}

	}

}

Note :- The above rule is not applicable for Unchecked Exception

               try
		{
			
		}
		catch(ArithmeticException e)  //Valid
		{
			e.printStackTrace();
		}
------------------------------------------------------------------
b) If the try block does not throw any exception then in the corresponding catch block we can write Exception, Throwable because both are the super classes for all types of Exception whether it is checked or unchecked.


public  class Test 
{
	public static void main(String[] args) 
	{     
		try
		{
			
		}
		catch (Throwable e)  //Throwable OR Exception both
		{                       are allowed
			e.printStackTrace();
		}
	    System.out.println("Hello");
	 
	}
	
}
------------------------------------------------------------------
c) At the time of method overriding if the super class method does 
   not reporting or throwing checked exception then the overridden method of sub class not allowed to throw checked exception. otherwise it will generate compilation error but overridden method can throw Unchecked Exception.

   package com.ravi.method_related_rule;

import java.io.IOException;

class Super
{
	public void show()  
	{
		System.out.println("Super class method not throwing checked Exception");
	}
}
class Sub extends Super
{
	@Override
	public void show() //throws IOException  [error]
	{
		System.out.println("Sub class method should not throw checked Exception");
	}
}

public class MethodOverridingWithChecked {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
-------------------------------------------------------------------
d) If the super class method declare with throws keyword to throw a checked exception, then at the time of method overriding, sub class method may or may not use throws keyword.
               If the Overridden method is also using throws
 keyword to throw checked exception then it must be either same exception class or sub class, it should not be super class as well as we can't add more exceptions in the overridden method.

package com.ravi.method_related_rule;

import java.io.FileNotFoundException;
import java.io.IOException;

class Base
{
	public void show() throws FileNotFoundException
	{
		System.out.println("Super class method ");
	}
}
class Derived extends Base
{
	public void show() throws FileNotFoundException
	{
		System.out.println("Sub class method ");
	}
}

public class MethodOverridingWithThrows 
{
	public static void main(String[] args) 
	{
	  System.out.println("Overridden method may or may not throw checked exception but if it is throwing then must be same or sub class");	
	}

}
-------------------------------------------------------------------
Initializer must be complete normally (In static block and non static block abnormal termination is not possible)

class Check
{
          static
	  {
	   throw new Exception();  //error
	  }
}
public class Test
{
  public static void main(String [] args)
  {
	 
     
  }
}
------------------------------------------------------------
package com.ravi.exception;

class Test
{
	static
	{
		try
		{
			throw new Exception("My Error Message");
		}
		catch(Exception e)
		{
			System.err.println("Inside Catch block");
			System.err.println(e);
		}
	}
}

public class Main {

	public static void main(String[] args) 
	{
		new Test();

	}

}
The above code is valid.
------------------------------------------------------------------
30-05-2024
------------
Exception propagation :-  [Exception object will shift from callee to caller]
--------------------------
Whenever we call a method and if the the callee method contains any kind of exception and if callee method doesn't contain any kind of exception handling mechanism (try-catch) then JVM will propagate the exception to caller method for handling purpose. This is called Exception Propagation.

If the caller method also does not contain any exception handling mechanism then JVM will terminate the method from the stack frame hence the remaining part of the method(m1 method) will not be executed even if we handle the exception in another caller method like main.

If any of the the caller method does not contain any exception handling mechanism then exception will be handled by JVM, JVM has default exception handler which will provide the exception message and terminates the program abnormally.

package com.ravi.exception;

public class ExceptionPropagation {

	public static void main(String[] args) 
	{
		System.out.println("Main method started");
		try
		{
			m1();
		}
		catch(ArithmeticException e)
		{
			System.out.println("Hndled in main method");
		}
		System.out.println("Main method ended");
	}
	
	public static void m1()
	{
        System.out.println("m1 method started");
		m2();
		System.out.println("m1 method ended");
	}
	
	public static void m2()
	{
		System.out.println(10/0);
	}

}
-----------------------------------------------------------------
* Whenever we call a method and if the method is throwing any checked exception then for caller method we need to provide either try-catch Or declare the method throws that means normal termination.

package com.ravi.exception;

public class Propagation {

	public static void main(String[] args) 
	{
		try
		{
			accept();
		}
		catch(InterruptedException e)
		{
			
		}
	}

	public static void accept() throws InterruptedException
	{
		
	}
}
------------------------------------------------------------------
Types of exception in java :
-------------------------------
Exception can be divided into two types :

1) Predefined Exception OR Built-in Exception

2) Userdefined Exception OR Custom Exception

Predefined Exception :-
-------------------------
The Exceptions which are already defined by Java software people for some specific purposes are called predefined Exception or Built-in exception.
Ex :
----
IOException, ArithmeticException and so on

Userdefined Exception :-
---------------------------
The exceptions which are defined by user according to their own use and requirement are called User-defined Exception.

Ex:-
----
InvalidAgeException, GreaterMarksException
-----------------------------------------------------------------------
Steps to create userdefined exception :
------------------------------------------
In order to create user defined exception we should follow the following steps.

1) A userdefined exception class must extends either Exception(Checked Exception) Or RuntimeException(Unchecked Exception) as a super class.

    a) If our userdefined class extends RuntimeException that menas we are creating UncheckedException.

    b) If our userdefined class extends Exception that menas we are creating checkedException and exception handling is compulsory here.

2) The userdefined class must contain No argument constructor as well as parameterized construtor(in case we want to pass some userdefined error message).

   We should take No argument constructor if we don't want to send any error message where as we should take parameterized constructor with super keyword if we want to send the message to the super class.

3) We should use throw keyword to throw the Exception object explicitly.
------------------------------------------------------------------
Assignment :
-------------
Create InvalidAgeException class as a checked Exception where we 
need to throw the exception with proper error message  if age is less than 18
-----------------------------------------------------------------
Create GreaterMarksException as a Unchecked Exception where we need to throw the exception with proper error message if marks is greater than 100 
------------------------------------------------------------------
Multithreading :
----------------
Multithreading :
----------------
Uniprocessing :- 
----------------
In uniprocessing, only one process can occupy the memory So the
major drawbacks are 

1) Memory is westage
2) Resources are westage
3) Cpu is idle

To avoid the above said problem, multitasking is introduced.

In multitasking multiple task can concurrently work with CPU so, our task will be completed as soon as possible.

Multitasking is further divided into two categories.

a) Process based Multitasking
b) Thread based Multitasking


Process based Multitasking :
----------------------------
If a CPU is switching from one subtask(Thread) of one process to 
another subtask of another process then it is called Process based Multitasking.

Thread based Multitasking :
---------------------------
If a CPU is switching from one subtask(Thread) to another subtask within the same process then it is called Thread based Multitasking.
----------------------------------------------------------------
Thread :-
----------
A thread is light weight process and it is the basic unit of CPU which can run concurrently with another thread within the same context (process).

It is well known for independent execution. The main purpose of multithreading to boost the execution sequence.

A thread can run with another thread at the same time so our task will be completed as soon as possible.

In java whenever we define main method then JVM internally creates a thread called main thread.
-----------------------------------------------------------------
Program that describes that main is a Thread :
-----------------------------------------------
Whenever we define main method then JVM will create main thread internally, the purpose of this main thread to execute the entire main method.

In java there is a predefined class called Thread available in java.lang package, this class contains a predefined static method currentThread() which will provide currently executing Thread.

Thread t = Thread.currentThread(); //Factory Method

Thread class has provided predefined method getName() to get the name of the Thread.

package com.ravi.m1;

public class MainThread {

	public static void main(String[] args) 
	{
		Thread thread = Thread.currentThread();
		System.out.println("Current Thread Name is :"+thread.getName());
		
		   //OR
		System.out.println("Current Thread Name is :"+Thread.currentThread().getName());
	}

}
-----------------------------------------------------------------
How to create a userdefined Thread in java ?
---------------------------------------------
As we know whenever we define the main method then JVM internally creates a thread called main thread.

The purpose of main thread to execute the entire main method so at the time of execution of main method a user can create our own userdefined thread.

In order to create the userdefined Thread we can use one of the following two ways :-

1) By extending java.lang.Thread class
2) By implementing java.lang.Runnable interface

Note :- Thread is a predefined class available in java.lang package where as Runnable is a predefined interface available in java.lang Package.
------------------------------------------------------------------
How to create a userdefined Thread in java ?
---------------------------------------------
As we know whenever we define the main method then JVM internally creates a thread called main thread.

The purpose of main thread to execute the entire main method so at the time of execution of main method a user can create our own userdefined thread.

In order to create the userdefined Thread we can use one of the following two ways :-

1) By extending java.lang.Thread class
2) By implementing java.lang.Runnable interface

Note :- Thread is a predefined class available in java.lang package where as Runnable is a predefined interface available in java.lang Package.
----------------------------------------------------------------
Creating a user-defined Thread by extending Thread class :
----------------------------------------------------------
public synchronized void start() :
-----------------------------------
start() is a predefined method of Thread class and this method internally performs two tasks

1) It makes a request to opearting system to assign a new thread to perform concurrent execution.

2) It internally invokes the run() method as a part a separate Stack.

Note :- For every individual thread, JVM creates a separate runtime stack.

The following program explains how to create a userdefined Thread by extending Thread approach.

------------------------------------------------------------------
package com.ravi.thread;

class MyThread extends Thread
{
	@Override
	public void run()
	{
		System.out.println("Child thread is running with separate Stack");
	}
}

public class ThreadDemo {

	public static void main(String[] args) 
	{
		System.out.println("Main Thread started");
		MyThread m = new MyThread();
	    m.start();
	    System.out.println("Main Thread ended");
	}

}

In the above program main thread and Thread-0 threads are created both threads are executing their own Stack Memory as shown in the diagram (31st May)
----------------------------------------------------------------
public boolean isAlive() :
--------------------------
It is a predefined method of Thread class through which we can find out whether a thread has started or not ?

As we know a new thread is created after calling start() method so if we use isAlive() method before start() method, it will return false but if the same isAlive() method if we invoke after the start() method, it will return true.

We can't restart a thread in java if we try to restart then It will generate an exception i.e java.lang.IllegalThreadStateException

package com.ravi.thread;

class Test extends Thread
{
	@Override
	public void run()
	{
		System.out.println("run");
	}
}

public class IsAliveDemo 
{
	public static void main(String[] args) 
	{
		Test t1 = new Test();
		System.out.println("Is Thread started ? "+t1.isAlive());
		t1.start();
		System.out.println("Is Thread started ? "+t1.isAlive());
		
		//t1.start(); //java.lang.IllegalThreadStateException
		
	}

}
-------------------------------------------------------------------
package com.ravi.basic;

class Stuff extends Thread
{
	@Override
	public void run() 
	{		
		System.out.println("Child Thread is Running!!!!");
	}	
}
public class ExceptionDemo 
{
	public static void main(String[] args) 
	{		
		System.out.println("Main Thread Started");		
		
		Stuff s1 = new Stuff(); 
		Stuff s2 = new Stuff(); 
		
		
		s1.start();
		s2.start();
		
		System.out.println(10/0);
		
		System.out.println("Main Thread Ended");
	}

}

Note :- Here main thread is interrupted due to AE but still child thread will be executed because child thread is executing with separate Stack
-------------------------------------------------------------------
package com.ravi.basic;

class Sample extends Thread
{
	@Override
	public void run()
	{
		String name = Thread.currentThread().getName();
		for(int i=1; i<=10; i++)
		{
		   System.out.println(i+" by "+name+ " thread");
		}
	}
}
public class ThreadLoop 
{	
	public static void main(String[] args) 
	{
	   System.out.println("Main Thread Started!!!");
	   
	   Sample s1 = new Sample();  
	   s1.start();
	   
	   
	   String name = Thread.currentThread().getName();
	   
	   for(int i=1; i<=10; i++)
	   {
		   System.out.println(i+" by "+name+ " thread");
	   }
	   
	   int x = 1;
	   do
	   {
		   System.out.println("India");
		   x++;
	   }
	   while(x<=10);
	   
	   
	}
}
-------------------------------------------------------------------
package com.ravi.basic;

class Sample extends Thread
{
	@Override
	public void run()
	{
		String name = Thread.currentThread().getName();
		for(int i=1; i<=10; i++)
		{
		   System.out.println(i+" by "+name+ " thread");
		}
	}
}
public class ThreadLoop 
{	
	public static void main(String[] args) 
	{
	   System.out.println("Main Thread Started!!!");
	   
	   Sample s1 = new Sample();  s1.start();
	   
	   
	   String name = Thread.currentThread().getName();
	   
	   for(int i=1; i<=10; i++)
	   {
		   System.out.println(i+" by "+name+ " thread");
	   }
	   
	   int x = 1;
	   do
	   {
		   System.out.println("India");
		   x++;
	   }
	   while(x<=10);
	   
	   
	}
}

Note :- From the above program, It is clear that CPU can frequently move from one thread to another thread. (Main thread to child thread-> Thread-0 thread)
----------------------------------------------------------------
How to set and get the name of the Thread : 
--------------------------------------------------
Whenever we create a userdefined Thread in java then by default JVM assigns the name of thread is Thread-0, Thread-1, Thread-2 and so on.

If a user wants to assign some user defined name of the Thread, then Thread class has provided a predefined method called setName(String name) to set the name of the Thread.

On the other hand we want to get the name of the Thread then Thread class has provided a predefined method called getName().

public void setName(String name)  //setter

public String getName()  //getter
-------------------------------------------------------------------
package com.ravi.basic;
class Test extends Thread
{
	@Override
	public void run()
	{
		String name = Thread.currentThread().getName();
		System.out.println(name +" thread is running Here!!!!");
	}
}
public class ThreadName 
{
	public static void main(String[] args) 
	{
		Test t1 = new Test(); 
		Test t2 = new Test(); 
		
		t1.start();			
		t2.start();	
		
	System.out.println(Thread.currentThread().getName()+" thread is running.....");
	}
}

Note :- If we don't provide our user-defined name for the thread then by default the name would be Thread-0, Thread-1 and so on.
---------------------------------------------------------------
package com.ravi.basic;
class Demo extends Thread
{
	@Override
	public void run()
	{
		System.out.println(Thread.currentThread().getName()+" thread is running.....");	
	}
}
public class ThreadName1 
{
	public static void main(String[] args) 
	{
	  Thread t =  Thread.currentThread();
	  t.setName("Parent"); //Changing the name of the main thread
	  
	   Demo d1 = new Demo();
	   Demo d2 = new Demo();
	   
	   d1.setName("Child1");
	   d2.setName("Child2");
	   
	   d1.start();  d2.start();
	   
	   String name = Thread.currentThread().getName();
	   System.out.println(name + " Thread is running..");
	}
}
----------------------------------------------------------------
Thread.sleep(long millisecond) :
-------------------------------
If we want to put a thread into temporarly waiting state then we should use sleep() method.

The waiting time of the Thread depends upon the time specified by the user in millisecond as parameter to sleep() method.

Thread.sleep(1000); //Thread will wait for 1 second

It is a static method of Thread class.

It is throwing a checked Exception i.e InterruptedException because there may be chance that this sleeping thread may be interrupted by some another thread.

package com.ravi.basic;

class Sleep extends Thread
{
   @Override
   public void run() 
   {
	   for(int i=1; i<=10; i++)
	   {
		   System.out.println("i value is :"+i);
		   try
		   {
			  Thread.sleep(1000);
		   }
		   catch(InterruptedException e)
		   {
			   System.err.println("Thread is Interrupted "+e);
		   }
	   }
   }
}
public class SleepDemo 
{
	public static void main(String[] args) 
	{
		Sleep s = new Sleep();
		s.start();
		
		
			
	}
}
----------------------------------------------------------------
Assignment :
-------------
WAP to implement sleep(long millis, long nanos) methos which is accepting two parameters.
----------------------------------------------------------------
01-06-2024
-----------
Thread life cycle in java :
-----------------------------
As we know a thread is well known for Independent execution and it contains a life cycle which internally contains 5 states (Phases). 

During the life cycle of a thread, It can pass from thses 5 states. At a time a thread can reside to only one state of the given 5 states.

1) NEW State (Born state)

2) RUNNABLE state (Ready to Run state) [Thread Pool]

3) RUNNING state

4) WAITING / BLOCKED state

5) EXIT/Dead state


New State :-
-------------
Whenever we create a thread instance(Thread Object) a thread comes to new state OR born state. New state does not mean that the Thread has started yet only the object or instance of Thread has been created.

Runnable state :-
-------------------
Whenever we call start() method on thread object, A thread moves to Runnable state i.e Ready to run state. Here Thread schedular is responsible to select/pick a particular Thread from Runnable state and sending that particular thread to Running state for execution.

Running state :-
-----------------
If a thread is in Running state that means the thread is executing its own run() method. 

From Running state a thread can move to waiting state either by an order of thread schedular or user has written some method(wait(), join() or sleep()) to put the thread into temporarly waiting state.

From Running state the Thread may also move to Runnable state directly, if user has written Thread.yield() method explicitly.

Waiting state :-
------------------
A thread is in waiting state means it is waiting for it's time period to complete. Once the time period will be completed then it will re-enter inside the Runnable state to complete its remaining task.

Dead or Exit :
----------------
Once a thread has successfully completed its run method then the thread will move to dead state. Please remember once a thread is dead we can't restart a thread in java.

IQ :- If we write Thread.sleep(1000) then exactly after 1 sec the Thread will re-start?

Ans :- No, We can't say that the Thread will directly move from waiting state to Running state. 

The Thread will definetly wait for 1 sec in the waiting mode and then again it will re-enter into Runnable state which is control by Thread Schedular so we can't say that the Thread will re-start just after 1 sec.
----------------------------------------------------------------join() method of Thread class :
-------------------------------
join() method of Thread class :
------------------------------------
The main purpose of join() method to put the one thread into waiting mode until the other thread finish its execution.

Here the currently executing thread stops its execution and the thread goes into the waiting state. The current thread remains in the wait state until the thread on which the join() method is invoked has achieved its dead state.

It also throws checked exception i.e InterruptedException so better to use try catch or declare the method as throws.

It is an instance method so we can call this method with the help of Thread object reference.

package com.ravi.basic;

class Join extends Thread
{
	@Override
	public void run()
	{
		for(int i=1; i<=5; i++)
		{
			try
			{
				Thread.sleep(1000);
			}
			catch(Exception e)
			{
				e.printStackTrace();
			}
			System.out.println("i value is :"+i);
		}
	}
}


public class JoinDemo 
{
	public static void main(String[] args) throws InterruptedException
	{
       System.out.println("Main thread started....");
       
       Join j1 = new Join();
       Join j2 = new Join();
       Join j3 = new Join();
       
      j1.start();  
      
      j1.join();
      
      j2.start();  
      
      j3.start();
       
       System.out.println("Main thread ended...");
       
	}

}
----------------------------------------------------------------
package com.ravi.basic;

public class JoinDemo1 
{
	public static void main(String[] args) throws InterruptedException 
	{
		System.out.println("Main thread started");
		Thread thread = Thread.currentThread();
		
		String name = thread.getName();
		
		for(int i=1; i<=5; i++)
		{			
			System.out.println(i + " by "+name+ " thread ");
			Thread.sleep(1000);			
		}
		thread.join();  //Deadlock
	
		
		System.out.println("Main thread ended");

	}

}

Here, It is a deadlock state because main thread is waiting for main thread to complete.
---------------------------------------------------------------
package com.ravi.basic;

class Alpha extends Thread
{
	@Override
	public void run()
	{
		Thread t = Thread.currentThread();
		String name = t.getName();	//Alpha_Thread		
		
		Beta b1 = new Beta();
		b1.setName("Beta_Thread");
        b1.start();  
        try 
        {
			b1.join(); //Alpha thread is Blocked
			System.out.println("--------------------");
		} 
        catch (InterruptedException e) 
        {			
			e.printStackTrace();
		}
		
		for(int i=1; i<=10; i++)
		{
			System.out.println(i+" by "+name);
		}
		
	}
}

public class JoinDemo2 
{
	public static void main(String[] args) 
	{
		Alpha a1 = new Alpha();
		a1.setName("Alpha_Thread");
		a1.start();
	}
}

class Beta extends Thread
{
	@Override
	public void run()
	{
		Thread t = Thread.currentThread();
		String name = t.getName();	
		for(int i=1; i<=20; i++)
		{
			System.out.println(i+" by "+name);
		}
		System.out.println(".............");
	}
}
---------------------------------------------------------------
Assignment :
-------------
WAP to implement join(long millis) method.
---------------------------------------------------------------
03-06-2024
------------
Creating Thread by implements Runnable approach :
--------------------------------------------------
package com.ravi.thread;

class MyThread implements Runnable
{
	
	public void run()
	{ 
		String name = Thread.currentThread().getName();
		System.out.println("Thread Name is :"+name);		
	}	
}

public class RunnableDemo 
{
	public static void main(String[] args) 
	{
	   System.out.println("Main Thread");	  
	  
	   Thread t1 = new Thread(new MyThread()); //new Thread(Runnable target)
	   t1.start();

	}

}
----------------------------------------------------------------------

In between extends Thread and implements Runnable, implements Runnbale is better approach due to the following reasons

1) We can extend a class if we implement from Runnable interface
2) We can achieve loose coupling
3) We can implement Lambda expression
4) Our user-defined class will be light weight because all the methods
   and properties of Thread class will not be available
----------------------------------------------------------------------
Anonymous inner class for Thread class with reference :
--------------------------------------------------------
package com.ravi.thread;

public class AnonymousWithReference 
{
	public static void main(String[] args)
	{
		Thread t1 = new Thread()
		{
			@Override
			public void run()
			{
				System.out.println(Thread.currentThread().getName());
			}
		};
		t1.start();

	}

}
---------------------------------------------------------------------
Anonymous inner class for Thread class without reference :
--------------------------------------------------------
package com.ravi.thread;

public class AnonymousWithoutReference {

	public static void main(String[] args) 
	{
		new Thread()
		{
			@Override
			public void run()
			{
				System.out.println(Thread.currentThread().getName());
			}
		}.start();

	}

}
---------------------------------------------------------------------
Anonymous inner class for Runnable interface with reference :
-------------------------------------------------------------
package com.ravi.thread;

public class AnonymousRunnable {

	public static void main(String[] args) 
	{
		Runnable r1 = new Runnable()
		{
			@Override
			public void run()
			{
				System.out.println(Thread.currentThread().getName());
			}
			
		};
		r1.run();
		
		Thread t1 = new Thread(r1); t1.start();

	}

}
---------------------------------------------------------------------
Runnable by using Lambda
-------------------------
package com.ravi.thread;

public class RunnableLambda {

	public static void main(String[] args) 
	{
		Runnable r1 = () -> System.out.println(Thread.currentThread().getName());
		
		Thread t1 = new Thread(r1); t1.start();
		
		
		new Thread(()-> System.out.println(Thread.currentThread().getName()),"Child1").start();
		
	}

}
----------------------------------------------------------------------
Thread class Constructor :
--------------------------
In Thread class we have total 9 constructors are available but 
commonly we are using the following 7 constructors 

1) Thread t1 = new Thread();

2) Thread t2 = new Thread(String name);

3) Thread t3 = new Thread(Runnable target);

4) Thread t4 = new Thread(Runnable target, String name);

5) Thread t5 = new Thread(ThreadGroup tg, String name);

6) Thread t6 = new Thread(ThreadGroup tg, Runnable target);

7) Thread t6 = new Thread(ThreadGroup tg, Runnable target, String name);
----------------------------------------------------------------
Problem with multithreading :-
----------------------------------
Multithreading is very good to complete our task as soon as possible but in some situation, It provides some wrong data or wrong result.

In Data Race or Race condition, all the threads try to access the resource at the same time so the result will be corrupted.

In multithreading if we want to perform read operation and data is not updatable then multithreading is good but if the data is updatable data (modifiable data) then multithreading may produce some wrong result or wrong data as shown in the diagram.(3-JUN-24)

package com.ravi.thread;

class Customer implements Runnable
{
	private int availableSeat = 1;
	
	private int wantedSeat;
	
	public Customer(int wantedSeat)
	{
		this.wantedSeat = wantedSeat;
	}	
	
	@Override
	public void run() 
	{
		String name = null;
		
		if(availableSeat >= wantedSeat)
		{
		   name = Thread.currentThread().getName();
		   System.out.println(wantedSeat+" seat is reserved for :"+name);
		   availableSeat = availableSeat - wantedSeat;
		}
		else
		{
			name = Thread.currentThread().getName();
			System.err.println("Sorry !"+name+" berth is not available");
		}
		
	}	
}


public class RailwayReservation {

	public static void main(String[] args) 
	{
		Customer c1 = new Customer(1);
		
		Thread t1 = new Thread(c1, "Virat");
		Thread t2 = new Thread(c1, "Rohit");
		
		t1.start();  t2.start();

	}

}
--------------------------------------------------------------------
Assignment :
------------
WAP to perform withdraw operation by using multiple threads which displays the wrong result due to concurrency by using Lambda.
------------------------------------------------------------------
package com.ravi.advanced;

class MyThread implements Runnable
{
	private String str;
	
	public MyThread(String str)
	{
		this.str=str;
	}	
	
	@Override
	public void run()
	{
		for(int i=1; i<=10; i++)
		{
			System.out.println(str+ " : "+i);
			try
			{
				Thread.sleep(100);
			}
			catch (Exception e)
			{
			System.err.println(e);
			}
		}
	}
}
public class Theatre
{
	public static void main(String [] args)
	{
		MyThread obj1 = new MyThread("sell the Ticket");  
		MyThread obj2 = new MyThread("Allocate the Seat"); 

		Thread t1 = new Thread(obj1);
		Thread t2 = new Thread(obj2);

		t1.start();
		t2.start();
	}
}
----------------------------------------------------------------------
* Synchronization :
------------------
In order to solve the problem of multithreading java software people has introduced synchronization concept.

In order to acheive synchronization in java we have a keyword called "synchronized".

It is a technique through which we can control multiple threads but accepting only one thread at all the time.

Synchronization allows only one thread to enter inside the synchronized area for a single object.

Synchronization can be divided into two categories :-

1) Method level synchronization

2) Block level synchronization

1) Method level synchronization :-
-----------------------------------
In method level synchronization, the entire method gets synchronized so all the thread will wait at method level and only one thread will enter inside the synchronized area as shown in the diagram.(03-JUN-24) 
----------------------------------------------------------------
2) Block level synchronization
-------------------------------
In block level synchronization the entire method does not get synchronized, only the part of the method gets synchronized so all the thread will enter inside the method but only one thread will enter inside the synchronized block as shown in the diagram (03-JUN-24) 

Note :- In between method level synchronization and block level synchronization, block level synchronization is more preferable because all the threads can enter inside the method so only the PART OF THE METHOD GETS synchronized so only one thread will enter inside the synchronized block.
-----------------------------------------------------------------
04-06-2024
-----------
How synchronization logic controls multiple threads ?
------------------------------------------------------
Every Object has a lock(monitor) in java environment and this lock can be given to only one Thread at a time.

The thread who acquires the lock from the object will enter inside the synchronized area, it will complete its task without any disturbance because at a time there will be only one thread inside the synchronized area(for single Object). *This is known as Thread-safety in java.

The thread which is inside the synchronized area, after completion of its task while going back will release the lock so the other threads (which are waiting outside for the lock) will get a chance to enter inside the synchronized area by again taking the lock from the object and submitting it to the synchronization mechanism.
This is how synchronization mechanism controls multiple Threads.

Note :- Synchronization logic can be done by senior programmers in the real time industry because due to poor synchronization there may be chance of getting deadlock.

//Program on Method level synchronization :
--------------------------------------------

package com.ravi.synchronization_demo;

class Table
{
	public synchronized void printTable(int num) 
	{
		for(int i=1; i<=10; i++)
		{
			System.out.println(num+" X "+i+" = "+(num*i));
			try
			{
				Thread.sleep(1000);
			}
			catch(InterruptedException e)
			{
				e.printStackTrace();
			}
		}
		System.out.println("....................");
	}
}

public class MethodLevelSynchronization 
{
	public static void main(String[] args) 
	{
		Table obj = new Table();   //lock is created
		
		new Thread()
		{
			@Override
			public void run()
			{
				obj.printTable(5);
			}
		}.start();

		
		new Thread()
		{
			@Override
			public void run()
			{
				obj.printTable(10);
			}
		}.start();
	}

}

//Program on block level synchronization :
--------------------------------------------
package com.ravi.advanced;

//Block level synchronization

class ThreadName
{
	public void printThreadName()
	{		  		
	  String name = Thread.currentThread().getName();
	  System.out.println("Thread inside the method is :"+name);
			
		   synchronized(this)  //synchronized Block
		   {  			   
			for(int i=1; i<=9; i++)
			{
				System.out.println("i value is :"+i+" by :"+name);
			}
			System.out.println(".............................");
		   }		
	}
}
public class BlockSynchronization 
{
	public static void main(String[] args)
	{
		ThreadName obj1 = new ThreadName(); //lock is created	
		
		Runnable r1 = () -> obj1.printThreadName();
		
		Thread t1 = new Thread(r1,"Child1"); 
		Thread t2 = new Thread(r1,"Child2"); 
		t1.start(); t2.start();				
	}
}
---------------------------------------------------------------------
Problem with Object level synchronization :
-------------------------------------------
From the given diagram it is clear that there is no interference between t1 and t2 thread because they are passing throgh Object1 where as on the other hand there is no interferenec even in between t3 and t4 threads because they are also passing through Object2 (another object).

But there may be chance that with t1 Thread, t3 or t4 thread can enter inside the synchronized area at the same time, simillarly it is also possible that with t2 thread, t3 or t4 thread can enter inside the synchronized area so the conclusion is, synchronization mechanism does not work with multiple Objects.(Diagram 04-JUNE)

package com.ravi.advanced;
class PrintTable
{
	    public synchronized void printTable(int n)
	    {
	       for(int i=1; i<=10; i++)
	       {
	    	   System.out.println(n+" X "+i+" = "+(n*i));
	    	   try
	    	   {
	    		   Thread.sleep(500);
	    	   }
	    	   catch(Exception e)
	    	   {	    		   
	    	   }
	       }
	       System.out.println(".......................");
	    }	
}

public class ProblemWithObjectLevelSynchronization
{
	public static void main(String[] args) 
	{
		PrintTable pt1 = new PrintTable(); //lock1		
		PrintTable pt2 = new PrintTable(); //lock2
		
		Thread t1 = new Thread()  //Anonymous inner class concept
				{
			       @Override
			       public void run()
			       {
			    	   pt1.printTable(2);	//lock1
			       }			   
				};
		       	        
		        Thread t2 = new Thread()
				{
			       @Override
			       public void run()
			       {
			    	   pt1.printTable(3);	//lock1
			       }			   
				};
		                
		        Thread t3 = new Thread()
				{
			       @Override
			       public void run()
			       {
			    	   pt2.printTable(6);	//lock2
			       }			   
				};
		               
		        Thread t4 = new Thread()
				{
			       @Override
			       public void run()
			       {
			    	   pt2.printTable(9); //lock2
			       }			   
				};
				 t1.start();	t2.start();	 t3.start();  t4.start(); 
	}
}

---------------------------------------------------------------------
Static Synchronization :
------------------------
If We declare a synchronized method as a static method then it is called static synchronization.

Now with static synchronization lock will be available at class level but not Object level.

To call the static synchronized method, object is not required so we can call the static method with the help of class name.

Unlike objects we can't create multiple classes for the same application.
----------------------------------------------------------------------
package com.ravi.advanced;
class MyTable     
{
	 public static synchronized void printTable(int n)  //static synchronization
	    {
	       for(int i=1; i<=10; i++)
	       {
	    	   try
	    	   {
	    		   Thread.sleep(100);
	    	   }
	    	   catch(InterruptedException e)
	    	   {
	    		  System.err.println("Thread is Interrupted...");
	    	   }
	    	   System.out.println(n+" X "+i+" = "+(n*i));
	       }
	       System.out.println("------------------------");
	    }
}
public class StaticSynchronization 
{
	public static void main(String[] args)
	{
			        Thread t1 = new Thread()
					{
				      @Override
				      public void run()
				      {
				    	 MyTable.printTable(5); 
				      }
					};		
					
					Thread t2 = new Thread()
					{
				      @Override
				      public void run()
				      {
				    	  MyTable.printTable(10);
				      }
					};										

					Runnable r3 = new Runnable() 
					{						
						@Override
						public void run() 
						{
							MyTable.printTable(15);							
						}
					};
					Thread t3 = new Thread(r3);
					
					t1.start();
					t2.start();	t3.start();
					
		}
}
--------------------------------------------------------------------
** Inter Thread Communication(ITC) :
------------------------------------
It is a mechanism to communicate two synchronized threads within the context to achieve a particular task.

In ITC we put a thread into wait mode by using wait() method and other thread will complete its corresponding task, after completion of the task it will call notify() method so the waiting thread will get a notification to complete its remaining task.

ITC can be implemented by the following method of Object class.

1) public final void wait() throws InterruptedException

2) public native final void notify()

3) public native final void notifyAll()


public  final void wait() throws InterruptedException :-
-------------------------------------------------------------
It will put a thread into temporarly waiting state and it will release the lock.

It will wait till the another thread invokes notify() or notifyAll() for this object.

public native final void notify() :-
-------------------------------------
It will wake up the single thread that is waiting on the same object.

public native final void notifyAll() :-
----------------------------------------
It will wake up all the threads which are waiting on the same object.

*Note :- wait(), notify() and notifyAll() methods are defined in Object class but not in Thread class because these methods are related to lock(because we can use these methods from the synchronized area ONLY) and Object has a lock so, all these methods are defined inside Object class.

*What is the difference between sleep() and wait() 
 paint diagram : 04-JUNE-24
------------------------------------------------------------------------
05-06-2024
----------
WAP that describes if we don't use ITC then the problem is :

//Program that describes if we don't use ITC then the problem is ...

class Test implements Runnable
{
	int var = 0;	
	@Override
	public void run()
	{
		for(int i=1; i<=10; i++)   
		{
			var = var + i;     //var = 1   3  6  10  15  21
			try
			{
				Thread.sleep(200);
			}
			catch (Exception e)
			{
			}		          
		}
			
	}
}
public class ITCProblem 
{
	public static void main(String[] args) 
	{		
		Test t = new Test();
		Thread t1 = new Thread(t);		
		t1.start();
		try
		{
			Thread.sleep(200);
		}
		catch (Exception e)
		{
		}		
	   	System.out.println(t.var);
	}
}

Note :- In the above program main thread is printing the value of var 
but the value of var is changing based on the loop iteration, here there is no communication between main thread and Thread-0 so, output will vary.
------------------------------------------------------------------------
//Communication between main thread and child thread using ITC

class SecondThread extends Thread 
{
	    int x = 0;

	    @Override
		public void run() 
		{	
			//Child thread will wait here for lock
			synchronized(this) 
			{
				for(int i=1; i<=100; i++)
				{
					x =  x + i;
				}
				System.out.println("Sending notification");
				notify();  
			}
	 }
} 
public class InterThreadComm
{
public static void main(String [] args) 
{
		SecondThread b = new SecondThread();  
		b.start();

		    synchronized(b)  //lock is taken by main thread
			{
				//main thread is suspended by Thread Schedular
				try 
				{
					System.out.println("Waiting for b to complete...");
					b.wait(); //main thread will wait and release the lock

					System.out.println("Main thread wake up");
				} 
				catch (InterruptedException e)
				{
				}
				System.out.println("Value is: " + b.x);
			}		
	}
}


Note :- Here we have a communication between main thread and Thread-0
        thread so we will get proper output.
----------------------------------------------------------------------
class Customer
{  
     int balance = 10000;    

	public synchronized void withdraw(int amount)  //amount = 15000
	{  
		System.out.println("going to withdraw...");    
		if(balance < amount)
			{  
				System.out.println("Less balance; waiting for deposit...");  
					try
					{
						wait();  //waiting and releasing the lock
					}
					catch(Exception e){}  
			}  
		balance  = balance - amount;
		System.out.println("withdraw completed..."+balance+" is remaining balance"); 
	}    

	public synchronized void deposit(int amount)   
		{  
			System.out.println("going to deposit...");  
			balance = balance + amount;  
			System.out.println("Balance after deposit is :"+balance);
			System.out.println("deposit completed... ");  
			notify();  
		}  
}   
public class InterThreadBalance
{  
public static void main(String args[])
	{  
      Customer c = new Customer();    //lock is created here

		Thread son = new Thread()  //anonymous class concept
		{  
			@Override
			public void run()
			{
				c.withdraw(15000);
			}  
		};
		son.start(); 		

		Thread father = new Thread()
		{  
			public void run()
			{
				c.deposit(9000);
			}  
		};
		
		father.start();  
    }
} 
--------------------------------------------------------------------
//Program on notifyAll()

class Resource 
{
    private boolean flag = false;

    public synchronized void waitMethod() 
	{
		System.out.println("Wait");
       	while (!flag) 
		{
          try 
		  {
             System.out.println(Thread.currentThread().getName() + " is waiting...");
             wait(); 
          } 
		  catch (InterruptedException e) 
		  {
                e.printStackTrace();
          }
        }
        System.out.println(Thread.currentThread().getName() + " thread completed!!");
    }

    public synchronized void setMethod() 
	{
		System.out.println("notifyAll");
		this.flag = true;
        System.out.println(Thread.currentThread().getName() + " has make flag value as a true");
        notifyAll(); // Notify all waiting threads that the signal is set
    }
}

public class InterThreadNotifyAll
{
    public static void main(String[] args) 
		{
        Resource r1 = new Resource();

        Thread t1 = new Thread(() -> r1.waitMethod(), "Child1");
        Thread t2 = new Thread(() -> r1.waitMethod(), "Child2");
		Thread t3 = new Thread(() -> r1.waitMethod(), "Child3");
		
		Thread setter = new Thread(() -> r1.setMethod(), "Setter_Thread");

        t1.start();
        t2.start();
        t3.start();
       
	     
        try 
		{
            Thread.sleep(5000);
        } 
		catch (InterruptedException e) 
		{
            e.printStackTrace();
        }


        setter.start();
    }
}
----------------------------------------------------------------------
Thread Priority :
-----------------
It is possible in java to assign priority to a Thread. Thread class has provided two predefined methods setPriority(int newPriority) and getPriority() to set and get the priority of the thread respectively.

In java we can set the priority of the Thread in numbers from 1- 10 only where 1 is the minimum priority and 10 is the maximum priority.

Whenever we create a thread in java by default its priority would be 5 that is normal priority.

The user-defined thread created as a part of main thread will acquire the same priority of main Thread.

Thread class has also provided 3 final static variables which are as follows :-

Thread.MIN_PRIORITY  :- 01

Thread.NORM_PRIORITY : 05

Thread.MAX_PRIORITY  :- 10

Note :- We can't set the priority of the Thread beyond the limit(1-10) so if we set the priority beyond the limit (1 to 10) then it will generate an exception java.lang.IllegalArgumentException.
---------------------------------------------------------------------
public class ThreadPrior
{
	public static void main(String [] args)
	{
		System.out.println("Main thread priority is :"+Thread.currentThread().getPriority());  //5
        
		Thread t = new Thread();
        System.out.println(t.getPriority());//5	    
		 t.setPriority(8);
	     System.out.println(t.getPriority());	//8	

		 t.setPriority(Thread.MAX_PRIORITY);
		 System.out.println(t.getPriority()); //10
	}
}
----------------------------------------------------------------------
Program that describes user thread will acqire the priority of main thread
class MainThread 
{
	public static void main(String[] args) 
	{
		Thread t = Thread.currentThread();
		t.setPriority(9);

		Thread t1 = new Thread();
		System.out.println("Priority is :"+t1.getPriority());
		
	}
}
----------------------------------------------------------------------
class ThreadPrior1 extends Thread           
	{
 public void run()
  {
     int count = 0;
	 for (int i=1; i<=100000 ; i++ )
	 {
		 count++;
	 }

   System.out.println("running thread name is:"+Thread.currentThread().getName());

   System.out.println("running thread priority is:"+Thread.currentThread().getPriority());
  }

 public static void main(String args[])
  {
  ThreadPrior1 m1 = new ThreadPrior1();
  ThreadPrior1 m2 = new ThreadPrior1();

  m1.setPriority(Thread.MIN_PRIORITY);//1
  m2.setPriority(Thread.MAX_PRIORITY);//10

  m1.setName("Last");
  m2.setName("First");

  m1.start();
  m2.start(); 
 }
}   

Most of time the thread having highest priority will complete its task but we can't say that it will always complete its task first.
----------------------------------------------------------------------
Thread.yield() :
----------------
It is a static method of Thread class.

It will send a notification to thread schedular to stop the currently executing Thread (In Running state) and provide a chance to Threads which are in Runnable state to enter inside the running state having same priority or higher priority. Here The running Thread will directly move from Running state to Runnable state.

The Thread schedular can ignore this notification message given by currently executing Thread.

Here there is no guarantee that  after using yield() method the running Thread will move to Runnable state and from Runnable state the thread can move to Running state.[That is the reason yield() method is throwing InterruptedExecption]

If the thread which is in runnable state is having low priority then the current executing thread in Running state, will continue its execution.

It is mainly used to avoid the over-utilisation a CPU by the current Thread.
---------------------------------------------------------------------
class Test implements Runnable
{
	@Override
	public void run()
	{		
		for(int i=1; i<=10; i++)
		{
			String name = Thread.currentThread().getName();

			System.out.println("i value is :"+i+" by thread :"+name);    
			
			 if(name.equals("Child1"))
			{
				Thread.yield();  //Give a chance to Child2 Thread
			}

		}
   }
}
public class ThreadYieldMethod 
{
	public static void main(String[] args) 
	{
		Test obj = new Test();

		Thread t1 = new Thread(obj, "Child1");
		Thread t2 = new Thread(obj, "Child2");
        
		t1.start();  t2.start();
	}
}
Note :- In real time if a thread is acquiring more time of CPU then to release that Thread we call yield() method the currently executing Thread.
-----------------------------------------------------------------
06-06-2024
----------
interrupt Method of Thread class :
----------------------------------
It is a predefined method of Thread class. The main purpose of this method to disturb the execution of the Thread, if the thread is in waiting or sleeping state.

Whenever a thread is interupted then it throws InterruptedException so the thread (if it is in sleeping or waiting mode) will get a chance to come out from a particular logic.

Points :-
---------
If we call interrupt method and if the thread is not in sleeping or waiting state then it will behave normally.

If we call interrupt method and if the thread is in sleeping or waiting state then we can stop the thread  gracefully.

*Overall interrupt method is mainly used to interrupt the
thread safely so we can manage the resources easily.

Methods :
---------
1) public void interrupt () :- Used to interrupt the Thread but the thread must be in sleeping or waiting mode.

2) public boolean isInterrupted() :- Used to verify whether thread is interrupted or not.
----------------------------------------------------------------------
class Interrupt extends Thread
{
   @Override
   public void run()
	{
	   Thread t = Thread.currentThread();
	   System.out.println(t.isInterrupted()); 
       
	   for(int i=1; i<=10; i++)
		{
		   System.out.println(i);  
		   try
		   {
			Thread.sleep(1000);
		   }
		   catch (InterruptedException e)
		   {
			   System.err.println("Thread is Interrupted ");
			   e.printStackTrace();
		   }
		}
	}
}
public class  InterruptThread
{
	public static void main(String[] args) 
	{
		Interrupt it = new Interrupt();
		System.out.println(it.getState());  
		it.start();
		it.interrupt();  //main thread is interrupting the child thread
	}
}

Here main thread is interrupting the Child Thread :
----------------------------------------------------------------------
class Interrupt extends Thread
{
   public void run()
	{
	   try
	   {
	    Thread.currentThread().interrupt();

	   for(int i=1; i<=10; i++)
		{
		   System.out.println("i value is :"+i);
		   Thread.sleep(1000);
		}

	   }
		catch (InterruptedException e)
		{
			System.err.println("Thread is Interrupted :"+e);
		}
		System.out.println("Child thread completed...");
	}
}
public class  InterruptThread1
{
	public static void main(String[] args) 
	{
		System.out.println("Main thread is started");
		Interrupt it = new Interrupt();
		it.start();
		System.out.println("Main thread is ended");
	}
}

here child thread is interrupting itself.
----------------------------------------------------------------------
public class InterruptThread2
{
    public static void main(String[] args) 
	{
        Thread thread = new Thread(new MyRunnable());
        thread.start();
     
        try 
		{
           Thread.sleep(3000);//main thread is waiting for 3 sec
        } 
		catch (InterruptedException e) 
		{
            e.printStackTrace();
        }
        
       thread.interrupt();  //child thread interrupted
    }
}

class MyRunnable implements Runnable 
{
    @Override
    public void run() 
	{
        try 
		{
            while (!Thread.currentThread().isInterrupted())
			{
                System.out.println("Thread is running...");
                Thread.sleep(500);
            }
        } 
		catch (InterruptedException e) 
		{
            System.out.println("Thread interrupted gracefully.");
        } 
		finally 
		{
            System.out.println("Thread resource can be release here.");
        }
    }
}

We can interrupt a sleeping thread from infinite loop so thread will come out from that logic and completed the execution normally so if any resourse is attached with thread that resourse will be released.
---------------------------------------------------------------------
ThreadGroup :
-------------
There is a predefined class called ThreadGroup available in java.lang package.

In Java it is possible to group multiple threads in a single object so, we can perform a particular operation on a group of threads by a single method call.

The target of thread may be same or may be different.

The Thread class has the following constructor for ThreadGroup 

new Thread(ThreadGroup groupName, Runnable target, String name);
----------------------------------------------------------------------
public class ThreadGroupDemo1
{
   public static void main(String[] args) 
	{       
        ThreadGroup myThreadGroup = new ThreadGroup("NIT_Thread");

        // Create and start threads within the ThreadGroup

        Thread thread1 = new Thread(myThreadGroup, new MyRunnable(), "Thread 1");

        Thread thread2 = new Thread(myThreadGroup, new MyRunnable(), "Thread 2");

        Thread thread3 = new Thread(myThreadGroup, new MyRunnable(), "Thread 3");

		 Thread thread4 = new Thread(myThreadGroup, new MyRunnable(), "Thread 4");
      
        
        
        thread1.start();
        thread2.start();
		thread3.start();
		thread4.start();

        // Display information about the ThreadGroup and its threads
        System.out.println("ThreadGroup Name: " + myThreadGroup.getName());

        System.out.println("Active Count: " + myThreadGroup.activeCount());       
    }
}

class MyRunnable implements Runnable  
{
        @Override
        public void run() 
		{
            for (int i = 1; i <= 3; i++) 
			{
                System.out.println(Thread.currentThread().getName() + ": " + i);
                try 
				{
                    Thread.sleep(1000);
                } 
				catch (InterruptedException e) 
				{
                    e.printStackTrace();
                }
            }
        }
    }

----------------------------------------------------------------------
package com.ravi.thread;

public class ThreadGroupDemo2 
{
	public static void main(String[] args) 
	{
		Thread t = Thread.currentThread();
		System.out.println(t.toString());
	}

}

From this toString() method of Thread class, It is clear that main thread belongs to one group created by JVM, the name of the group is main group.
---------------------------------------------------------------------
package com.ravi.thread;

class Tatkal implements Runnable
{
	@Override
	public void run() 
	{
		String name = Thread.currentThread().getName();
		System.out.println("Tatkal Ticket is booked for :"+name);
	}
	
}
class General implements Runnable
{
	@Override
	public void run() 
	{
		String name = Thread.currentThread().getName();
		System.out.println("General Ticket is booked for :"+name);
	}
	
}

public class ThreadGroupDemo3 {

	public static void main(String[] args) 
	{
		ThreadGroup tg1 = new ThreadGroup("Tatkal");
		ThreadGroup tg2 = new ThreadGroup("General");
		
		Thread t1 = new Thread(tg1, new Tatkal(), "Scott");
		Thread t2 = new Thread(tg2, new General(), "Smith");
		
		t1.start();  t2.start();
		
		

	}

}
----------------------------------------------------------------------
Deadlock :
------------
It is a situation where two or more than two threads are in blocked state forever, here threads are waiting to acquire another thread resource without releasing it's own resource.

This situation happens when multiple threads demands same resource without releasing its own attached resource so as a result we get Deadlock situation and our execution of the program will go to an infinite state as shown in the diagram. (06-JUNE-24)
----------------------------------------------------------------------
public class DeadlockExample
	{
  public static void main(String[] args) 
	 {
     String resource1 = "Ameerpet";  
     String resource2 = "S R Nagar";  

    // t1 tries to lock resource1 then resource2

    Thread t1 = new Thread() 
		{
	  @Override
      public void run() 
		  {
			  synchronized (resource1) 
				  {
			   System.out.println("Thread 1: locked resource 1");
			      try 
				   { 
				   Thread.sleep(1000);
				   } 
				   catch (Exception e) 
				   {}
				  				  
			   synchronized (resource2) //Nested synchronized block
			   {
				System.out.println("Thread 1: locked resource 2");
			   }
             }
      }
    };


    // t2 tries to lock resource2 then resource1
    Thread t2 = new Thread() 
	{
      @Override
      public void run() 
	  {
        synchronized (resource2) 
			{
          System.out.println("Thread 2: locked resource 2");
              try 
			  { 
			  Thread.sleep(1000);
			  } 
			  catch (Exception e) 
			{}

          synchronized (resource1) //Nested synchronized block
		  {
            System.out.println("Thread 2: locked resource 1");
          }
        }
      }
    };    
    t1.start();
    t2.start();
  }
}
        
Here both the threads are waiting for another thread resourse to relese hence both the thread will go into infinite state which is known as 
Deadlock situation.
-----------------------------------------------------------------------
Daemon Thread [Service Level Thread]:
--------------------------------------
Daemon thread is a low- priority thread which is used to provide background maintenance.  

The main purpose of of Daemon thread to provide services to the user thread.              

JVM can't terminate the program till any of the non-daemon (user) thread is active, once all the user thread will be completed then JVM will terminate all Daemon threads, which are running in the background to support user threads.

The example of Daemon thread is Garbage Collection thread, which is running in the background for memory management.

In order to make a thread as a  Daemon thread , we should use setDaemon(true)

public class DaemonThreadDemo1 
{
  public static void main(String[] args) 
	{
	    System.out.println("Main Thread Started...");

        Thread daemonThread = new Thread(() -> 
		{
            while (true) 
			{
                System.out.println("Daemon Thread is running...");
                try 
				{
                    Thread.sleep(1000);
                } 
				catch (InterruptedException e) 
				{
                    e.printStackTrace();
                }
            }
        });

        daemonThread.setDaemon(true); 
        daemonThread.start();

        
        Thread userThread = new Thread(() -> 
		{
            for (int i = 1; i <= 19; i++) 
			{
                System.out.println("User Thread: " + i);
                try 
				{
                    Thread.sleep(2000);
                } 
				catch (InterruptedException e) 
				{
                    e.printStackTrace();
                }
            }
        });

        userThread.start();

        System.out.println("Main Thread Ended...");
    }
}

Note : Here when user thread will be terminated then automatically deamon thread will also terminated.
----------------------------------------------------------------------
07-06-2024
-----------
Collection Framework in java (40 - 45% IQ):
-------------------------------------------
Collections framework is nothing but handling individual Objects(Collection Interface) and Group of objects(Map interface).

We know only object can move from one network to another network.

A collections framework is a class library to handle group of Objects.

It is implemented by using java.util package.

It provides an architecture to store and manipulate group of objects.

All the operations that we can perform on data such as searching, sorting, insertion and deletion can be done by using collections framework because It is the data structure of Java.

The simple meaning of collections is single unit of Objects.
----------------------------------------------------------------


It provides the following sub interfaces :

1) List (Accept duplicate elements)
2) Set (Not accepting duplicate elements)
3) Queue (Storing and Fetching the elements based on some order i.e FIFO)


Collection is an interface in java.util package where as Collections is predefined class which contains various static method available in java.util package available from JDK 1.2v.
----------------------------------------------------------------
Methods of Collection interface :
---------------------------------
a) public boolean add(Object element) :- It is used to add an item/element in the collection.

b) public boolean addAll(Collection c) :- It is used to insert the specified collection elements in the existing collection(For merging the Collection)

c) public boolean retainAll(Collection c) :- It is used to retain all the elements from existing element. (Common Element)


d) public boolean removeAll(Collection c) :- It is used to delete all the elements from the existing collection.

e) public boolean remove(Object element) :- It is used to delete an element from the collection.

f) public int size() :- It is used to find out the size of the Collection.

g) public void clear() :- It is used to clear all the elements at once from the Collection.

All the above methods of Collection interface will be applicable to all the sub interfaces like List, Set and Queue.
-----------------------------------------------------------------------
List interface :
----------------
It is the sub interface of Collection(I).

List interface accepts duplicate elements.

List interface insertes the elements based on order or index.

We can perform manual sorting operation.
-----------------------------------------------------------------------
Behaviour of List interface specific classes :
----------------------------------------------
1) It stores the elements based on the index.
2) It can accept homogeneous as well as hetrogeneous.
3) Classes are dynmically Growable.
4) We can implements Generic to eliminate the compilation warning
   and we can hold hetrogeneous also (<Object>)


Methods of List interface :
------------------------------
1) public boolean isEmpty() :- Verify whether List is empty or not

2) public void clear() :- Will clear all the elements

3) public int size() :- To get the size of the Collections

4) public void add(int index, Object o) :- Insert the element based on the index position.

5) public boolean addAll(int index, Collection c) :- Insert the Collection based on the index position

6) public Object get(int index) :- To retrieve the element based on the index position

7) public Object set(int index, Object o) :- To override or replace the existing element based on the index position

8) public Object remove(int index) :- remove the element based on the index position

9) public boolean remove(Object element) :-  remove the element based on the object element, It is the Collection interface method extended by List interface 

10) public int indexOf() :- index position of the element

11) public int lastIndex() :- last index position of the element

12) public Iterator iterator() :- To fetch or iterate or retrieve the elements from Collection in forward direction only.

13) public ListIterator listIterator() :- To fetch or iterate or retrieve the elements from Collection in forward and backward direction
------------------------------------------------------------------------
package com.ravi.collection;

import java.util.Vector;
import java.util.function.Consumer;

public class CollectionDemo {

	public static void main(String[] args) 
	{
	    Vector<Integer> v = new Vector<>();
	    v.add(12);
	    v.add(15);
	    v.add(18);
	    v.add(19);
	    
	    /* Approach 1
	    Consumer<Integer> cons = new Consumer<Integer>() 
	    {
	    	@Override
			public void accept(Integer t) 
	    	{
				System.out.println(t);				
			}	    	
		}; */
	    
	    /* Approach 2
	    Consumer<Integer> cons = num -> System.out.println(num);
	    
	    */    
	    
	    
		v.forEach(num -> System.out.println(num));
	}

}
-----------------------------------------------------------------------
10-06-2024
-----------
How many ways we can fetch/Print the Collection Object
-------------------------------------------------------
We can fetch the Collection Object by using 9 ways :

1) By using toString() method of respective class.
2) By using Enumeration interface
3) By using Ordinary for loop 
4) By using for-Each loop 
5) By using Iterartor interface
6) By using ListIteartor
7) By using SplitIteartor interface
8) By using forEach(Consumer<T> cons) method
9) By using Method Reference 

Note : Among all these 9, Enumeration, Iterator, ListIterator and SplitIterator are the cursor.
--------------------------------------------------------------------------
Iterator interface :
----------------------
It is a predefined interface available in java.util package available from 1.2 version.

It is used to fetch/retrieve the elements from the Collection in forward direction only because it is also a cursor.

public Iterator iterator();

Example :
-----------
 Iterator itr = v.iterator();

Now, Iterator interface has provided two methods 


public boolean hasNext() :- 

It will verify, the element is available in the next position or not, if available it will return true otherwise it will return false.

public Object next() :- It will return the collection object.
-----------------------------------------------------------------
ListIterator interface :
-------------------------
It is a predefined interface available in java.util package and it is the sub interface of Iterator.

It is used to retrieve the Collection object in both the direction i.e in forward direction as well as in backward direction.

public ListIterator listIterator();

Example :
-----------
ListIterator lit =   v.listIterator();

1) public boolean hasNext() :- 
It will verify the element is available in the next position or not, if available it will return true otherwise it will return false.

2) public Object next() :- It will return the next position collection object.

3) public boolean hasPrevious() :- 
It will verify the element is available in the previous position or not, if available it will return true otherwise it will return false.


4) public Object previous () :- It will return the previous position collection object.

Note :- Apart from these 4 methods we have add(), set() and remove() method in ListIterartor interface
------------------------------------------------------------------
Spliterator interface :
-----------------------
It is a predefined interface available in java.util package from java 1.8 version.

It is a cursor through which we can fetch the elements from the 
Collection [Collection, array, Stream]

It is the combination of hasNext() and next() method.

It is using forEachRemaining(Consumer <T>) method for fetching the 
elements.

By using forEach() method :
--------------------------------
From java 1.8 onwards every collection class provides a method forEach() method, this method takes Consumer functional interface as a  parameter.
--------------------------------------------------------------------------
package com.ravi.collection.ex;

import java.util.Enumeration;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.Spliterator;
import java.util.Vector;

public class CollectionExample {

	public static void main(String[] args)
        {
		Vector<String> fruits = new Vector<>();
		fruits.add("Orange");
		fruits.add("Mango");
		fruits.add("Apple");
		fruits.add("Grapes");
		//Collections.sort(fruits);
		
		System.out.println("FETCHING ELEMENTS USING TOSTRING");
		
		System.out.println(fruits.toString());
		
		System.out.println("FETCHING ELEMENTS USING ENUMERATION ");
		
		Enumeration<String> ele = fruits.elements();
        while(ele.hasMoreElements())
        {
        	System.out.println(ele.nextElement());
        }
		
        System.out.println("FETCHING ELEMENTS USING ORDINARY FOR LOOP");
        
        for(int i=0; i<fruits.size(); i++)
        {
        	System.out.println(fruits.get(i));
        }
        
        System.out.println("FETCHING ELEMENTS USING  FOR EACH LOOP");
        
        for(String fruit : fruits)
        {
        	System.out.println(fruit);
        }
        
        System.out.println("FETCHING ELEMENTS USING ITERATOR");
        
        Iterator<String> itr =  fruits.iterator();
        while(itr.hasNext())
        {
              System.out.println(itr.next());
        }

        System.out.println("FETCHING ELEMENTS USING LISTITERATOR");
        
        ListIterator<String> lstItr = fruits.listIterator();
        
        System.out.println("IN FORWARD DIRECTION :");
        
        while(lstItr.hasNext())
        {
        	System.out.println(lstItr.next());
        }
        
        System.out.println("IN BACKWARD DIRECTION :");
        
        while(lstItr.hasPrevious())
        {
        	System.out.println(lstItr.previous());
        }
        
        System.out.println("FETCHING ELEMENTS USING SPLITITERATOR");
        
        Spliterator<String> splitItr = fruits.spliterator();
        splitItr.forEachRemaining(fruit -> System.out.println(fruit));
        
        System.out.println("USING FOREACH METHOD :");
        fruits.forEach(fruit -> System.out.println(fruit.toUpperCase()));
        
        System.out.println("USING METHOD REFERENCE :");
        fruits.forEach(System.out::println);
        
        
	}

}
--------------------------------------------------------------------------
ArrayList :
-----------
public class ArrayList<E>  extends AbstractList<E> implements List<E>, Serializable, Clonable, RandomAccess  

It is a predefined class available in java.util package under List interface from java 1.2v.

It accepts duplicate elements and null values.

It is dynamically growable array.

It stores the elements on index basis so it is simillar to dynamic array.

Initial capacity of ArrayList is 10. The new capacity of Arraylist can be calculated by using the  formula
new capacity = (current capacity * 3)/2 + 1

*All the methods declared inside an ArrayList is not synchronized so multiple thread can access the method of ArrayList. 

*It is highly suitable for fetching or retriving operation when duplicates are allowed and Thread-safety is not required.

It implements List,Serializable, Clonable, RandomAccess interfcaes

Constructor of ArrayList :
----------------------------
In ArrayList we have 3 types of Constructor:
Constructor of ArrayList :
----------------------------
We have 3 types of Constructor in ArrayList

1) ArrayList al1 = new ArrayList();
   Will create ArrayList object with default capacity 10.

2) ArrayList al2 = new ArrayList(int initialCapacity);
   Will create an ArrayList object with user specified Capacity

3) ArrayList al3 = new ArrayList(Collection c)
   We can copy any Collection interface implemented class data to the current object   reference (Coping one Collection data to another) 

-------------------------------------------------------------------------
package com.ravi.arraylist;

import java.util.*;
public class ArrayListDemo
{
	public static void main(String... a)
	{
		ArrayList<String> arl = new ArrayList<>();//Generic type		
		arl.add("Apple");   
		arl.add("Orange");
		arl.add("Grapes");
		arl.add("Mango");
		arl.add("Guava");
		arl.add("Mango");
		
		Collections.sort(arl);
		System.out.println("In Ascending Order");
		arl.forEach(System.out::println);
		
		Collections.reverse(arl);
		System.out.println("In reverse Order");
		arl.forEach(System.out::println);
		
			
	}
}
------------------------------------------------------------------------
import java.util.*;
public class ArrayListDemo
{
	public static void main(String... a)
	{
		ArrayList<String> arl = new ArrayList<>();//Generic type		
		arl.add("Apple");   
		arl.add("Orange");
		arl.add("Grapes");
		arl.add("Mango");
		arl.add("Guava");
		arl.add("Mango");

		System.out.println("Contents :"+arl); //toString()  [Apple,....]

		arl.remove(2); //based on the index position [List]
		arl.remove("Guava"); //based on the Object [Collection]

		System.out.println("Contents After Removing :"+arl);
		System.out.println("Size of the ArrayList:"+arl.size());

		Collections.sort(arl); 
		
	    arl.forEach(System.out::println);	
	}
}
------------------------------------------------------------------------
package com.ravi.arraylist;

import java.util.ArrayList;

record Product(int productId, String productName)
{
	
}

public class ArrayListDemo1 {

	public static void main(String[] args) 
	{
		ArrayList<Product> listOfProducts = new ArrayList<>();
		listOfProducts.add(new Product(333, "Camera"));
		listOfProducts.add(new Product(222, "Laptop"));
		listOfProducts.add(new Product(111, "Mobile"));
		
		
		listOfProducts.forEach(System.out::println);

	}

}
-----------------------------------------------------------------------
package com.ravi.arraylist;

//Program to merge and retain of two collection 
import java.util.*;
public class ArrayListDemo2
	{
		public static void main(String args[]) 
		{ 
		  ArrayList<String> al1=new ArrayList<>();
		  al1.add("Ravi");
		  al1.add("Rahul");
		  al1.add("Rohit");		  
		  
		  ArrayList<String> al2=new ArrayList<>();
		  al2.add("Pallavi");
		  al2.add("Sweta");
		  al2.add("Puja");		  

		  al1.addAll(al2);  

        al1.forEach(x -> System.out.println(x.toUpperCase()));

        System.out.println(".................................");

		  ArrayList<String> al3=new ArrayList<>();
		  al3.add("Ravi");
		  al3.add("Rahul");
		  al3.add("Rohit");		  
		  
		  ArrayList<String> al4=new ArrayList<>();
		  al4.add("Pallavi");
		  al4.add("Rahul");
		  al4.add("Raj");
		  
		  al3.retainAll(al4);  

        al3.forEach(x -> System.out.println(x));		  
   }
}
------------------------------------------------------------------------
How to create immutable List :
------------------------------
Immutable list means further we cann't modify.

We can achieve by using two ways :

  1) Arrays.asList()  //Fixed in length
  2) List.of()        //Immutable List


package com.ravi.arraylist;

import java.util.Arrays;
import java.util.List;

public class ImmutableList {

	public static void main(String[] args) 
	{
		
		List<Integer> listOfNumbers = List.of(1,2,3,4,5,6,7);
		listOfNumbers.add(8); //java.lang.UnsupportedOperationException
		
		List<Integer> listOfNum = Arrays.asList(1,2,3,4,5,6,7,8);
		listOfNum.add(9); //java.lang.UnsupportedOperationException
		
	}

}
-----------------------------------------------------------------------
//Program to fetch the elements in forward and backward 
//direction using ListIterator interface

package com.ravi.arraylist;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.ListIterator;

public class ArrayListDemo3   
{                             
public static void main(String args[])
  {
	 List<String> listOfName = Arrays.asList("Rohit","Akshar","Pallavi","Sweta"); 
	 
	 Collections.sort(listOfName);
	 
	 //Fetching the data in both the direction
	 ListIterator<String> lst = listOfName.listIterator();
	 
	 System.out.println("In Forward Direction..");	 
	 while(lst.hasNext())
	 {
		System.out.println(lst.next()); 
	 }
	 System.out.println("In Backward Direction..");	 
	 while(lst.hasPrevious())
	 {
		System.out.println(lst.previous()); 
	 }
	 
  }
}
-----------------------------------------------------------------------
11-06-2024
-----------
//Serialization and De-serialization on ArrayList Object
package com.ravi.arraylist;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.ArrayList;

public class ArrayListDemo4
{  
  public static void main(String [] args) throws IOException, Exception 
  {
    ArrayList<String> al = new ArrayList<>();
    al.add("B.Tech");
    al.add("M.Tech");
    al.add("BCA");
    al.add("MCA");
    al.add("BE");
    al.add("B.Pharma");
    
    var fos = new FileOutputStream("C:\\new\\Course.txt");
    var oos = new ObjectOutputStream(fos);
    
    try(fos; oos)
    {
    	oos.writeObject(al);
    	System.out.println("Object Stored Successfully");
    }
    catch(Exception e)
    {
    	e.printStackTrace();
    }
    
    //De-Serialization
    var fin = new FileInputStream("C:\\new\\Course.txt");
    var ois = new ObjectInputStream(fin);
    
    try(ois;fin)
    {
    	@SuppressWarnings("unchecked")
		ArrayList<String> arl =(ArrayList<String>)ois.readObject();        
        System.out.println(arl);
    }
    
    
  }
       
}         

----------------------------------------------------------------------
Serialization and De-serialization on Employee object
------------------------------------------------------
package com.ravi.arraylist;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.ArrayList;

record Employee(int empId, String employeeName) implements Serializable
{
	
}

public class ArrayListSerialization 
{	
	public static void main(String[] args) throws IOException, ClassNotFoundException
	{
		ArrayList<Employee> al = new ArrayList<>();
		al.add(new Employee(1, "Scott"));
		al.add(new Employee(2, "Smith"));
		al.add(new Employee(3, "John"));
		
		var fos = new FileOutputStream("C:\\new\\Employee.txt");
		var oos = new ObjectOutputStream(fos);
		
		try(fos; oos)
		{
			oos.writeObject(al);
			System.out.println("Employee Object Stored Successfully");
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}
		
		//De-Serialization
		var fin = new FileInputStream("C:\\new\\Employee.txt");
		var ois = new ObjectInputStream(fin);
		
		try(fin; ois)
		{
		 ArrayList<Employee> emp =  (ArrayList<Employee>)ois.readObject();
		 System.out.println(emp);
		}

	}

}
------------------------------------------------------------------------
public void ensureCapacity(int minimumCapacity) :
--------------------------------------------------
It is a predefined method of ArrayList class, by using this method we can resize the capacity of ArrayList Object.

Here by specifying the parameter it ensures that it can hold at least the number of elements specified by the minimum capacity argument.

ArrayList class does not provide capacity() method support.

package com.ravi.arraylist;

import java.util.ArrayList;
import java.util.LinkedList;

public class ArrayListDemo5
{
	public static void main(String[] args) 
	{		    
		ArrayList<String> city= new ArrayList<>();
		
		
		city.ensureCapacity(3); //resize the capacity of Arraylist	
		city.add("Hyderabad");
		city.add("Mumbai");
		city.add("Delhi"); 
		

		city.add("Kolkata");
		System.out.println("ArrayList: " + city);		
	 }
}
-----------------------------------------------------------------------
package com.ravi.arraylist;

//Program on ArrayList that contains null values as well as we can pass the element based on the index position
import java.util.ArrayList;
import java.util.LinkedList;
public class ArrayListDemo6
{
	public static void main(String[] args) 
	{
		ArrayList<Object> al = new ArrayList<>(); //Generic type
		al.add(12);
		al.add("Ravi");
		al.add(12);		
		al.add(3,"Hyderabad"); //add(int index, Object o)method of List interface
		al.add(1,"Naresh");
		al.add(null);
		al.add(11);
		System.out.println(al);  //12 Naresh Ravi  12  Hyderabad
	}
}
------------------------------------------------------------------------
package com.ravi.arraylist;

import java.util.ArrayList;
import java.util.List;

class Professor
{
    private String name;
    private String specialization;

    public Professor(String name, String specialization) 
    {
        this.name = name;
        this.specialization = specialization;
    }

    public String getName() 
    {
        return name;
    }

    public String getSpecialization() 
    {
        return specialization;
    }
}

class Department 
{
    private String name;
    private final List<Professor> professors; // Department "HAS-A" relationship with Professor

    public Department(String name) 
    {
        this.name = name;
        this.professors = new ArrayList<>();
    }

    public void addProfessor(Professor prof)
    {
        professors.add(prof);
    }

    public String getName() 
    {
        return name;
    }

    public List<Professor> getProfessors() 
    {
        return professors;
    }
}

public class ArrayListDemo7
{
    public static void main(String[] args) 
    {
        Professor prof1 = new Professor("Ravi", "Java");
        Professor prof2 = new Professor("Rahul", "Python");
        Professor prof3 = new Professor("Samir", ".Net");
        
        Department csd = new Department("Computer Science");
        csd.addProfessor(prof1);
        csd.addProfessor(prof2);
        csd.addProfessor(prof3);
        
        // Accessing properties through the "HAS-A" relationship
        System.out.println("Department Name: " + csd.getName());

        System.out.println("Professors in " + csd.getName() + ":");
               
        csd.getProfessors().forEach(prof ->System.out.println("-> " + prof.getName() + " (" + prof.getSpecialization() + ")") );
        
    }
}
------------------------------------------------------------------------
Program on ArrayList to perform various booke operation :
---------------------------------------------------------
3 files :
----------
Book.java
---------
package com.ravi.virtaul_lab;

public class Book {
    
    private String title;
    private String author;
    private long isbn;
    private double price;
    private int quantity;
    private String bookType;
    
	public Book(String title, String author, long isbn, double price, int quantity, String bookType) {
		super();
		this.title = title;
		this.author = author;
		this.isbn = isbn;
		this.price = price;
		this.quantity = quantity;
		this.bookType = bookType;
	}

	public String getTitle() {
		return title;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public String getAuthor() {
		return author;
	}

	public void setAuthor(String author) {
		this.author = author;
	}

	public long getIsbn() {
		return isbn;
	}

	public void setIsbn(long isbn) {
		this.isbn = isbn;
	}

	public double getPrice() {
		return price;
	}

	public void setPrice(double price) {
		this.price = price;
	}

	public int getQuantity() {
		return quantity;
	}

	public void setQuantity(int quantity) {
		this.quantity = quantity;
	}

	public String getBookType() {
		return bookType;
	}

	public void setBookType(String bookType) {
		this.bookType = bookType;
	}

	
	public String displayBook() 
	{
		return "(title=" + title + ", author=" + author + ", isbn=" + isbn + ", price=" + price + ", quantity="
				+ quantity + ")";
	}
    
    
 



}


Library.java
------------
package com.ravi.virtaul_lab;

import java.util.ArrayList;
import java.util.Scanner;

public class Library 
{
    private ArrayList<Book> books;

    public Library() 
    {
        books = new ArrayList<>();
    }

    public void addBook(Book book) 
    {
    	
        if (this.searchBookByISBN(book.getIsbn()) != null) 
        {
            System.out.println("Book with the same ISBN "+book.getIsbn() +" already exists.");
        } 
        else 
        {
            books.add(book);
            System.out.println("Book added successfully.");
        }
    }

    // Method to search a book by ISBN
    public Book searchBookByISBN(long isbn) 
    {    	
        for (Book book : books) 
        {
        	if (book.getIsbn() == isbn) 
            {            	
                return book;
            }
        }
        return null;
    }
    
    public void displayAllBooks()
    {
    	for(Book book : books)
    	{
    		System.out.println(book.displayBook());
    	}
    }
    
    public void updateBookQuantityByISBN(long isbn) {
        Book book = searchBookByISBN(isbn);
        if (book != null) {
            Scanner scanner = new Scanner(System.in);

            System.out.println("Updating quantity of book : ");
            System.out.print("Enter new Quantity: ");
            int newQuantity = scanner.nextInt();
            if (newQuantity >= 0) {
                book.setQuantity(newQuantity);
                System.out.print("Quantity updated successfully.");
                System.out.println("new quantity = "+newQuantity);
                
            } 
            else 
            {
                System.out.println("Invalid quantity.");
            }
        } else {
            System.out.println("Book with ISBN "+isbn+" not found.");
        }
    }
    
    
 }


Main.java
----------
package com.ravi.virtaul_lab;

import java.util.InputMismatchException;
import java.util.Scanner;

public class Main 
{

    public static void main(String[] args) 
    {
        Library lib = new Library();
        Scanner scanner = new Scanner(System.in);

        while (true) {
            System.out.println("1. Add Book");
            System.out.println("2. Display Books");
            System.out.println("3. Update Quantity");
            System.out.println("4. Exit");
            System.out.print("Choose an option: ");
            int choice = scanner.nextInt();
            scanner.nextLine();  // Consume newline
            
            long isbn =0; double price=0.0;  int quantity = 0;
            switch (choice) 
            {
            
                case 1:
                	 System.out.print("Enter Title: ");
                     String title = scanner.nextLine();
                     System.out.print("Enter Author: ");
                     String author = scanner.nextLine();
                     try
                     {
                    	 System.out.print("Enter ISBN: ");
                         isbn = scanner.nextLong();
                         scanner.nextLine(); 
                     }
                     catch(InputMismatchException e)
                     {
                    	 System.err.println("ISBN must contain number digit only");
                    	 scanner.nextLine(); 
                     }
                     
                     try
                     {
                    	 System.out.print("Enter Price: ");
                         price = scanner.nextDouble();
                         scanner.nextLine(); 
                         
                     }
                     catch(InputMismatchException e)
                     {
                    	 System.err.println("Invalid price format. Please enter a valid number");
                    	 scanner.nextLine(); 
                     }
                     
                     try
                     {
                    	   System.out.print("Enter Quantity: ");
                           quantity = scanner.nextInt();
                           scanner.nextLine(); // Consume newline
                        
                         
                     }
                     catch(InputMismatchException e)
                     {
                    	 System.err.println("Invalid Quantity format. Please enter a valid integer");
                     }   
                                   
                     System.out.print("Enter Book Type (Fiction/NonFiction): ");
                     String bookType = scanner.nextLine();
                     lib.addBook(new Book(title, author, isbn, price, quantity, bookType));
                     break;              
                    case 2:
                    lib.displayAllBooks();
                    break;
                    case 3:
                    System.out.print("Enter ISBN: ");
                    isbn = scanner.nextLong();
                    lib.updateBookQuantityByISBN(isbn);
                    break;
                case 4:
                    System.out.println("Exiting...");
                    scanner.close();
                    return; 
                default:
                    System.out.println("Wrong Choice. Please try again.");
           
    	    }
        } 
    }
}
------------------------------------------------------------------------
Time Complexcity of ArrayList :
-------------------------------
The time complexcity of ArrayList to insert and delete an element from the middle would be O(n) because 'n' number of elements will be re-located so it is not a good choice to perform insertion and deletion operation in the middle of the List. 

On the other hand time complexcity of ArrayList to retrieve an element from the List would be O(1) because by using get(int index) method we can retrieve the element randomly by using the time complexcity O(1) [It implements RandomAccess interface]

[23-APRIL-24]

To avoid this we introduced LinkedList.
---------------------------------------------------------------
LinkedList :
------------
public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, Serializable

It is a predefined class available in java.util package under List interface.

It is ordered by index position like ArrayList except the elements (nodes) are doubly linked to one another. This linkage provide us new method for adding and removing the elements from the middle of LinkedList.

*The important thing is, LikedList may iterate more slowely than ArrayList but LinkedList is a good choice when we want to insert or delete the elements frequently in the list.

From jdk 1.6 onwards LinkedList class has been enhanced to support basic queue operation by implementing Deque<E> interface.

LinkedList methods are not synchronized.

ArrayList is using Array data structure but LinkedList class is using LinkedList data structure.


Constructor:
-------------
It has 2 constructors 

1) LinkedList list1 = new LinkedList();
    It will create a LinkedList object with 0 capacity.

2) LinkedList list2 = new LinkedList(Collection c);
    Interconversion between the collection


Methods of LinkedList class:
-------------------------------
1) void addFirst(Object o)
2) void addLast(Object o)

3) Object getFirst()
4) Object getLast()

5) Object removeFirst()
6) Object removeLast()

Note :- It stores the elements in non-contiguous memory location.           
	   
	   The time complexcity for insertion and deletion is  O(1)

	   The time complexcity for seraching O(n)
------------------------------------------------------------------------
12-06-2024
----------
package com.ravi.linked_list;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
public class LinkedListDemo
{
 public static void main(String args[])
 { 
      List<Object> list=new LinkedList<>();
	  list.add("Ravi");
	  list.add("Vijay");
	  list.add("Ravi");
	  list.add(null);
	  list.add(42);
	  
	  System.out.println("1st Position Element is :"+list.get(1));

	  //Iterator interface 
	  
	   Iterator<Object> itr = list.iterator();
	   itr.forEachRemaining(System.out::println); //JDK 1.8 
	 
  }
}
-----------------------------------------------------------------------
package com.ravi.linked_list;

import java.util.*;
public class LinkedListDemo1
{
      public static void main(String args[])
      {
           LinkedList<String> list= new LinkedList<>(); //generic
           list.add("Item 2");//2
           list.add("Item 3");//3
           list.add("Item 4");//4
           list.add("Item 5");//5
           list.add("Item 6");//6
           list.add("Item 7");//7
           
           list.add("Item 9"); //10

           list.add(0,"Item 0");//0
           list.add(1,"Item 1"); //1

           list.add(8,"Item 8");//8
		   list.add(9,"Item 10");//9
            System.out.println(list);
			
			  list.remove("Item 5"); 
			  
			  System.out.println(list);
			  
			    list.removeLast(); 
			    System.out.println(list);
			 
			    list.removeFirst(); 
			    System.out.println(list);
			
			  list.set(0,"Ajay"); //set() will replace the existing value
			  list.set(1,"Vijay"); 
			  list.set(2,"Anand"); 
			  list.set(3,"Aman");
			  list.set(4,"Suresh"); 
			  list.set(5,"Ganesh");
			  list.set(6,"Ramesh");
			  list.forEach(x -> System.out.println(x)); 
			 		
			
      } 
}
----------------------------------------------------------------------
package com.ravi.linked_list;

//Methods of LinkedList class
import java.util.LinkedList;
public class LinkedListDemo2
{
    public static void main(String[] argv) 
    {
          LinkedList<String> list = new LinkedList<>();
          
          list.addFirst("Ravi");  
          list.add("Rahul"); 
          list.addLast("Anand");	
          
          System.out.println(list.getFirst()); 
          System.out.println(list.getLast()); 
          
          list.removeFirst();
          list.removeLast(); 
          
          System.out.println(list); 
    }
}
-----------------------------------------------------------------------
//ListIterator interface method :
---------------------------------
package com.ravi.linked_list;
//ListIterator methods
import java.util.*;
public class LinkedListDemo3 
{
	public static void main(String[] args) 
	{
		LinkedList<String> city = new LinkedList<> ();
         city.add("Kolkata");
		 city.add("Bangalore");
		 city.add("Hyderabad");
		 city.add("Pune");
		 System.out.println(city);   

		ListIterator<String> lt = city.listIterator();

       while(lt.hasNext())
		  {
			String cityName =  lt.next();

			if(cityName.equals("Kolkata"))
			{
                 lt.remove();
			}
			else if(cityName.equals("Hyderabad"))
			{
                 lt.add("Ameerpet");
			}
			else if(cityName.equals("Pune"))
			{
                 lt.set("Mumbai");
			}
		}
		city.forEach(System.out::println);
	}
}
-----------------------------------------------------------------------
package com.ravi.linked_list;

//Insertion, deletion, displaying and exit

import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

public class LinkedListDemo4
{
 public static void main(String[] args)
	{
      List<Integer> linkedList = new LinkedList<>();
      Scanner scanner = new Scanner(System.in);

        while (true) 
		{
          System.out.println("Linked List: " + linkedList);
          System.out.println("1. Insert Element");
          System.out.println("2. Delete Element");
		  System.out.println("3. Display Element");
          System.out.println("4. Exit");
          System.out.print("Enter your choice: ");

          int choice = scanner.nextInt();
          switch (choice) 
			{
              case 1: 
                  System.out.print("Enter the element to insert: ");
                  int elementToAdd = scanner.nextInt();
                  linkedList.add(elementToAdd);
                  break;
              case 2:
                  if (linkedList.isEmpty()) 
					{
                      System.out.println("Linked list is empty. Nothing to delete.");
                  } 
					else 
					{
                      System.out.print("Enter the element to delete: ");
                      int elemenetToDelete = scanner.nextInt();
       boolean remove =              linkedList.remove(Integer.valueOf(elemenetToDelete));
                      
                       if(remove)
                       {
                    	   System.out.println("Element "+elemenetToDelete+ " is deleted Successfully" );
                       }
                       else
                       {
                    	   System.out.println(elemenetToDelete+" not available is the LinkedList");
                       }
                    
                  }
                  break;
				case 3:
					System.out.println("Elements in the linked list.");
                   System.out.println(linkedList);
				     break;
              case 4:
                  System.out.println("Exiting the program.");
                  scanner.close();
                  System.exit(0);
              default:
                  System.out.println("Invalid choice. Please try again.");
          }
      }
  }
}
----------------------------------------------------------------------
import java.util.LinkedList;
import java.util.Iterator;
import java.util.List;

class Dog 
{
      private String name;
      Dog(String n) 
      {
           name = n;
      }

	public String getName()
	{
		return this.name;
	}

    public String toString()
	{
		return this.name;
	}
}
public class LinkedListDemo5
{
       public static void main(String[] args)
       {
             List<Dog> d = new LinkedList<>();
             Dog dog = new Dog("Tiger");
             d.add(dog);
             d.add(new Dog("Tommy"));
             d.add(new Dog("Rocky"));

             Iterator<Dog> i3 = d.iterator();
		    i3.forEachRemaining(x -> System.out.println(x.getName().toUpperCase())); //java 8      


             System.out.println("size " + d.size());
             System.out.println("Get 1st Position Object " + d.get(1).getName());
             
            
        }
}
------------------------------------------------------------------------
import java.util.Deque;
import java.util.LinkedList;

public class LinkedListDemo6
{
    public static void main(String[] args) 
		{
        // Create a LinkedList and treat it as a Deque
        Deque<String> deque = new LinkedList<>();

        // Adding elements to the front of the deque
        deque.addFirst("Ravi");
        deque.addFirst("Raj");   //Raj  Ravi Pallavi Sweta

        // Adding elements to the back of the deque
        deque.addLast("Pallavi");   
        deque.addLast("Sweta");

        
        System.out.println("Deque: " + deque);  //Raj Ravi P  S

       
        String first = deque.removeFirst();
        String last = deque.removeLast();

       
        System.out.println("Removed first element: " + first);
        System.out.println("Removed last element: " + last);
        System.out.println("Updated Deque: " + deque);
    }
}

-----------------------------------------------------------------------
Vector :
--------
public class Vector<E> extends AbstractList<E>  implements List<E>, Serializable, Clonable, RandomAccess

Vector is a predefined class available in java.util package under List interface. 

Vector is always from java means it is available from jdk 1.0 version.

Vector and Hashtable, these two classes are available from jdk 1.0, remaining Collection classes were added from 1.2 version. That is the reason Vector and Hashtable are called legacy(old) classes.

The main difference between Vector and ArrayList is, ArrayList methods are not synchronized so multiple threads can access the method of ArrayList where as on the other hand most the methods are synchronized in Vector so performance wise Vector is slow.

*We should go with ArrayList when Threadsafety is not required on the other hand we should go with Vector when we need ThreadSafety for reterival operation.

It also stores the elements on index basis.It is dynamically growable with initial capacity 10. The next capacity will be 20 i.e double of the first capacity.

new capacity = current capacity * 2;

Just like ArrayList it also implements List, Serializable, Clonable, RandomAccess interfaces.

Constructors in Vector :
-------------------------
We have 4 types of Constructor in Vector

1) Vector v1 = new Vector();        
     It will create the vector object with default capacity is 10        
    
2) Vector v2 = new Vector(int initialCapacity);     
     Will create the vector object with user specified capacity.

3) Vector v3 = new Vector(int initialCapacity, int incrementalCapacity);     
     Eg :-     Vector v = new Vector(1000,5);

     Initially It will create the Vector Object with initial capacity 1000 and then when  the capacity will be full then increment by 5 so the next capacity would be 1005, 1010 and so on.

 4) Vector v4 = new Vector(Collection c);
      Interconversion between the Collection.
-----------------------------------------------------------------------
//Code for compare the performance of ArrayList and Vector

package com.ravi.iq;

import java.util.ArrayList;
import java.util.Vector;

public class PerformanceComparison {

	public static void main(String[] args) 
	{
		ArrayList<Integer> al = new ArrayList<>();
		
		long startTime = System.currentTimeMillis();
		for(int i=0; i<=1000000; i++)
		{
			al.add(i);
		}
		long endTime = System.currentTimeMillis();
		System.out.println("Total time taken by ArrayList :"+(endTime - startTime)+ " ms");
		
		
		
		Vector<Integer> v1 = new Vector<>();
		startTime = System.currentTimeMillis();
		for(int i=0; i<=1000000; i++)
		{
			v1.add(i);
		}
		endTime = System.currentTimeMillis();
		System.out.println("Total time taken by Vector :"+(endTime - startTime)+ " ms");

	}

}

Note :- Performance wise ArrayList is more better than Vector.
-----------------------------------------------------------------------
//Vector Program on capacity
import java.util.*;
public class VectorExampleDemo1
{
	public static void main(String[] args) 
	{
		Vector<Integer> v = new Vector<>(100,5);  //initial capacity is 100
		System.out.println("Initial capacity is :"+v.capacity());

        for(int i =0; i<100; i++)
		{
             v.add(i);
		}

		System.out.println("After adding 100 elements  capacity is :"+v.capacity());
		v.add(101);		
		System.out.println("After adding 101th elements  capacity is :"+v.capacity());

		System.out.println(v);
	}
}
-----------------------------------------------------------------------
13-06-2024
-----------
package com.ravi.vector;

import java.util.Scanner;
import java.util.Vector;

public class VectorDemo2
{
    public static void main(String[] args) 
    {        
        Vector<String> toDoList = new Vector<>();

        Scanner scanner = new Scanner(System.in);

        int choice;
        do 
        {
            System.out.println("ToDo List Menu:");
            System.out.println("1. Add Task");
            System.out.println("2. View Tasks");
            System.out.println("3. Mark Task as Completed");
            System.out.println("4. Exit");
            System.out.print("Enter your choice: ");

            choice = scanner.nextInt();
            scanner.nextLine(); 

            switch (choice) 
            {
                case 1:
                    // Add Task
                    System.out.print("Enter task description: ");
                    String task = scanner.nextLine();
                    toDoList.add(task);
                    System.out.println("Task added successfully!\n");
                    break;
                case 2:
                    // View Tasks
                    System.out.println("ToDo List:");
                    for (int i = 0; i < toDoList.size(); i++) {
             System.out.println((i + 1) + ". " + toDoList.get(i));
                    }
                    System.out.println();
                    break;
                case 3:
                    // Mark Task as Completed
                    System.out.print("Enter task number to mark as completed: ");
                    int taskNumber = scanner.nextInt();
                    if (taskNumber >= 1 && taskNumber <= toDoList.size()) 
                    {
                        String completedTask = toDoList.remove(taskNumber - 1);
                        System.out.println("Task marked as completed: " + completedTask + "\n");
                    } else {
                        System.out.println("Invalid task number!\n");
                    }
                    break;
                case 4:
                    System.out.println("Exiting ToDo List application. Goodbye!");
                    break;
                default:
                    System.out.println("Invalid choice. Please enter a valid option.\n");
            }

        } while (choice != 4);

       
        scanner.close();
    }
}
----------------------------------------------------------------------
package com.ravi.vector;
//Array To Collection
import java.util.*;
public class VectorDemo3
{
	public static void main(String args[])
	{
		Vector<Integer> v = new Vector<>();  
		
		int x[]={22,20,10,40,15,58};
   
        //Adding array values to Vector
		for(int i=0; i<x.length; i++)
		{
			v.add(x[i]);
		}		
		Collections.sort(v);
		System.out.println("Maximum element is :"+Collections.max(v));
		System.out.println("Minimum element is :"+Collections.min(v));
		System.out.println("Vector Elements :");
		v.forEach(y -> System.out.println(y));
		System.out.println(".....................");
		Collections.reverse(v);
		v.forEach(y -> System.out.println(y));
	}
}
---------------------------------------------------------------------
package com.ravi.vector;

import java.util.Vector;

record Customer(int customerId, String customerName, double customerBill)
{
	
}

public class VectorDemo5
{
  public static void main(String[] args) 
  {
	Vector<Customer> listOfCustomers = new Vector<>();
	listOfCustomers.add(new Customer(1,"A" ,3478.90));
	listOfCustomers.add(new Customer(2,"B" ,2879.90));
	listOfCustomers.add(new Customer(3, "C",3212.90));
	listOfCustomers.add(new Customer(4, "D",3290.90));
	
	listOfCustomers.stream().filter(cust -> cust.customerBill() >3000).forEach(cust -> System.out.println(cust));
	
  }
}
-----------------------------------------------------------------------
Stack :
--------
public class Stack<E> extends Vector<E>

It is a predefined class available in java.util package. It is the sub class of Vector class introduced from JDK 1.0 so, It is also a legacy class. 

It is a linear data structure that is used to store the Objects in LIFO (Last In first out) order.

Inserting an element into a Stack is known as push operation  where as extracting an element from the top of the stack is known as pop operation.

It throws an exception called EmptyStackException, if Stack is empty and we want to fetch the element.

It has only one constructor as shown below

Stack s = new Stack();

------------------------------------------------------------------------------------
Methods :
----------
E push(Object o) :- To insert an element in the bottom of the Stack.

E pop() :- To remove and return the element from the top of the Stack.

E peek() :- Will fetch the element from top of the Stack without removing.

boolean empty() :- Verifies whether the stack is empty or not (return type is boolean)

int search(Object o) :- It will search a particular element in the Stack and it returns OffSet position (int value). If the element is not present in the Stack it will return -1
-----------------------------------------------------------------------
//Program to insert and fetch the elements from stack
package com.ravi.stack;
import java.util.*;
public class Stack1
{
      public static void main(String args[])
      {
            Stack<Integer> s = new Stack<>();
            try
            {     s.push(12);
                  s.push(15);
				  s.push(22);
				  s.push(33);
				  s.push(49);				  
				  System.out.println("After insertion elements are :"+s); 

                  System.out.println("Fetching the elements using pop method");
                  System.out.println(s.pop());
                  System.out.println(s.pop()); 
                  System.out.println(s.pop());  
                  System.out.println(s.pop());  
                  System.out.println(s.pop());
                      
                  
				  	
	 				 				  
				  System.out.println("After deletion elements are :"+s); //[]
				  System.out.println("Is the Stack empty ? :"+s.empty());  
              }
			catch(EmptyStackException e)
			{
			   e.printStackTrace();
			} 
      }
}
---------------------------------------------------------------------
//add(Object obj) is the method of Collection
package com.ravi.stack;
import java.util.*;
public class Stack2
{
      public static void main(String args[])
      {
            Stack<Integer> st1 = new Stack<>();
            st1.add(10);
            st1.add(20);      
            st1.forEach(x -> System.out.println(x));

            Stack<String> st2 = new Stack<>();
            st2.add("Java");  
            st2.add("is");
            st2.add("programming");
            st2.add("language"); 
            st2.forEach(x -> System.out.println(x));

            Stack<Character> st3 = new Stack<>();
            st3.add('A');  
            st3.add('B');
            st3.forEach(x -> System.out.println(x));

            Stack<Double> st4 = new Stack<>();
            st4.add(10.5);
            st4.add(20.5);               
            st4.forEach(x -> System.out.println(x));          
      }  
}

Note :- add(Object obj) method is available in Collection interface overridden by Vector class so it is available in Stack class.
-----------------------------------------------------------------
package com.ravi.stack;
import java.util.Stack;  

public class Stack3
{  
	public static void main(String[] args)   
		{  
			Stack<String> stk= new Stack<>();  
			stk.push("Apple");  
			stk.push("Grapes");  
			stk.push("Mango");  
			stk.push("Orange");  
			System.out.println("Stack: " + stk);  
			
			String fruit = stk.peek(); 			
			System.out.println("Element at top: " + fruit);  
			System.out.println("Stack elements are : " + stk); 
		}  
}  
--------------------------------------------------------------------
//Searching an element in the Stack
package com.ravi.stack;
import java.util.Stack;  
public class Stack4
{  
	public static void main(String[] args)   
		{  
			Stack<String> stk= new Stack<>();  
			stk.push("Apple");  
			stk.push("Grapes");  
			stk.push("Mango"); 					
			System.out.println("Offset Position is : " + stk.search("Mango")); //1			
			System.out.println("Offser Position is : " + stk.search("Banana")); //-1
		    System.out.println("Is stack empty ? "+stk.empty());	//false
			
			System.out.println("Index Position is : " + stk.indexOf("Mango")); //2
		}  
}  

offset position means the element which will be extracted first from the top of the Stack
-----------------------------------------------------------------------
Set interface :
---------------
Set interface is the sub interface of Collection(I) which came from JDK 1.2v

Set interface never accept duplicate elements, Here internally equals(Object obj) method is working to verify two object are identical or not, if identical then it will accept only 1.

Set intreface does not use any indexing technique.

ListIterator interface does not work with Set interface.

Set interface uses methods of Collection interface as well as It has more methods from java 9.

Set interface Hierarchy :
--------------------------
Available in the paint diagram (25-APRIL)
-----------------------------------------------------------------
14-06-2024
-----------
HashSet (UNSORTED , UNORDERED, NO DUPLICATES)
---------------------------------------------
public class HashSet<E> extends AbstractSet<E> implements Set<E>, Clonabale, Serializable

It is a predefined class available in java.util package under Set interface and introduced from JDK 1.2V.

It is an unsorted and unordered set.  

It accepts hetrogeneous kind of data.

*It uses the hashcode of the object being inserted into the Collection. Using this hashcode it finds the bucket location.

It doesn't contain any duplicate elements as well as It does not maintain any order while iterating the elements from the collection.

It can accept null value.

HashSet methods are not synchronized.

HashSet is used for fast searching operation.

It contains 4 types of constructors 
1) HashSet hs1 = new HashSet();
    It will create the HashSet Object with default capacity is 16. The default load fator or Fill Ratio is 0.75   (75% of HashSet is filled up then new HashSet Object will be created having double capacity)

2) HashSet hs2 = new HashSet(int initialCapacity);
    will create the HashSet object with user specified capacity


3) HashSet hs3 = new HashSet(int initialCapacity, float loadFactor);
    we can specify our own initialCapacity and loadFactor(by default load factor is 0.75)

4) HashSet hs = new HashSet(Collection c);
    Interconversion of Collection
------------------------------------------------------------------------
//Unsorted, Unordered and no duplicates
import java.util.*;
public class HashSetDemo 
{
 public static void main(String args[])
 { 
	    HashSet<Integer> hs = new HashSet<>();
		hs.add(67); 
		hs.add(89);
		hs.add(33);
		hs.add(45);
		hs.add(12);
		hs.add(35);
		
		hs.forEach(str-> System.out.println(str));
	}
}

We have a diagram for this program [14-JUNE]
-----------------------------------------------------------------------
import java.util.*;
public class HashSetDemo1
{
      public static void main(String[] argv) 
      {
      HashSet<String> hs=new HashSet<>();	  
	  hs.add("Ravi");
	  hs.add("Vijay");
	  hs.add("Ravi");
	  hs.add("Ajay");
	  hs.add("Palavi");
	  hs.add("Sweta");
	  hs.add(null);
	  hs.add(null);
	  hs.forEach(str -> System.out.println(str));

      }
}

Note :- HashSet does not maintain any order while iterating the elements.
------------------------------------------------------------------------
package com.nit.oop;

import java.util.Arrays;
import java.util.HashSet;

public class HashDemo2 {

	public static void main(String[] args) 
	{
	   Boolean [] bool = new Boolean[5];	
		
       HashSet<Object> hs = new HashSet<>();
       bool[0]=  hs.add(12);
       bool[1]=  hs.add(new String("NIT"));
       bool[2]=  hs.add(12);
       bool[3]=  hs.add(new StringBuffer("Ampt"));
       bool[4] = hs.add(new String("NIT"));
       
       System.out.println(Arrays.toString(bool));
       
       hs.forEach(System.out::println);
       
	}

}
-----------------------------------------------------------------------
//add, delete, display and exit
import java.util.HashSet;
import java.util.Scanner;

public class HashSetDemo3
{
    public static void main(String[] args) 
		{
        HashSet<String> hashSet = new HashSet<>();
        Scanner scanner = new Scanner(System.in);

        while (true) 
		{
            System.out.println("Options:");
            System.out.println("1. Add element");
            System.out.println("2. Delete element");
            System.out.println("3. Display HashSet");
            System.out.println("4. Exit");

            System.out.print("Enter your choice (1/2/3/4): ");
            int choice = scanner.nextInt();

            switch (choice) 
			{
                case 1:
                    System.out.print("Enter the element to add: ");
                    String elementToAdd = scanner.next();
                    if (hashSet.add(elementToAdd)) 
					{
                        System.out.println("Element added successfully.");
                    } 
					else
					{
                        System.out.println("Element already exists in the HashSet.");
                    }
                    break;
                    case 2:
                    System.out.print("Enter the element to delete: ");
                    String elementToDelete = scanner.next();
                    if (hashSet.remove(elementToDelete)) 
					{
                        System.out.println("Element deleted successfully.");
                    } 
					else 
					{
                        System.out.println("Element not found in the HashSet.");
                    }
                    break;
                    case 3:
                    System.out.println("Elements in the HashSet:");
                    hashSet.forEach(System.out::println);
                    break;
                    case 4:
                    System.out.println("Exiting the program.");
                    scanner.close();
                    System.exit(0);
                    default:
                    System.out.println("Invalid choice. Please try again.");
            }

            System.out.println(); 
        }
    }
}
-----------------------------------------------------------------------
LinkedHashSet :
---------------  
public class LinkedHashSet extends HashSet implements Set, Clonable, Serializable

It is a predefined class in java.util package under Set interface and introduced from java 1.4v. 

It is the sub class of HashSet class.

It is an orderd version of HashSet that maintains a doubly linked list across all the elements. 

It internally uses Hashtable and LinkedList data structures.

We should use LinkedHashSet class when we want to maintain an order.

When we iterate the elements through HashSet the order will be unpredictable, while when we iterate the elments through LinkedHashSet then the order will be same as they were inserted in the collection.

It accepts hetrogeneous and null value is allowed.

It has same constructor as HashSet class.  
------------------------------------------------------------------------
import java.util.*;
public class LinkedHashSetDemo
{
 public static void main(String args[])
	{ 
		  LinkedHashSet<String> lhs=new LinkedHashSet<>();
		  lhs.add("Ravi");
		  lhs.add("Vijay");
		  lhs.add("Ravi");
		  lhs.add("Ajay");
		  lhs.add("Pawan");
		  lhs.add("Shiva");
		  lhs.add(null);
		  lhs.add("Ganesh");          
		  lhs.forEach(str -> System.out.println(str));	   
	}
}
-----------------------------------------------------------------------
import java.util.LinkedHashSet;

public class LinkedHashSetDemo1 
{
    public static void main(String[] args) 
	{
       LinkedHashSet<Integer> linkedHashSet = new LinkedHashSet<>();

        linkedHashSet.add(10);
        linkedHashSet.add(5);
        linkedHashSet.add(15);
        linkedHashSet.add(20);
        linkedHashSet.add(5); 

        System.out.println("LinkedHashSet elements: " + linkedHashSet);

        System.out.println("LinkedHashSet size: " + linkedHashSet.size());

        int elementToCheck = 15;
        if (linkedHashSet.contains(elementToCheck)) 
		{
            System.out.println(elementToCheck + " is present in the LinkedHashSet.");
        } 
		else 
		{
            System.out.println(elementToCheck + " is not present in the LinkedHashSet.");
        }

        int elementToRemove = 10;
        linkedHashSet.remove(elementToRemove);
        System.out.println("After removing " + elementToRemove + ", LinkedHashSet elements: " + linkedHashSet);

              linkedHashSet.clear(); 
        System.out.println("After clearing, LinkedHashSet elements: " + linkedHashSet); //[]
    }
}
-----------------------------------------------------------------------
SortedSet interface :
---------------------
As we know we can't perform sorting operation by using Collections.sort() in HashSet and LinkedHashSet because sort() method accepts List as a parameter.

To provide sorting facility, java software people introduced SortedSet interface.

SortedSet interface provides default natural sorting order that means if we are sorting numeric value then ascending order and if we are sorting String then alphabetical order Or dictionary order.

In order to provide sorting, It uses Comparable<T> and Comparator<T>
interfaces.
-----------------------------------------------------------------------
*** What is difference between Comparable and Comparator
Difference chart is available in pasin diagram 

Program on Comparable<T>
-------------------------
2 files :
----------
Employee.java(R)
-----------------
package com.nit.compare;

public record Employee(int empId, String empName) implements Comparable<Employee>
{
        //Sorting based on the Employee name
	@Override
	public int compareTo(Employee e2) 
	{
		return this.empName.compareTo(e2.empName);      	
	}
}


EmployeeComparable.java
------------------------
package com.nit.compare;

import java.util.ArrayList;
import java.util.Collections;

public class EmployeeComparable 
{
   public static void main(String[] args) 
   {
	 ArrayList<Employee> al = new ArrayList<>();
	 al.add(new Employee(444, "Virat"));
	 al.add(new Employee(111, "Zuber"));
	 al.add(new Employee(222, "Rohit"));
	 al.add(new Employee(333, "Aryan"));
	 
	 Collections.sort(al);
	 
	 al.forEach(System.out::println);
	 
   }
}


Limitation of Comparable :
--------------------------
1) It provides only one sorting logic 

2) Here we can modify BLC class file because It is written by same 
   developer but if the same BLC class is given by another developer in .class file format then we can't modify the source code.

Program on Comparator :
-----------------------
2 files :
---------
package com.nit.comparator;

public record Product(int productId, String productName) {

}

ProductComparator.java
----------------------
package com.nit.comparator;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class ProductComparator {

	public static void main(String[] args) 
	{
		ArrayList<Product> al = new ArrayList<>();
		al.add(new Product(333, "Camera"));
		al.add(new Product(222, "Laptop"));
		al.add(new Product(111, "Mobile"));
		
		Comparator<Product> cmpId = new Comparator<Product>()
		{
			@Override
			public int compare(Product p1, Product p2) 
			{
				return p1.productId() - p2.productId();
			}
		
		};

		Collections.sort(al, cmpId);
		System.out.println("Sorting based on the ID ");
		al.forEach(System.out::println);
		
		Comparator<Product> cmpName = (p1,p2)-> p1.productName().compareTo(p2.productName());
		Collections.sort(al, cmpName);
		System.out.println("Sorting based on the Name ");
		al.forEach(System.out::println);
		
	}

}
-----------------------------------------------------------------------
16-06-2024
----------
Program that describes how to write descending order logic for 
Integer class.

package com.ravi.collection;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class UserDefinedSorting {

	public static void main(String[] args) 
	{
		ArrayList<Integer> al = new ArrayList<>();
		al.add(78);
		al.add(48);
		al.add(94);
		al.add(88);
		al.add(32);
		
		Comparator<Integer> compDesc = (i1, i2)-> i2-i1;
		
		Collections.sort(al, compDesc);
		
		al.forEach(num -> System.out.println(num));
		

	}

}
-----------------------------------------------------------------------
TreeSet :
---------
TreeSet :
---------
public class TreeSet<E> extends AbstractSet<E> implements NavigableSet<E>, Clonable, Serializable

It is a predefined class available in java.util package under Set interface.

TreeSet, TreeMap  and PriorityQueue are the three sorted collection in the entire Collection Framework so these classes never accepting non comparable objects.

It will sort the elements in natural sorting order i.e ascending order in case of number , and alphabetical order or Dictionary order in the case of String. In order to sort the elements according to user choice, It uses Comparable/Comparator  interface.

It does not accept duplicate and null value (java.lang.NullPointerException).

It does not accept non comparable type of data if we try to insert it will throw a runtime exception i.e java.lang.ClassCastException

TreeSet implements NavigableSet.

NavigableSet extends SortedSet.

It contains 4 types of constructors :
----------------------------------------
1) TreeSet t1 = new TreeSet();
     create an empty TreeSet object, elements will be inserted in a natural sorting order.

2) TreeSet t2 = new TreeSet(Comparator c);
    Customized sorting order

3)  TreeSet t3 = new TreeSet(Collection c);

4) TreeSet t4 = new TreeSet(SortedSet s);
-----------------------------------------------------------------------
package com.ravi.exception;

import java.util.TreeSet;

public class TreeSetDemo {

	public static void main(String[] args)
	{
		TreeSet<Dog> ts = new TreeSet<>();
		ts.add(new Dog(2));
		ts.add(new Dog(3));
		ts.add(new Dog(1));
		
		System.out.println(ts);
	}

}

class Dog implements Comparable<Dog>
{
	private int id;

	public Dog(int id) 
	{
		super();
		this.id = id;
	}

	@Override
	public int compareTo(Dog d2) 
	{
		return this.id - d2.id;
	}

	@Override
	public String toString() {
		return "Dog [id=" + id + "]";
	}
	
	
	
}
-----------------------------------------------------------------------
package com.ravi.exception;

import java.util.TreeSet;

public class TreeSetDemo1 
{
  public static void main(String[] args) 
  {
	TreeSet<Integer> ts1 = new TreeSet<>((i1,i2)-> (i2-i1));
	
	ts1.add(20);
	ts1.add(10);  
	ts1.add(30);
	
	ts1.forEach(System.out::println);
	
  }
}
-----------------------------------------------------------------------
//program that describes TreeSet provides default natural sorting order
import java.util.*;
public class TreeSetDemo 
{
	public static void main(String[] args) 
	{
		SortedSet<Integer> t1 = new TreeSet<>();
		t1.add(4);
		t1.add(7);
		t1.add(2);
		t1.add(1);
		t1.add(9);	

	
		System.out.println(t1);

		NavigableSet<String> t2 = new TreeSet<>();
		t2.add("Orange");
		t2.add("Mango");
		t2.add("Banana");
		t2.add("Grapes");
		t2.add("Apple");		
		System.out.println(t2);		
	}
}
---------------------------------------------------------------------
import java.util.*;
public class TreeSetDemo1
{
	public static void main(String[] args) 
	{
		TreeSet<String> t1 = new TreeSet<>();
		t1.add("Orange"); 
		t1.add("Mango");
		t1.add("Pear");
		t1.add("Banana");
		t1.add("Apple");	
		System.out.println("In Ascending order");
		t1.forEach(i -> System.out.println(i));

		TreeSet<String> t2 = new TreeSet<>();
		t2.add("Orange");
		t2.add("Mango");
		t2.add("Pear");
		t2.add("Banana");
		t2.add("Apple");

        System.out.println("In Descending order");
		Iterator<String> itr2 = t2.descendingIterator();  //for descending order

         itr2.forEachRemaining(x -> System.out.println(x));		
	}
}

Note :- descendingIterator() is a predefined method of TreeSet class which will traverse in the descending order and return type of this method is Iterator interface.

public Iterator descendingIterator()
-----------------------------------------------------------------------
import java.util.*;
public class TreeSetDemo2
{
	public static void main(String[] args) 
	{
		Set<String> t = new TreeSet<>();  
		t.add("6");   
		t.add("5");
		t.add("4");
		t.add("2");
		t.add("9");	
		Iterator<String> iterator = t.iterator();
		iterator.forEachRemaining(x -> System.out.println(x));

		//From 1.8 to replace hasNext() and next() method
	}
}
-----------------------------------------------------------------------
import java.util.*;  

public class TreeSetDemo3 
	{
	public static void main(String[] args)
	{
		Set<Character> t = new TreeSet<>();  
		t.add('A'); 
		t.add('C');
		t.add('B');
		t.add('E');
		t.add('D');	
		Iterator<Character> iterator = t.iterator();
		iterator.forEachRemaining(x -> System.out.println(x)); 			
	}
}
-----------------------------------------------------------------------
//Different sorting logic for Custom Object

package com.nit.collection;

import java.util.TreeSet;

record Student(int studentId, String studenetName)
{
	
}

public class TreeSetDemo4 
{
	public static void main(String[] args) 
	{
		TreeSet<Student> ts1 = new TreeSet<>((s1,s2)-> s1.studentId()-s2.studentId());
		
		ts1.add(new Student(333, "Aryan"));
		ts1.add(new Student(222, "Ravi"));
		ts1.add(new Student(111, "Zuber"));
		System.out.println("Sorting based on the Student Id (Ascending)");
		ts1.forEach(s -> System.out.println(s));
		
		
        TreeSet<Student> ts2 = new TreeSet<>((s1,s2)-> s2.studentId()-s1.studentId());
		
		ts2.add(new Student(333, "Aryan"));
		ts2.add(new Student(222, "Ravi"));
		ts2.add(new Student(111, "Zuber"));
		System.out.println("Sorting based on the Student Id (Descending)");
		ts2.forEach(s -> System.out.println(s));
		
		 TreeSet<Student> ts3 = new TreeSet<>((s1,s2)-> s1.studenetName().compareTo(s2.studenetName()));
		 
		 
		 ts3.add(new Student(333, "Aryan"));
		 ts3.add(new Student(222, "Ravi"));
		 ts3.add(new Student(111, "Zuber"));
	System.out.println("Sorting based on the Student Name (Ascending)");
			ts3.forEach(s -> System.out.println(s));
			
		
		
	}

}
-----------------------------------------------------------------------
package com.nit.collection;

import java.util.SortedSet;
import java.util.TreeSet;

public class TreeSetDemo5 {

	public static void main(String[] args) 
	{
		SortedSet<String> ss = new TreeSet<>();
		ss.add("Mango");
		ss.add("Orange");
		
		TreeSet<String> ts1 = new TreeSet<>(ss);
		ts1.add("Apple");
		ts1.add("Kiwi");
		
		System.out.println(ts1);

	}

}
----------------------------------------------------------------------
17-06-2024
-----------
Methods of SortedSet interface :
--------------------------------------
public E first() :- Will fetch first element

public E last() :- Will fetch last element

public SortedSet headSet(int range) :- Will fetch the values which are less than specified range

public SortedSet tailSet(int range) :- Will fetch the values which are equal and greater than the specified range.

public SortedSet subSet(int startRange, int endRange) :- Will fetch the range of values where startRange is inclusive and endRange is exclusive.

Note :- headSet(), tailSet() and subSet(), return type is SortedSet
-----------------------------------------------------------------------
import java.util.*;
public class SortedSetMethodDemo
{
       public static void main(String[] args) 
       {
            TreeSet<Integer> times = new TreeSet<>();
            times.add(1205);
            times.add(1505);
            times.add(1545);
			times.add(1600);
            times.add(1830);
            times.add(2010);
            times.add(2100);
            
            SortedSet<Integer> sub = new TreeSet<>();
            
			sub = times.subSet(1545,2100); 
            System.out.println("Using subSet() :-"+sub);//[1545, 1600,1830,2010]
            System.out.println(sub.first());
            System.out.println(sub.last());   
			
		    sub = times.headSet(1545); 
			System.out.println("Using headSet() :-"+sub); //[1205, 1505]
            
		     sub =  times.tailSet(1545); 
			 System.out.println("Using tailSet() :-"+sub); //[1545 to 2100] 
       }
}
----------------------------------------------------------------------
NavigableSet :
--------------
By using SortedSet interface methods we can provide range of values but It will not provide navigation among the elements.

In order to provide navigation among the elements, Java software people
has provided a separarte interface called NavigableSet which is extending from SortedSet interface.

import java.util.*;

public class NavigableSetDemo 
{   
    public static void main(String[] args)
    {
        NavigableSet<Integer> ns = new TreeSet<>(); 
        ns.add(1);
        ns.add(2);
        ns.add(3);
        ns.add(4);
        ns.add(5);
        ns.add(6);

		System.out.println("lower(3): " + ns.lower(3));//Just below than the specified element or null
        
        System.out.println("floor(3): " + ns.floor(3)); //Equal  less or null
      
        System.out.println("higher(3): " + ns.higher(3));//Just greater than specified element or null
  
       System.out.println("ceiling(3): " + ns.ceiling(3));//Equal or greater or null 
	   
        	
    }
}
----------------------------------------------------------------------
package com.ravi.calculation;

enum Direction 
{
	EAST, WEST, NORTH, SOUTH;
	
	private Direction()
	{
		System.out.println("Executed");
	}
}

/* public final class Direction extends java.lang.Enum
 * {
 *   public static final Direction EAST = new Direction();
 *   public static final Direction WEST = new Direction();
 *   public static final Direction NORTH = new Direction();
 *   public static final Direction SOUTH = new Direction();
 * 
 * 
 * }
 */



public class EnumDemo {  

	public static void main(String[] args) 
	{
		System.out.println(Direction.EAST);

	}

}
----------------------------------------------------------------------
Map interface :
---------------
As we know Collection interface is used to hold single Or individual object but Map interface will hold group of objects in the form key and value pair. {key = value}

Map interface is not the part the Collection.

Before Map interface We had Dictionary(abstract class) class and it is extended by Hashtable class in JDK 1.0V

Map interface works with key and value pair introduced from 1.2V.

Here key and value both are objects.

Here key must be unique and value may be duplicate.

Each key and value pair is creating one Entry.(Entry is nothing but the combination of key and value pair)

interface Map
{   
     interface Entry
      {
         //key and value
      }
}

How to represent this entry interface (Map.Entry in .java) [Map$Entry in .class]

In Map interface whenever we have a duplicate key then the old key value will be replaced by new key(duplicate key) value.

forEach(BiConsumer cons) method is available in Map interface.

Iterator and ListIterator we can't use directly using Map.
-----------------------------------------------------------------------
Map interface Hierarchy :
-------------------------
Map interface Hierarchy [17-JUNE-24]
---------------------------------------------------------------
Methods of Map interface :
--------------------------
1) Object put(Object key, Object value) :- To insert one entry in the Map collection. It will return the old object key value if the key is already available(Duplicate key), If key is not available then it will return null.

2) putIfAbsent(Object key, Object value) :- It will insert an entry if and only if key is not present , if the key is already available then it will not insert the Entry to the Map Collection


3) Object get(Object key) :- It will return  corresponding value of key, if the key is not present then it will return null.

4) Object getOrDefault(Object key, Object defaultValue) :- To avoid null value this method has been introduced, here we can pass some defaultValue to avoid the null value.

5) boolean containsKey(Object key) :- To Search a particular key

6) boolean containsValue(Object value) :- To Search a particular value

7) int size() :- To count the number of Entries.

8) remove(Object key) :- One complete entry will be removed.

9) void clear() :- Used to clear the Map  

10) boolean isEmpty() :- To verify Map is empty or not?

11) void putAll(Map m) :- Merging of two Map collection.
----------------------------------------------------------------------
Methods which are used to convert Map into Collection :
--------------------------------------------------------
1) public Set keySet() : Will provide all the unique keys

2) public Collection values () : Will provide all the values()

3) public Set<Mp.Entry> entrySet() : Will provide key and value pair
                                     both
----------------------------------------------------------------------
18-06-2024
-----------
*** How HashMap Works internally ?
----------------------------------
a) While working with HashSet or HashMap every object must be compared because duplicate objects are not allowed.

b) Whenever we add any new key to verify whether key is unique or duplicate, HashMap internally uses hashCode(), == operator and equals method.

c) While adding the key object in the HashMap, first of all it will invoke the hashCode() method to retrieve the corresponding key hashcode value.
    Example :- hm.put(key,value);
               then internally key.hashCode();

d) If the newly added key and existing key hashCode value both are same (Hash collision), then only == operator is used for comparing those keys by using reference or memory address, if both keys references are same then existing key value will be replaced with new key value.

        If the reference of both keys are different then equals(Object obj) method is invoked to compare those keys by using state(data). [content comparison]

	If the equals(Object obj) method returns true (content wise both keys are same), this new key is duplicate then existing key value will be replaced by new key value.

	If equals(Object obj) method returns false, this new key is unique, new entry (key-value) will be inserted.

	Note :- equals(Object obj) method is invoked only when two keys are having same hashcode as well as their references are different.

e) Actually by calling hashcode method we are not comparing the objects, we are just storing the objects in a group so the currently adding key object will be compared with its HASHCODE GROUP objects, but not with all the keys which are available in the Map.

f) The main purpose of storing objects into the corresponding group to decrease the number of comparison so the efficiency of the program will increase.

g) To insert an entry in the HashMap, HashMap internally uses Hashtable data structure

h) Now, for storing same hashcode object into a single group, hash table data structure internally uses one more data structure called Bucket.

i) The Hashtable data structure internally uses Node class array object.

j) The bucket data structure internally uses LinkedList data structure, It is a single linked list again implemented by Node class only.

*k) A bucket is group of entries of same hash code keys.

l) Performance wise LinkedList is not good to serach, so from java 8 onwards LinkedList is changed to Binary tree to decrease the number of comparison within the same bucket hashcode if the number of entries are greater than 8.

* equals() and hashCode() method contract :
-----------------------------------------
Both the methods are working together to find out the duplicate objects in the Map.

*If equals() method invoked on two objects and it returns true then hashcode of both the objects must be same.

Note : IF TWO OBJECTS ARE HAVING SAME HASH CODE THEN IT MAY BE SAME OR DIFFERENT BUT if we call equals() methdo then hashCode of both the objects must be same.
-----------------------------------------------------------------------
package com.nit.collection;

import java.util.HashMap;

public class HashMapInternals {

	public static void main(String[] args) 
	{
		HashMap<String,Integer> hm1 = new HashMap<>();
		hm1.put("A", 1);
		hm1.put("A", 2);
		hm1.put(new String("A"), 3);
		System.out.println("Size is :"+hm1.size());
		System.out.println(hm1);
		System.out.println("....................");
		HashMap<Integer,Integer> hm2 = new HashMap<>();
		hm2.put(128, 1);
		hm2.put(128, 2);
		System.out.println("Size is :"+hm2.size());
		System.out.println(hm2);
		System.out.println("....................");
		HashMap hm3 = new HashMap();
		hm3.put("A", 1);
		hm3.put("A", 2);
		hm3.put(new String("A"), 3);
		hm3.put(65, 4);
		System.out.println("Size is :"+hm3.size());
		System.out.println(hm3);
		


	}

}
-----------------------------------------------------------------------
import java.util.*;
class Employee
{
	int eid;
	String ename;

	Employee(int eid, String ename)
	{
		this.eid = eid;
		this.ename = ename;
	}

    @Override
	public boolean equals(Object obj)  //obj = e2
	{		
		if(obj instanceof Employee)
        {
			Employee e2 = (Employee) obj; //downcasting

			if(this.eid == e2.eid && this.ename.equals(e2.ename))
			{
				return true;
			}
			else
			{
				return false;
			}
	    }
		else
		{
			System.out.println("Comparison is not possible");
			return false;
		}		
	}

	public String toString()
		{
			 return " "+eid+" "+ename;
		}
}
public class HashMapDemo8
{
	public static void main(String[] args) 
	{
		Employee e1 = new Employee(101,"Aryan");
		Employee e2 = new Employee(102,"Pooja");
		Employee e3 = new Employee(101,"Aryan");
		Employee e4 = e2;

		
		HashMap<Employee,String> hm = new HashMap<>();
		hm.put(e1,"Ameerpet");
		hm.put(e2,"S.R Nagar");
		hm.put(e3,"Begumpet");
		hm.put(e4,"Panjagutta");

		hm.forEach((k,v)-> System.out.println(k+" : "+v));
	}
}
-----------------------------------------------------------------------
19-06-2024
-----------
String intern method programs :
-------------------------------
package com.ravi.intern_demo;

public class StringIntern
{
  public static void main(String[] args) 
  {
	String str1 = "india";
	String str2 = new String("india");
	
	System.out.println(str1==str2);
	str2 = str2.intern();
	System.out.println(str1==str2);
   }
}
-----------------------------------------------------------------------
package com.ravi.intern_demo;

public class StringInternDemo1 {

	public static void main(String[] args)
	{
		String str1 = new String("Hyd");		
		String str2 = "Hyd";
		
		System.out.println(str1==str2);
		
		String str3 = str1.intern();
		
		System.out.println(str2==str3);

	}

}
----------------------------------------------------------------------
HashMap<K,V> :-  [Unsorted, Unordered, No Duplicate keys]
----------------------------------------------------------
public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Serializable, Clonable 

It is a predefined class available in java.util package under Map interface available from JDK 1.2.

It gives us unsorted and Unordered map. when we need a map and we don't care about the order while iterating the elements through it then we should use HashMap.

It inserts the element based on the hashCode of the Object key using hashing technique [hasing alogorithhm]

It does not accept duplicate keys but value may be duplicate.

It accepts only one null key(because duplicate keys are not allowed) but multiple null values are allowed.

HashMap is not synchronized.  

Time complexcity of search, insert and delete will be O(1)

We should use HashMap to perform fast searching opeartion.

It contains 4 types of constructor 

1) HashMap hm1 = new HashMap();
    It will create the HashMap Object with default capacity is 16. The default load fator or Fill Ratio is 0.75   (75% of HashMap is filled up then new HashMap Object will be created having double capacity)

2) HashMap hm2 = new HashMap(int initialCapacity);
    will create the HashMap object with user specified capacity


3) HashMap hm3 = new HashMap(int initialCapacity, float loadFactor);
    we can specify our own initialCapacity and loadFactor(by default load factor is 0.75%)

4)HashMap hm4 = new HashMap(Map m);
    Interconversion of Map Collection
----------------------------------------------------------------------
//Program that shows HashMap is unordered
import java.util.*;
public class HashMapDemo 
{
      public static void main(String[] a) 
      {
           Map<String,String> map = new HashMap<>();
		   map.put("Ravi", "12345");  
		   map.put("Rahul", "12345");
		   map.put("Aswin", "5678");
		   map.put(null, "6390");
		   map.put("Ravi","1529");
		   map.put("Aamir","890");

		   System.out.println(map); //{=}
           
           System.out.println(map.get(null));  
		   System.out.println(map.get("Virat"));  
		   
		   map.forEach((k,v)-> System.out.println("Key is :"+k+" value is "+v)); 
		                 
      }
}
---------------------------------------------------------------------
//Program to search a particular key and value in the Map collection
import java.util.*;
public class HashMapDemo1
{
	public static void main(String args[]) 
	{
		HashMap<Integer,String> hm = new HashMap<>();			 
		hm.put(1, "JSE");  
		hm.put(2, "JEE");
		hm.put(3, "JME"); 
		hm.put(4,"JavaFX");
		hm.put(5,null);
		hm.put(6,null);
		
		System.out.println("Initial map elements: " + hm); 
		System.out.println("key 2 is present or not :"+hm.containsKey(2));   

		System.out.println("JME is present or not :"+hm.containsValue("JME")); 

		System.out.println("Size of Map : " + hm.size()); 
		hm.clear(); 	
		System.out.println("Map elements after clear: " + hm);
	}
}
-----------------------------------------------------------------------
//Collection view methods [keySet(),  values(), Set<Map.Entry> entrySet()]
import java.util.*;
public class HashMapDemo2
{
public static void main(String args[]) 
	{
			Map<Integer,String> map = new HashMap<>(); 
			map.put(1, "C");
			map.put(2, "C++");
			map.put(3, "Java");
			map.put(4, ".net");
		
			map.forEach((k,v)->System.out.println("Key :"+k+" Value :"+v) );           
			           
			System.out.println("Return Old Object value :"+map.put(4,"Python"));  

			Set keys =  map.keySet();
			System.out.println("All keys are :"+keys);

			Collection values = map.values();
			System.out.println("All values are :"+values);
		
			for(Map.Entry m : map.entrySet())
			 {  
				 System.out.println(m.getKey()+" = "+m.getValue());  
			}  
	}    
}
-----------------------------------------------------------------------
import java.util.*;
public class HashMapDemo3
{
public static void main(String args[]) 
  {
		HashMap<Integer,String> map = new HashMap<>(26,0.95f);
		map.put(1, "Java");
		map.put(2, "is");
		map.put(3, "best");
		map.remove(3);  //will remove the complete Entry
		String val=(String)map.get(3);
		System.out.println("Value for key 3 is: " + val);
		map.forEach((k,v)->System.out.println(k +" : "+v));
   }    
}
---------------------------------------------------------------------
//To merge two Map Collection (putAll)  
import java.util.*;
public class HashMapDemo4
{
public static void main(String args[]) 
	{
		HashMap<Integer,String> newmap1 = new HashMap<>();

		HashMap<Integer,String> newmap2 = new HashMap<>();	  

		newmap1.put(1, "OCPJP");
		newmap1.put(2, "is");
		newmap1.put(3, "best");
			  
		System.out.println("Values in newmap1: "+ newmap1);

		newmap2.put(4, "Exam");

		newmap2.putAll(newmap1);

		newmap2.forEach((k,v)->System.out.println(k+" : "+v));		
   }    
}
----------------------------------------------------------------------
import java.util.*;
public class HashMapDemo5 
{
     public static void main(String[] argv) 
     {
          Map<String,String> map = new HashMap<>(9, 0.85f);
          map.put("key", "value");
          map.put("key2", "value2");
          map.put("key3", "value3");
		  map.put("key7","value7");


		   Set keys = map.keySet();//keySet return type is Set
		   System.out.println(keys ); //

          Collection val = map.values(); //values return type is collection
          System.out.println(val);
         
		  map.forEach((k,v)-> System.out.println(k+" : "+v));
		  
          	  
      }
}
-----------------------------------------------------------------------
//getOrDefault() method
import java.util.*;
public class  HashMapDemo6
{
	public static void main(String[] args) 
	{
		Map<String, String> map = new HashMap<>();
		map.put("A", "1");
		map.put("B", "2");
		map.put("C", "3");
        //if the key is not present, it will return default value .It is used to avoid null
		String value = map.getOrDefault("D","Key is not available");
		System.out.println(value);
		System.out.println(map); 
	}
}
---------------------------------------------------------------------
//interconversion of two HashMap
import java.util.*;
public class HashMapDemo7
	{
	public static void main(String args[])
	{		
		HashMap<Integer, String> hm1 = new HashMap<>();

		hm1.put(1, "Ravi");
		hm1.put(2, "Rahul");
		hm1.put(3, "Rajen");

		HashMap<Integer, String> hm2	= new HashMap<>(hm1);

		System.out.println("Mapping of HashMap hm1 are : "	+ hm1);
	
		System.out.println("Mapping of HashMap hm2 are : " + hm2);
	}
}
-----------------------------------------------------------------------
LinkedHashMap :
---------------
LinkedHashMap :
------------------
public class LinkedHashMap<K,V> extends HashMap<K,V> implements Map<K,V>

It is a predefined class available in java.util package under Map interface available from 1.4.

It is the sub class of HashMap class.

It maintains insertion order. It contains a doubly linked with the elements or nodes so It will iterate more slowly in comparison to HashMap.

It uses Hashtable and LinkedList data structure.

If We want to fetch the elements in the same order as they were inserted then we should go with LinkedHashMap.

It accepts one null key and multiple null values.

It is not synchronized.

It has also 4 constructors same as HashMap

1) LinkedHashMap hm1 = new LinkedHashMap();
    will create a  LinkedHashMap with default capacity 16 and load factor 0.75

2) LinkedHashMap hm1 = new LinkedHashMap(iny initialCapacity);

3) LinkedHashMap hm1 = new LinkedHashMap(iny initialCapacity, float loadFactor);


4) LinkedHashMap hm1 = new LinkedHashMap(Map m);
-----------------------------------------------------------------------
import java.util.*;
public class LinkedHashMapDemo 
{
	public static void main(String[] args) 
	{
		LinkedHashMap<Integer,String> l = new LinkedHashMap<>();
		l.put(1,"abc");
		l.put(3,"xyz");
		l.put(2,"pqr");
		l.put(4,"def");
		l.put(null,"ghi");
		System.out.println(l);
	}
}
-----------------------------------------------------------------------
import java.util.*;

public class LinkedHashMapDemo1 
{
      public static void main(String[] a) 
      {
           Map<String,String> map = new LinkedHashMap<>();
           map.put("Ravi", "1234");
		   map.put("Rahul", "1234");
		   map.put("Aswin", "1456");
		   map.put("Samir", "1239");
           
		   map.forEach((k,v)->System.out.println(k+" : "+v));
      }
}
----------------------------------------------------------------------
Hashtable<K,V>
--------------
public class Hashtable<K,V> extends Dictionary<K,V> implements Map<K,V>, Clonable, Serializable

It is predefined class available in java.util package under Map interface from JDK 1.0.

Like Vector, Hashtable is also form the birth of java so called legacy class.

It is the sub class of Dictionary class which is an abstract class.

*The major difference between HashMap and Hashtable is, HashMap methods are not synchronized where as Hastable methods are synchronized. 

HashMap can accept one null key and multiple null values where as Hashtable does not contain anything as a null(key and value both). if we try to add null then JVM will throw an exception i.e NullPointerException.

The initial default capacity of Hashtable class is 11 where as loadFactor is 0.75.


It has also same constructor as we have in HashMap.(4 constructors)

1) Hashtable hs1 = new Hashtable();
    It will create the Hashtable Object with default capacity as 11 as well as load factor is 0.75

2) Hashtable hs2 = new Hashtable(int initialCapacity);
    will create the Hashtable  object with specified capacity


3) Hashtable hs3 = new Hashtable(int initialCapacity, float loadFactor);
    we can specify our own initialCapacity and loadFactor

4) Hashtable hs = new Hashtable(Map c);
    Interconversion of Map Collection
-----------------------------------------------------------------------
import java.util.*;  
public class HashtableDemo
	{  
	 public static void main(String args[])
		{  
		  Hashtable<Integer,String> map=new Hashtable<>(); 
		  map.put(1, "Java");
		  map.put(2, "is");
		  map.put(3, "best");		
		  map.put(4,"language");
		  
		  //map.put(5,null);  

		  System.out.println(map);

		  System.out.println(".......................");

		    for(Map.Entry m : map.entrySet())
			 {  
				 System.out.println(m.getKey()+" = "+m.getValue());  
			} 
        }  
}  
-----------------------------------------------------------------------
20-06-2024
-----------
WeakHashMap<K,v>


public class WeakHashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>

It is a predefined class in java.util package under Map interface.It was introduced from JDK 1.2v onwards.

While working with HashMap, keys of HashMap are of strong reference type. This means the entry of  map will not be deleted by the garbage collector even though the key is set to be null and  still object is not eligible for Garbage Collector.

On the other hand while working with WeakHashMap, keys of WeakHashMap are of weak reference type. This means the entry of a map is  deleted by the garbage collector if the key value is set to be null because it is of weak type.

So, HashMap dominates over Garbage Collector where as Garbage Collector dominates over WeakHashMap.

It contains 4 types of Constructor :
---------------------------------------
1) WeakHashMap wm1 = new WeakHashMap();
   
    Creates an empty WeakHashMap object with default capacity is 16 and load fator 0.75


2) WeakHashMap wm2 = new WeakHashMap(int initialCapacity);

3) WeakHashMap wm3 = new WeakHashMap(int initialCapacity, float loadFactor);

    Eg:- WeakHashMap wm = new WeakHashMap(10,0.9);

    capacity - The capacity of this map is 10. Meaning, it can store 10 entries.

    loadFactor - The load factor of this map is 0.9. This means whenever our hashtable is filled up by 90%, the entries are moved to a new hashtable of double the size of the original hashtable.

4) WeakHashMap wm4 = new WeakHashMap(Map m);
-----------------------------------------------------------------------
import java.util.*;
public class WeakHashMapDemo
{
	public static void main(String args[]) throws Exception
	{
	    WeakHashMap<Test,String> map = new WeakHashMap<>();

		Test  t  = new Test();
		map.put(t," Rahul "); 

		System.out.println(map); //{Test Nit = Rahul}
		
		t = null;
		
		System.gc();	
		
		Thread.sleep(5000); 
		
		System.out.println(map); //{}
	}
}

class Test
{
	@Override
	public String toString()
	{
		return "Test Nit";
	}
	
	@Override
	public void finalize() //called automaticaly if an object is eligible 4 GC
	{
		System.out.println("finalize method is called");
	}
}
-----------------------------------------------------------------------

public class CustomStringHashCode 
{
    public static int customHashCode(String str) //NIT
    {
        if (str == null) 
        {
            return 0; // defualt value for null is 0
        }

        int hashCode = 0;

        for (int i = 0; i < str.length(); i++) 
        {
            char charValue = str.charAt(i);
            hashCode = 31 * hashCode + charValue;
        }

        return hashCode;
    }

    public static void main(String[] args) 
    {
        String exampleString = "null";
        
        // Using the built-in hashCode method
        int builtInHashCode = exampleString.hashCode();
        System.out.println("Built-in hashCode: " + builtInHashCode);

        // Using the customHashCode method
        int customHashCode = customHashCode(exampleString);
        System.out.println("Custom hashCode: " + customHashCode);
    }
}
-----------------------------------------------------------------------
System generated hashcode for the Object :
-------------------------------------------
System class has provided a predefined static method identityHashCode(Object obj) through which we can find out system generated hashcode value.


public class HashCodeDemo {

	public static void main(String[] args) 
	{
		String str = "hyderabad";
		
		System.out.println(str.hashCode());
		
		System.out.println(System.identityHashCode(str));
	}

}
----------------------------------------------------------------------
IdentityHashMap :        
-----------------
public class IdentityHashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Clonable, Serializable.

It was introduced from JDK 1.4 onwards.

The IdentityHashMap uses == operator to compare keys.

As we know HashMap uses equals() and hashCode() method for comparing the keys based on the hashcode of the object it will serach the bucket location and insert the entry their only.

So We should use IdentityHashMap where we need to check the reference or memory address instead of logical equality.

HashMap uses hashCode of the "Object key" to find out the bucket loaction in Hashtable, on the other hand IdentityHashMap does not use hashCode() method actually It uses System.identityHashCode(Object o)

IdentityHashMap is more faster than HashMap in case of key Comparison.

It has three constrcutors, It does not contain loadFactor specific constructor.
----------------------------------------------------------------------
import java.util.*;
public class IdentityHashMapDemo 
{
	public static void main(String[] args) 
	{
		HashMap<String,Integer> hm = new HashMap<>();

		IdentityHashMap<String,Integer> ihm = new IdentityHashMap<>();
		
		hm.put("Ravi",23);
		hm.put(new String("Ravi"), 24);
		
		ihm.put("Ravi",23);
		ihm.put(new String("Ravi"), 27); //compares based on == operator
		
		System.out.println("HashMap size :"+hm.size());  
		System.out.println(hm);
		System.out.println("........................");
		System.out.println("IdentityHashMap size :"+ihm.size()); 
		System.out.println(ihm);

	}

}
-----------------------------------------------------------------------
Generics :
-----------
Why generic came into picture : 
------------------------------------
As we know our compiler is known for Strict type checking because java is a statically typed checked language.

The basic problem with collection is It can hold any kind of Object.

ArrayList al = new ArrayList();
al.add("Ravi");
al.add("Aswin");
al.add("Rahul");
al.add("Raj");
al.add("Samir");

for(int i =0; i<al.size(); i++)
{ 
   String s = (String) al.get(i);
   System.out.println(s);
}

By looking the above code it is clear that Collection stores everything in the form of Object so here even after adding String type only we need type casting as shown below.

import java.util.*;
class Test1 
{
	public static void main(String[] args) 
	{
		ArrayList al = new ArrayList(); //raw type
		al.add("Ravi");
		al.add("Ajay");
		al.add("Vijay");
							
		for(int i=0; i<al.size(); i++)
		{
		String name = (String) al.get(i); //type casting is required
		System.out.println(name.toUpperCase());
		}	
		

	}
}
----------------------------------------------------------------------
 Even after type casting there is no guarantee that the things which are coming from ArrayList Object is String only because we can add anything in the Collection as a result java.lang.ClassCastException as shown in the program below.


import java.util.*;
class Test2
{
	public static void main(String[] args) 
	{
		ArrayList t = new ArrayList(); //raw type
		t.add("alpha");
		t.add("beta");
		for (int i = 0; i < t.size(); i++) 
		{
		  String str =(String) t.get(i);
		  System.out.println(str);
		}

		 t.add(1234);
		 t.add(1256);
		  for (int i = 0; i < t.size(); ++i)
	       {	 
			 String obj= (String)t.get(i); //we can't perform type casting here
			 System.out.println(obj);
		  }
	}
}
-----------------------------------------------------------------------
To avoid all the above said problem Generics came into picture from JDK 1.5 onwards
 
 -> It deals with type safe Object so there is a guarantee of both the end i.e putting inside and getting out.
 
 Example:-
 ArrayList<String > al = new ArrayList<>();

 Now here we have a guarantee that only String can be inserted as well as only String will come out from the Collection so we can perform String related operation.

 Advantages :-
 ---------------
 a) Type safe Object (No compilation warning)

 b) Strict compile time checking (Type erasure)

 c) No need of type casting

import java.util.*;
public class Test3
{
public static void main(String[] args) 
{
		ArrayList<String> al = new ArrayList<>();  //Generic type
		al.add("Ravi");
		al.add("Ajay");
		al.add("Vijay");		
		
        for(int i=0; i<al.size(); i++)
		{
		String name = al.get(i); //no type casting is required
		System.out.println(name.toUpperCase());
		}
   }
}
-----------------------------------------------------------------------
//Program that describes the return type of any method can be type safe 
//[We can apply generics on method return type]

import java.util.*;
public class Test4
{
	public static void main(String [] args)
	{
		Dog d1 = new Dog();
		Dog d2 = d1.getDogList().get(0);
		System.out.println(d2);
	}
}
class Dog
{
	public List<Dog> getDogList()
	{
		ArrayList<Dog> d = new ArrayList<>();
        d.add(new Dog());
		d.add(new Dog());
		d.add(new Dog());
		return d;
	}
}

Note :- In the above program the compiler will stop us from returning anything which is not compaitable List<Dog> and there is a guarantee that only "type safe list of Dog object" will be returned so we need not to provide type casting as shown below
Dog d2 = (Dog) d1.getDogList().get(0);  //before generic.
-----------------------------------------------------------------------
Mixing Generic with Non-Generic :

//Mixing generic with non-generic
import java.util.*;

class Car
{
}
public class Test5
{
	public static void main(String [] args) 
	{
	ArrayList<Car> a = new ArrayList<>();
	a.add(new Car());
	a.add(new Car());
    a.add(new Car());

	ArrayList b = a;  //assigning Generic to raw type 	          
	

    System.out.println(b);   
	}
}
-----------------------------------------------------------------------
//Mixing generic to non-generic
import java.util.*; 
public class Test6 
{
	public static void main(String[] args) 
	{ 
		List<Integer> myList = new ArrayList<>(); 
		myList.add(4); 
		myList.add(6); 
		myList.add(5);
        
		UnknownClass u = new UnknownClass(); 
		int total = u.addValues(myList); 
		System.out.println("The sum of Integer Object is :"+total); 
	} 
}  
class UnknownClass 
{ 
	public int addValues(List list)  //generic to raw type OR 
	{ 
	Iterator it = list.iterator();    
	int total = 0; 
	while (it.hasNext()) 
	{
		int i = ((Integer)it.next());
		total += i;                           //total = 15
	} 
	return total; 
	} 
} 

Note :-
In the above program the compiler will not generate any warning message because even though we are assigning type safe Integer Object to unsafe or raw type List Object but this List Object is not inserting anything new in the collection so there is no risk to the caller.
-----------------------------------------------------------------------
//Mixing generic to non-generic
import java.util.*; 
public class Test7 
{
	public static void main(String[] args) 
	{ 
		List<Integer> myList = new ArrayList<>(); 

		myList.add(4); 
		myList.add(6); 
		UnknownClass u = new UnknownClass(); 
		int total = u.addValues(myList); 
		System.out.println(total); 
	} 
}  
class UnknownClass 
{ 
    public int addValues(List list)  
	{ 
		list.add(5);	//adding object to raw type
		Iterator it = list.iterator(); 
		int total = 0; 
		while (it.hasNext()) 
		{
		int i = ((Integer)it.next()); 
		total += i; 
		} 
		return total; 
	} 
} 
Here Compiler will generate warning message because the unsafe object is inserting the value 5 to safe object.
----------------------------------------------------------------
*Type Erasure
------------
In the above program the compiler will  generate  warning message because the unsafe List Object is inserting the Integer object 5 so the type safe Integer object is getting value 5 from unsafe type so there is a problem to the caller method.

By writing ArrayList<Integer> actually JVM does not have any idea that our ArrayList was suppose to hold only Integers. 

All the type safe generics information does not exist at runtime. All our generic code is Strictly for compiler. 

There is a process done by java compiler called "Type erasure" in which the java compiler converts generic version to non-generic type.

List<Integer> myList = new ArrayList<Integer>();

At the compilation time it is fine but at runtime for JVM the code becomes

List myList = new ArrayList();

Note :- GENERIC IS STRICTLY A COMPILE TIME PROTECTION.
----------------------------------------------------------------------
Behavior of Polymorphism with Array and Generics :
--------------------------------------------------
//Polymorphism with array

import java.util.*;
abstract class Animal
{
	public abstract void checkup();
}

class Dog extends Animal
{
	@Override
	public void checkup()
	{
		System.out.println("Dog checkup");
	}
}

class Cat extends Animal
{
	@Override
	public void checkup()
	{
		System.out.println("Cat checkup");
	}
}

class Bird extends Animal
{
	@Override
	public void checkup()
	{
		System.out.println("Bird checkup");
	}
}

public class  Test8
{
	public void checkAnimals(Animal animals[])  
	{
		for(Animal animal : animals)
		{
			animal.checkup();
		}
	}

	public static void main(String[] args) 
	{
		Dog []dogs={new Dog(), new Dog()};

		Cat []cats={new Cat(), new Cat(), new Cat()};

		Bird []birds = {new Bird(), new Bird()};

		Test8 t = new Test8();

		t.checkAnimals(dogs);
		t.checkAnimals(cats);
		t.checkAnimals(birds);
	}
}

Note :-From the above program it is clear that polymorphism(Upcasting) concept works with array.
----------------------------------------------------------------
import java.util.*;
abstract class Animal
{
	public abstract void checkup();
}

class Dog extends Animal
{
    @Override
	public void checkup()
	{
		System.out.println("Dog checkup");
	}
}

class Cat extends Animal
{
	@Override
	public void checkup()
	{
		System.out.println("Cat checkup");
	}
}
class Bird extends Animal
{
	@Override
	public void checkup()
	{
		System.out.println("Bird checkup");
	}
}
public class Test9
{
	public void checkAnimals(List<Animal> animals)  
	{
		for(Animal animal : animals)
		{
             animal.checkup();
		}
	}
	public static void main(String[] args) 
	{
		List<Dog> dogs = new ArrayList<>();
		dogs.add(new Dog());
		dogs.add(new Dog());

		List<Cat> cats = new ArrayList<>();
		cats.add(new Cat());
		cats.add(new Cat());

		List<Bird> birds = new ArrayList<>();
		birds.add(new Bird());
		
		Test9 t = new Test9();
		t.checkAnimals(dogs);
		t.checkAnimals(cats);
		t.checkAnimals(birds);

	}
}



Note :- The above program will generate the compilation error.

So from the above program it is clear that polymorphism does not work in the same way for generics as it does with arrays.

Eg:-

Parent [] arr = new Child[5]; //valid
Object [] arr = new String[5]; //valid

But in generics the same type is not valid

List<Object> list = new ArrayList<Integer>(); //Invalid
List<Parent> mylist = new ArrayList<Child>(); //Invalid
----------------------------------------------------------------------
import java.util.*;
public class Test10
{
public static void main(String [] args)
	{	
	   //ArrayList<Number> al = new ArrayList<Integer>(); [Compile time]
	   //ArrayList al = new ArrayList();  [Runtime, Type Erasure]
	   //al.add("Ravi");
	     

		Object []obj = new String[3]; //valid with Array
		obj[0] = "Ravi";
		obj[1] = "hyd";
		obj[2] =  90; //java.lang.ArrayStoreException
		System.out.println(Arrays.toString(obj));
	}
}

Note : While working with Array, at runtime if we try to insert any 
       Illegal data then JVM will throw an exception i.e java.lang.ArrayStoreException but while working with generics 
       same type of Exception OR for same exception any other type 
       of Exception support is not provided by hava due to type 
       erasure so, Generic is a strict compile time protection.
-----------------------------------------------------------------------
Wild card character(?) :
------------------------
<?>			-: Many possibilities

<Animal>		-: Only <Animal> can assign, but not Dog                             or sub type of animal

<? super Dog>	-: Dog, Animal, Object can assign (Compiler has                      surity)

<? extends Animal> -: Below of Animal(Child of Animal) means, sub classes of Animal (But the compiler does not have surity because you can have many sub classes of Animal in the future, so chances of wrong collections)
---------------------------------------------------------------------
//program on wild-card chracter
import java.util.*;
class Parent
{

}
class Child extends Parent
{
}
public class Test12
{
public static void main(String [] args)
	{	
		List<?> lp = new ArrayList<Parent>(); 
		System.out.println("Wild card....");
	}
}
-----------------------------------------------------------------------
import java.util.*;
public class Test13 
{
	public static void main(String[] args) 
	{
		List<? extends Number> list1 = new ArrayList<Long>();

		List<? super String> list2 = new ArrayList<Object>();

		List<? super Beta> list3 = new ArrayList<Alpha>();

		List list4 = new ArrayList();
		
		System.out.println("yes");
	}
}

class Alpha
{
}
class Beta extends Alpha
{
}
class Gamma extends Alpha
{
}
----------------------------------------------------------------------
class Test<R,A>
{
	private R r;
	public void set(A a) 
	{
		r = a; //error [both are not compaitable]
	}
	
	public R get() 
	{
		return r;
	}
}
public class Test14 
{
   public static void main(String[] args) 
   {
      Test<String,String> test = new Test(); 
      test.set("Info");
      System.out.println(test.get());
   }
}
-----------------------------------------------------------------------
class MyClass<T>     
{
	T obj;
	public MyClass(T obj)       //obj = new Student(
	{
		this.obj=obj;
	}

	T getObj()
	{
		return obj;
	}
}
public class Test15
{
	public static void main(String[] args) 
	{
		Integer i=12;
		MyClass<Integer> mi = new MyClass<>(i);
		System.out.println("Integer object stored :"+mi.getObj());

		Float f=12.34f;
		MyClass<Float> mf = new MyClass<>(f);
		System.out.println("Float object stored :"+mf.getObj());

		MyClass<String> ms = new MyClass<>("Rahul");
		System.out.println("String object stored :"+ms.getObj());

		MyClass<Boolean> mb = new MyClass<>(false);
		System.out.println("Boolean object stored :"+mb.getObj());

		Double d=99.34;
		MyClass<Double> md = new MyClass<>(d);
		System.out.println("Double object stored :"+md.getObj());

		MyClass<Student> std = new MyClass<>(new Student(1,"A"));
		System.out.println("Student object stored :"+std.getObj());
	}
}

record Student(int id, String name)
{

}
-----------------------------------------------------------------------
//E stands for Element type
class Fruit    
{
}
class Apple extends Fruit   //Fruit is super, Apple is sub class
{
	@Override
	public String toString()
	{
		return "Apple";
	}
}

class Basket<E>   // E is fruit type 
{
	private E element;  	
	public void setElement(E element) //Fruit element = new Mango();
	{
		this.element = element;
	}	

	public E getElement() // public Fruit getElement{}
	{
		return this.element;		
	}
}

public class Test16
{
	public static void main(String[] args) 
	{
		Basket<Fruit> b = new Basket<>();
		b.setElement(new Apple());

		Apple x = (Apple) b.getElement();	
		System.out.println(x);

       
        Basket<Fruit> b1 = new Basket<>();
		b1.setElement(new Mango());
		Mango y = (Mango)b1.getElement();	
		System.out.println(y);
		
	}
}
class Mango extends Fruit
{
	@Override
	public String toString()
	{
		return "Mango";
	}
}
----------------------------------------------------------------------
Stream API :
------------
Streams in java :
------------------
It is introduced from Java 8 onwards, the Stream API is used to process the collection objects.

It contains classes for processing sequence of elements over Collection object and array.

Stream is a predefined interface available in java.util.stream sub package.

Package Information :
---------------------
java.util -> Base package
java.util.function -> Functional interfaces
java.util.concurrent -> Multithreaded support
java.util.stream -> Processing of Collection Object

forEach() method in java :
-----------------------------
The Java forEach() method is a  technique to iterate over a collection such as (list, set or map) and stream. It is used to perform a given action on each of the element of the collection.

The forEach() method has been added in following places:

Iterable interface   This makes Iterable.forEach() method available to all collection classes. Iterable interface is the super interface of Collection interface

Map interface   This makes forEach() operation available to all map classes.

Stream interface   This makes forEach() operations available to all types of stream.
-----------------------------------------------------------------
Creation of Streams to process the data :
-----------------------------------------------
We can create Stream from  collection or array with the help of stream() and of() methods:

A stream()  method is added to the Collection interface and allows creating a Stream<T> using any collection object as a source

public java.util.Stream<E> stream();

The return type of this method is Stream interafce available in java.util.stream sub package.

Eg:-
List<String> items = new ArrayList<String>();
		items.add("Apple");
		items.add("Orange");
		items.add("Mango");
		Stream<String> stream = items.stream();
----------------------------------------------------------------------
package com.ravi.basic;
import java.util.*;  //Base package
import java.util.stream.*; //Sub package
public class StreamDemo1 
{
	public static void main(String[] args) 
	{
		List<String> items = new ArrayList<>();

		items.add("Apple");
		items.add("Orange");
		items.add("Mango");

        //Collections Object to Stream
		Stream<String> strm = items.stream();
		strm.forEach(p -> System.out.println(p));
	}
}
-----------------------------------------------------------------------
Stream.of()       
--------------
public static java.util.stream.Stream  of(T ...x)
-----------------------------------------------------
It is a static method of Stream interface through which we can create Stream of arrays and Stream of Collection. The return type of this method is Stream interface

//Stream.of()
package com.ravi.basic;
import java.util.stream.*;
public class StreamDemo2 
{
	public static void main(String[] args) 
	{
		//Stream of Collection
		Stream<Integer> stream = Stream.of(1,2,3,4,5,6,7,8,9);
		stream.forEach(p -> System.out.println(p));

		System.out.println("...............................");

         //Anonymous Array Object (Stream of Arrays)
		Stream<Integer> strm = Stream.of( new Integer[]{15,29,45,8,16} );
		strm.forEach(p -> System.out.println(p));
	}
}
----------------------------------------------------------------------

Intermediate Operations:
------------------------
filter(Predicate<T> predicate): Returns a new stream which contains filtered elements based on the boolean expression using Predicate.

map(Function<T, R> mapper): Transforms elements in the stream using the provided mapping function.  

flatMap(Function<T, Stream<R>> mapper): Flattens a stream of streams into a single stream. 

distinct(): Returns a stream with distinct elements (based on their equals method).

sorted(): Returns a stream with elements sorted in their natural order.

sorted(Comparator<T> comparator): Returns a stream with elements sorted using the specified comparator.

peek(Consumer<T> action): Allows us to perform an action on each element in the stream without modifying the stream.

limit(long maxSize): Limits the number of elements in the stream to a specified maximum size.

skip(long n): Skips the first n elements in the stream.

takeWhile(Predicate<T> predicate): Returns a stream of elements from the beginning until the first element that does not satisfy the predicate.

dropWhile(Predicate<T> predicate): Returns a stream of elements after skipping elements at the beginning that satisfy the predicate.
----------------------------------------------------------------------
public abstract Stream<T> filter(Predicate<T> p) : 
----------------------------------------------------
It is a predfined method of Stream interface. It is used to select/filter elements as per the Predicate passed as an argument. It is basically used to filter the elements based on boolean condition.

public abstract <T>  collect(java.util.stream.Collectors c)
----------------------------------------------------------------
It is a predfined method of Stream interface. It is used to return the result of the intermediate operations performed on the stream.

It is a terminal operation. It is used to collect the data after filteration and convert the data to the Collection(List/Set).

Collectors is a predfined final class available in java.util.stream sub package which conatins a static method toList() and toSet() to convert the data as a List/Set i.e Collection object. The return type of this method is List/Set interface.

//Filter all the even numbers from Collection 
package com.ravi.basic;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

public class StreamDemo3 
{
	public static void main(String[] args) 
	{
        List<Integer> numbers = Arrays.asList(1,2,3,4,5,6,7,8,9,10,11,12,3,7,2,8,12);
        
        ArrayList<Integer> evenNumbers = new ArrayList<>();
        
        //Retrieving all the even number from the List 
        
        for(Integer i : numbers)
        {
        	if(i%2==0)
        		evenNumbers.add(i);
        		
        }
        System.out.println("Printing even numbers without Stream");
        evenNumbers.forEach(System.out::println);
        
               
        //Retrieving all the even number from the List 
        
        System.out.println("Printing even numbers with Stream");
          numbers.stream().filter(num -> num %2==0).forEach(System.out::println);
        
         //Retrieving all the even number using Stream and convert it into List so duplicates are allowed
          
          System.out.println("Printing Even number using List");
          List<Integer> listOfNumbers = numbers.stream().filter(num-> num%2==0).collect(Collectors.toList());
          listOfNumbers.forEach(System.out::println);
          
          
          System.out.println("Printing Odd number using Set");
          Set<Integer> collect = numbers.stream().filter(num-> num%2==1).collect(Collectors.toSet());
          collect.forEach(System.out::println);
        
	}
}
-----------------------------------------------------------------------
22-06-2024
-----------
public Stream sorted() :
------------------------
It is a predefined method of Stream interface.
It provides default natural sorting order.
The return type of this methof is Stream.

public Stream distinct() : It will remove duplicate elements.

//Filtering the name
package com.ravi.basic;
import java.util.*;
import java.util.stream.*;
public class StreamDemo4 
{
	public static void main(String[] args) 
	{
		List<String> list = Arrays.asList("Ravi", "Rahul", "Akshar", "Roshan","Raj","Ankit","Ravi");		

		list.stream().sorted().distinct().forEach(System.out::println);
		
		 
		
    
	}
}
-----------------------------------------------------------------------
//Sorting the data
package com.ravi.basic;
import java.util.*;
import java.util.stream.*;
public class StreamDemo5 
{
	public static void main(String[] args) 
	{
	List<String> names = Arrays.asList("Zaheer","Rahul","Aryan","Sailesh");

		List<String> sortedName =
            names.stream().sorted((s1,s2)->s2.compareTo(s1)).collect(Collectors.toList());
		
        System.out.println(sortedName);
	}
}
-----------------------------------------------------------------------
package com.ravi.basic;

import java.util.ArrayList;

record Customer(Integer custId, String custName, Double custBill)
{	
}


public class StreamDemo6
{
	public static void main(String[] args) 
	{
		ArrayList<Customer> al = new ArrayList<>();
		al.add(new Customer(1, "Raj", 32000D));
		al.add(new Customer(2, "Smith", 34000D));
		al.add(new Customer(3, "Scott", 29000D));
		al.add(new Customer(4, "Ravi",  35000D));
		al.add(new Customer(5, "Samir", 39000D));
		
		//Retrieve all the customer name whose bill is > 30000
		
		al.stream().filter(cust -> cust.custBill()>30000).forEach(c -> System.out.println(c.custName()));	
		
		
	}
}
-----------------------------------------------------------------------
public Stream map(Function<T,R> mapper) :
-------------------------------------------------
It is a predefined method of Stream interface.

It takes Function (Predefined functional interafce ) as a parameter.

It performs intermediate operation and consumes single element from input Stream and produces single element to output Stream. (1:1 transformation)

Here mapper function is functional interface which takes one input and provides one output.
------------------------------------------------------------------
package com.ravi.basic;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;
 
public class StreamDemo7 
{
    public static void main(String[] args) 
    {
    	//add value 10 to each and every number
    	List<Integer> asList = Arrays.asList(1,2,3,4,5,6,7,8,9);
    	asList.stream().map(num -> num + 10).forEach(System.out::println);
    	
    	System.out.println("............................");
    	
    	//Find even numbers in stream and collect the cubes
    	List<Integer> numbers =  List.of(1,2,3,4,5,6,7,8,9,10);
    	
    	numbers.stream().filter(num -> num%2==0).map(n-> n*n*n).forEach(System.out::println);
    	
    	System.out.println("...................");
    	//Find the length of the name
    	Stream.of("Raj","Scott","subramanyam","Rahul").map(str-> str.length()).forEach(System.out::println);     
        
    }
}
-----------------------------------------------------------------------
//Program on map(Function<T,R> mapped)
package com.ravi.basic;
import java.util.*;
import java.util.stream.*;
public class StreamDemo8
{ 
	public static void main(String args[])
	{
		List<Player> players = createMyPlayerList();
		
		//Journey from Player object to name of the player
		Set<String> playerName = players.stream().map(p1 -> p1.name()).collect(Collectors.toSet());
		playerName.forEach(System.out::println);
	}		
	
	public static List<Player> createMyPlayerList()
	{
		List<Player> listOfPlayers = new ArrayList<>();
		listOfPlayers.add(new Player("Virat",32));
		listOfPlayers.add(new Player("Rohit",33));
		listOfPlayers.add(new Player("Shami",34));
		listOfPlayers.add(new Player("Siraj",28));
		listOfPlayers.add(new Player("Sarfaraj",26));
		listOfPlayers.add(new Player("Virat",32));
		
		return listOfPlayers;
	}
}
 
record Player(String name, int age)
{
	
}
----------------------------------------------------------------------
It is a predefined method of Stream interface.

The map() method produces one output value for each input value in the stream. So if there are n elements in the stream, map() operation will produce a stream of n output elements.

flatMap() is two step process i.e. map() + Flattening. It helps in converting Collection<Collection<T>> to Collection<T> [to make flat i.e converting Collections of collection into single collection or merging of all the collection]

//flatMap()
//map + Flattening [Converting Collections of collection into single collection]
package com.ravi.basic;
import java.util.*;
import java.util.stream.*;
public class StreamDemo9  
{
	public static void main(String[] args) 
	{
		List<String> list1 = Arrays.asList("A","B","C");
		List<String> list2 = Arrays.asList("D","E","F");
		List<String> list3 = Arrays.asList("G","H","I");
		 
		List<List<String>> listOfLists = Arrays.asList(list1, list2, list3);
		
		
		System.out.println(listOfLists); 
		System.out.println("...............");
        //Using flatMap() to convert Collections of collection into single collection
		
		List<String> collect = listOfLists.stream().flatMap(list -> list.stream()).collect(Collectors.toList());
		
		System.out.println(collect);
		
		
	}
}
----------------------------------------------------------------------
//Flattening of prime, even and odd number
package com.ravi.basic.flat_map;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class FlatMapDemo1 
{
	public static void main(String[] args)
	{
      List<Integer> primeNumbers = Arrays.asList(5,7,11);
      List<Integer> evenNumbers = Arrays.asList(2,4,6);
      List<Integer> oddNumbers = Arrays.asList(1,3,5);
      
      List<List<Integer>> listOfCollection = Arrays.asList(primeNumbers, evenNumbers, oddNumbers);
      System.out.println(listOfCollection);
      
      List<Integer> collect = listOfCollection.stream().flatMap(num -> num.stream()).collect(Collectors.toList());
      
  System.out.println(collect);
      
	
	
	}

}
-----------------------------------------------------------------------
//Fetching first character using flatMap()
package com.ravi.basic.flat_map;

import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class FlatMapDemo2 
{
	public static void main(String[] args)
	{
		List<String> asList = Arrays.asList("Jyoti","Ankit","Vaibhab","Aman");
		
		asList.stream().flatMap(str -> Stream.of(str.charAt(0))).forEach(System.out::print);
		
		
		
		
	}

}
----------------------------------------------------------------------
package com.ravi.basic.flat_map;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

class Product 
{
	private Integer productId;
	private List<String> listOfProducts;

	public Product(Integer productId, List<String> listOfProducts)       
	{
		super();
		this.productId = productId;
		this.listOfProducts = listOfProducts;

	}

	public Integer getProductId() {
		return productId;
	}

	public List<String> getListOfProducts() {
		return listOfProducts;
	}
}

public class FlatMapDemo3 
{
	public static void main(String[] args) 
	{

		List<Product> listOfProduct = Arrays.asList(
	new Product(1, Arrays.asList("Camera", "Mobile", "Laptop")),
	new Product(2, Arrays.asList("Bat", "Ball", "Wicket")),
	new Product(3, Arrays.asList("Chair", "Table", "Lamp")),
	new Product(4, Arrays.asList("Cycle", "Bike", "Car"))

		);

		List<String> collect = listOfProduct.stream().flatMap(p -> p.getListOfProducts().stream())
				.collect(Collectors.toList());
		System.out.println(collect);

	}

}
-----------------------------------------------------------------------
**Difference between map() and flatMap()
--------------------------------------
map() method transforms each element into another single element.

flatMap() transforms each element into a stream of elements and then flattens those streams into a single stream.

We should use map() when you want a one-to-one transformation, and  we should use flatMap() when dealing with nested structures or when you need to produce multiple output elements for each input element.
--------------------------------------------------------------
package com.ravi.basic;
import java.util.stream.Stream;
public class StreamDemo10
{
	public static void main(String[] args)
		{
		Stream<String> s = Stream.of("Virat", "Rohit", "Dhoni", "Virat", "Rohit","Aswin","Bumrah");
		s.distinct().sorted((s1,s2)-> s2.compareTo(s1)).forEach(System.out::println);	
		
	}

}
-----------------------------------------------------------------------
public Stream<T> limit(long maxSize) :
----------------------------------------
It is a predefined method of Stream interface to work with sequence of elements.

The limit() method is used to limit the number of elements in a stream by providing maximum size.

It creates a new Stream by taking the data from original Stream.

Elements which are not in the range or beyond the range of specified limit will be ignored.
---------------------------------------------------------------
package com.ravi.basic;
import java.util.stream.Stream; 
public class StreamDemo11 
{
	public static void main(String[] args) 
	{
		Stream<Integer> numbers = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

		Stream<Integer> limitedStream = numbers.limit(2);

		limitedStream.forEach(System.out::println);
	}
}
----------------------------------------------------------------------
public Stream<T> skip(long n) :
-------------------------------
It is a predefined method of Stream interface which is used to skip the elements from begning of the Stream.

It returns a new stream that contains the remaining elements after skipping the specified number of elements which is passed as a parameter.

package com.ravi.basic;
import java.util.stream.Stream; 
public class StreamDemo12 
{
	public static void main(String[] args) 
	{
		Stream<String> s = Stream.of("Virat", "Rohit", "Dhoni", "Zaheer", "Raina","Sahwag","Sachin","Bumrah");
		s.skip(3).limit(5).forEach(System.out::println);
	}
}
-----------------------------------------------------------------------
public Stream<T> peek(Consumer<? super T> action) :
--------------------------------------------
It is a predefined method of Stream interface which is used to perform a side-effect operation on each element in the stream while the stream remains unchanged.

It is an intermediate operation that allows us to perform operation on each element of Stream without modifying original.

The peek() method takes a Consumer as an argument, and this function is applied to each element in the stream. The method returns a new stream with the same elements as the original stream.
---------------------------------------------------------------
package com.ravi.basic;

import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class StreamDemo13 
{
	public static void main(String[] args) 
	{
		Stream<String> numbers = Stream.of("Apple","Mango","Grapes","Kiwi","pomogranate");

		List<Integer> doubledNumbers = numbers
		    .peek(str -> System.out.println("Peeking from Original: " + str.toUpperCase()))
		    .map(fruit -> fruit.length())
		    .collect(Collectors.toList());
		System.out.println("-----------------");
		System.out.println(doubledNumbers);
		
	}

}

Note :- peek(Consumer<T> cons) will not modify the Original Source.
---------------------------------------------------------------------
public Stream<T> takeWhile(Predicate<T> predicate) : 
-----------------------------------------------------
It is a predefined method of Stream interface introduced from java 9 which is used to perform a side-effect operation on each element in the stream while the stream remains unchanged.

*It is used to create a new stream that includes elements from the original stream only as long as they satisfy a given predicate.

package com.ravi.basic;

import java.util.stream.Stream;

public class StreamDemo14 
{
 public static void main(String[] args) 
 {
	 Stream<Integer> numbers = Stream.of(10,11,9,13,2,1,100);

     numbers.takeWhile(n -> n > 9).forEach(System.out::println);     

     System.out.println(".......................");
    
     numbers = Stream.of(12,2,3,4,5,6,7,8,9);
     
     numbers.takeWhile(n -> n%2==0).forEach(System.out::println);
     
    
     System.out.println(".......................");
     
     numbers = Stream.of(1,2,3,4,5,6,7,8,9);
     
     numbers.takeWhile(n -> n < 9).forEach(System.out::println);
     
     System.out.println(".......................");
    
     numbers = Stream.of(11,2,3,4,5,6,7,8,9); 
     
     numbers.takeWhile(n -> n > 9).forEach(System.out::println);
    
     System.out.println(".............................");
     
     Stream<String> stream = Stream.of("Ravi", "Ankit", "Rohan", "Aman", "Ravish"); 

     stream.takeWhile(str -> str.charAt(0)=='R').forEach(System.out::println); 
     
    
     
	 
 }
}
----------------------------------------------------------------------
public Stream<T> dropWhile(Predicate<T> predicate) :
----------------------------------------------------
It is a predefined method of Stream interface introduced from java 9 which is used to create a new stream by excluding elements from the original stream as long as they satisfy a given predicate.

package com.ravi.basic;

import java.util.stream.Stream;

public class StreamDemo15 {

	public static void main(String[] args) 
	{
		Stream<Integer> numbers = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

		numbers.dropWhile(num -> num < 5).forEach(System.out::println);
		
		System.out.println("..................................");
		
		numbers = Stream.of(15, 8, 7, 9, 5, 6, 7, 8, 9, 10);

		numbers.dropWhile(num -> num > 5).forEach(System.out::println);       
		
	}

}








































































































































































































































