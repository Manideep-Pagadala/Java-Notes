
11-DEC-23
javaravishanker@gmail.com

What is a language?
-------------------
A language is a communication media through which we can communicate with
each other.

What is a programming language?
--------------------------------
A Programming language is an intermediate between the user and computer System.

Every language contains two important aspects :
      1) Syntax (Rules given by the language)
      2) Semantics (Meaning OR Structure of the language)

In English language, if we want to make a translation then the syntax is :

Subject + verb + Object
She  is   a   girl. [Valid]
She  is   a   box.  [Invalid but still I am following the syntax]

In our programming language also :

int x = 12;
int y = 0;
int z = x /y;

In Java programming language we have 2 types of Security :

1) At Compilation level : Here our java compiler will verify whether the 
   code is valid or not according to the syntax.

2) At Runtime Level : Here our runtime environment will verify the semantics of the code that means the code is meaningful or not?
-------------------------------------------------------------------------
Statically(Strongly) typed language :-
---------------------------------------
The languages where data type is compulsory before initialization of a variable are called statically typed language.
In these languages we can hold same kind of value during the execution of the program.

Ex:- C,C++,Core Java, C#

Dynamically(Looesly) typed language :-
-------------------------------------------
The languages where data type is not compulsory and it is optional before initialization of a variable then it is called dynamically typed language.

In these languages we can hold different kind of value during the execution of the program.
Ex:- Visual Basic, Javascript, Python
---------------------------------------------------------------
What is a function :-
-----------------------
A function is a self defined block for any general purpose, calculation or printing some data.

The major benefits with function are :-
-------------------------------------------
1) Modularity :- Dividing the bigger modules into number of smaller modules where each module will perform its independent task.

2) Easy understanding :- Once we divide the bigger task into number of smaller tasks then it is easy to understand the entire code.

3) Reusability :- We can reuse a particular module so many number of times so It enhances the reusability nature.

Note :- In java we always reuse our classes.

4) Easy Debugging :- Debugging means finding the errors, With function It is easy to find out the errors because each module is independent with another module. 

Why we pass parameter to a function :-
--------------------------------------------
We pass parameter to a function for providing more information regrading the function.

Eg:-

userdefined function                  predefined function
public void switchOn(int a)            switchOn(3); // The fan is running in mode 3
{
  //start the fan
}

-----------------------------------------------------------------
Why member functions are called method in java ?
--------------------------------------------------
variable -> fields
function -> methods

Why functions are called method in java?
----------------------------------------------
In C++ there is a facility to write a function inside the class as well as outside of the class by using :: (Scope resolution Operator), But in java all the functions must be declared inside the class only.

That is the reason member functions are called method in java.

Variable -->  Field
function ---> Method
----------------------------------------------------------------
History of java :
----------------
First Name of Java : OAK (In the year 1991 which is a tree name)

Project Name :- Green Project 

Inventor of Java : - James Gosling and his friends

Official Symbol :- Coffee CUP

Java :- Island (Indonesia)
-----------------------------------------------------------------
Why java become so popular in the IT Industry ?
-----------------------------------------------------
The role of Java compiler :
-------------------------
a) Compiler are used to check the syntax.
b) It also check the compatibility issues(LHS = RHS)
c) It converts the source code into machine code.


Java code :
-------------
a) Java programs must be saved having extension .java

b) java compiler(javac) is used to compile our code.

c) After successful compilation we are getting .class file (bytecode)

d) This .class file we submit to JVM for execution prupose (for executing my java code)

JVM :- It stands for Java Virtual Machine. It is a software in the form of interpreter  written in 'C' language.

Every browser contains JVM, Those browsers are known as JEB (Java Enabled Browsers) browsers.
------------------------------------------------------------------

C and C++ programs are platform dependent programs that means the .exe file created on one machine will not be executed on the another machine if the system configuration is different.

That is the reason C and C++ programs are not suitable for website development.

Where as on the other hand java is a platform independent language. Whenever we write a java program, the extension of java program must be .java. 

Now this .java file we submit to java compiler (javac) for compilation process. After successful compilation the compiler will generate a very special machine code file i.e .class file (also known as bytecode). Now this .class file we submit to JVM for execution purpose.

The role of JVM is to load and execute the .class file. Here JVM plays a major role because It converts the .class file into appropriate machine code instruction (Operating System format) so java becomes platform independent language and it is highly suitable for website development.

Note :- We have different JVM for different Operating System that means JVM is platform dependent technology where as Java is platform Independent technology.
-----------------------------------------------------------------
What is the difference between the bit code and byte code.
----------------------------------------------------------
Bit code is directly understood by Operating System but on the other hand byte code is understood by JVM, JVM is going to convert this byte code into machine understandable format.
---------------------------------------------------------------
Comments in JAVA :-
------------------------
Comments are used to enhance the readability of the program. It is ignored by the compiler.
In java we have 3 types of comments 

1) Single line Comment (//)

2) Multiline Comment (/* ------------------------------- */)

3) Documentation Comment (/** -------------------------- */)

/**
Name of the Project : Online Shopping
Date created :- 12-12-2021
Last Modified - 16-01-2022
Author :- Ravishankar
Modules : -  10 Modules
*/
---------------------------------------------------------------
WAP in java to display welcome message :
------------------------------------------------
At initial level we can write a java program with the help class and methods.

Syntax for a class 
--------------------
[Access Modifier]  class [Name of the class]
{
            
}

Example :- 
public class Test
{
}

Syntax for a method :
-------------------------
[Access modifier] [return type] [Name of the method] ()
{


}
Example :-
public  void accept()
{
}
--------------------------------------------------------------------------------------
Note :- 
1) In java whenever we write a program we need at least a main method.

2) In java the execution of the program always starts and ends with main method.

----------------------------------------------------------------
Description of main() method :
-----------------------------------
public :-
--------
public is an access modifier in java. The main method must be declared as public otherwise JVM cannot execute our main method or in other words JVM can't enter inside the main method for execution of the program.

If main method is not declared as public then program will compile but it will not be executed by JVM.

Note :- From java compiler point of view there is no rule to declare our methods as public.
----------------------------------------------------------------
static :-
--------
In java our main method is static so we need not to create an object to call the main method.

If a method is declared as a static then we need not to create an object to call that method. We can directly call the static methods with the help of class name (Object is not required).

If we don't declare the main method as static method then our program will compile but it will not be executed by JVM.
------------------------------------------------------------------
void :-
-------
It is a keyword. It means no return type. Whenever we define any method in java and if we don't want to return any kind of value from that particular method then we should write void before the name of the method.

Eg:

public void input()                        public int accept()
{                                           {
}                                               return 15;
					    }

Note :- In the main method if we don't write void or any other kind of return type then it will generate a compilation error.

In java whenever we define a method then compulsory we should define return type of method.(Syntax rule)
----------------------------------------------------------------
main() :-
----------
It is a user-defined method because a user is responsible to define some logic inside the main method.

main() method is very important method because every program execution will start from main() method only, as well as the execution of the program ends with main() method only.

We can write multiple main methods in our class but argument must be different.
----------------------------------------------------------------
Command Line Argument (Introduction only) :-
-------------------------------------------
Whenever we pass an argument/parameter to the main method then it is called Command Line Argument.

The argument inside the main method is String because String is a alpha-numeric collection of character so, It can accept numbers,decimals, characters, combination of number and character.

That is the reason java software people has provided String as a parameter inside the main method.(More Wider scope to accept the value)
--------------------------------------------------------------
System.out.println() :-
-------------------------
It is an output statement in java, By using System.out.println() statement we can print anything on the console.

In System.out.println(), System is a predefined class available in java.lang package, out is a final, static reference variable of PrintStream class available in java.io package and println() is a predfined method available in PrintStream class.

In System.out, .(dot) is a member access operator. It is called as period. It is used to access the member of the class.
--------------------------------------------------------------
WAP in java to add two numbers :
--------------------------------
Addition.java
-------------
public class Addition 
{
	public static void main(String[] args) 
	{
		int val1 = 100;
		int val2 = 200;
		int result = val1 + val2;
		System.out.println(result);
	}
}

In this program we are getting the result but it is not 
user-friendly, to provide user-friendly message we should re-write the program

public class AdditionWithMessage 
{
	public static void main(String[] args) 
	{
		int val1 = 100;
		int val2 = 200;
		int result = val1 + val2;
		System.out.println("Sum is :" + result);
	}
}
---------------------------------------------------------------
//WAP to add two numbers without 3rd variable

public class AdditionWithout3rdVariable 
{
	public static void main(String[] args) 
	{
		int x = 12;
		int y = 15;
		System.out.println("Addition is :"+x+y); //Addition is :1215
		System.out.println(+x+y);//27
		System.out.println("Addition is :"+(x+y));
	}
}
-------------------------------------------------------------------------
18-12-2023
----------
Command Line Argument :
-----------------------
Whenever we pass any argument to the main method then it is called Command Line Argument.

By using command line argument we can pass some value at runtime.

The advantage of Command Line Argumenet is "Single time Compilation and 
number of times execution".

Note :- String is a collection of alpha-numeric character so Java software people decided to pass String as a parameter hence, it can accept all different types of values like int, float, double, character and so on.

Note :- If we modify .java file then we should re-compile our java file to generate a new .class file.
------------------------------------------------------------------------
//Accepting value from Command Line
public class Command 
{
	public static void main(String[] x) 
	{
		System.out.println(x[0]);
	}
}

javac Command.java
java Command Virat Rohit Siraj

Output :- Virat
-------------------------------------------------------------------------
WAP to take different value at the time of running the program 

//WAP to take different value at the time of running the program 

public class DifferentValuesFromCommand
{
	public static void main(String[] args) 
	{
		System.out.println(args[0]);
	}
}

javac DifferentValuesFromCommand.java
java DifferentValuesFromCommand Rahul Rohit Dhoni
Output :- Rahul
java DifferentValuesFromCommand Smiriti Mithali Jhulan
Output :- Smiriti
java DifferentValuesFromCommand ABC DEF GHI
Output :- ABC
-----------------------------------------------------------------------
Eclipse IDE :
-------------
IDE stands for Integrated Development Environment. By using Eclipse IDE, we can develop, compile and execute our program in a single window. 

The main purpose of Eclipse IDE to reduce the development time, Once developemnt time will be reduced, automatically the cost of the project will be reduced.

WAP in Eclipse IDE to print full name of user through command Line Argument 
---------------------------------------------------------------------------
package com.ravi.command;

public class FullNameByCommand 
{
  public static void main(String[] args) 
  {
	System.out.println(args[0]);
	
  }
}

java FullNameByCommand.java (Compilation)
java FullNameByCommand  Virat Kohli
Output :- Virat 
java FullNameByCommand  "Virat Kohli"
Output :- Virat Kohli
---------------------------------------------------------------------------
WAP to accept integer value from command line Argument :
--------------------------------------------------------
package com.ravi.command;

public class AcceptIntUsingCommand 
{
	public static void main(String[] args) 
	{
		System.out.println(args[0]);
	}

}

javac AcceptIntUsingCommand.java
java AcceptIntUsingCommand 12 89
Output : 12
java AcceptIntUsingCommand 12.45 89.78
Output : 12.45
java AcceptIntUsingCommand true false
Output : true

From the above it is clear that String parameter in the main method will accept different kinds of values.
---------------------------------------------------------------------------
WAP to add two numbers using Command line Argumenent :
------------------------------------------------------
package com.ravi.command;

public class CommandAddition 
{
	public static void main(String[] num) 
	{
		System.out.println(num[0] + num[1]);
	}

}

javac CommandAddition.java 
java CommandAddition 123 123
Output : 123123 [Here '+' operator behaves as a String concatenation Operator]

How to convert String into Integer :
------------------------------------
If we want to convert any String value into corresponding integer then java software people has provided predefined class called Integer available in java.lang package. 

In this class we have predefined static method, parseInt(String x) which is accepting a single parameter String as a parameter and convert this String into int value as shown in the below example.

public class Integer
{
  public static int parseInt(String x)
  {
   //Here logic is written to convert x which is String into corresponding int
  }
}

Note :-  "123" ------> parseInt(String x) ---------> 123 [Accepting String and converting into integer]
------------------------------------------------------------------------------
WAP to add two numbers using command line Argument with the help of Integer class
package com.ravi.command;

public class CommandAddition 
{
	public static void main(String[] num) 
	{	   
		
		  int a = Integer.parseInt(num[0]);
		  int b = Integer.parseInt(num[1]);		  
		  System.out.println("Sum is :"+(a+b));
	}

}

javac CommandAddition.java 
java CommandAddition 123 123
Output 246
java CommandAddition 500 1000
Output 1500
------------------------------------------------------------------------
19-12-2023
----------
What is a Package ?
-------------------
A package is nothing but folder in windows or directory in DOS.
A package is of two types :

1) Predefined Package :- Created by java software people. 
   Example :- java.lang, java.util, java.io, java.text, java.awt and so on

2) Userdefined Package :- Created by user.
   Example :- com.ravi.basic, com.ravi.introduction, com.ravi.oop and so on

   The program which contains package statement is different style of
   compiling :

   javac -d . Test.java
   (javac space -d space . space FileName.java)

   Program :
   ---------
   package com.tcs.shopping;

   public class Ravi 
   {
	
   }

   javac -d . Ravi.java
   3 folders will be created and then the .class file will be placed 
   inside the folder.
------------------------------------------------------------------------
Program which describes how Integer.parseInt(String str) is working :
---------------------------------------------------------------------
File Name :
Main.java
---------
package com.ravi.basic;

public class Main 
{
	public static void main(String[] args) 
	{
		int result =  Calculate.doSum(12, 36);
		System.out.println("Addition of two number :"+result);
		
		result =  Calculate.getSquare(12);
		System.out.println("Square is :"+result);
		
		result =  Calculate.getCube(2);
		System.out.println("Cube is :"+result);
	}
}

class Calculate
{
	public static int doSum(int x, int y)
	{
		int z = x + y;
		return z;
	}
	
	public static int getSquare(int a)
	{
		int b = a * a;
		return b;
	}
	
	public static int getCube(int p)
	{
		return (p*p*p);
	}
}
------------------------------------------------------------------------
*Naming convention in Java :
----------------------------
 1) How to write a class in java 
----------------------------------
While writing a class in java we should follow pascal naming convention. A java class represents noun.

ThisIsExampleOfClass (Each word first letter is capital)
Example :
-----------
String 
System
Integer
BufferedReader
DataInputStream
ClassNotFoundException
ArithmeticException

2) How to write a method in java :
---------------------------------------
In order to write methods in java we need to follow camel case naming convention. A java method represents verb.

thisIsExampleOfMethod()

Example:
----------
read()
readLine()
toUpperCase()
charAt()


3) How to write variable(Fields) in java 
--------------------------------------------
In order to write variables in java we need to follow camel case naming convention.

rollNumber;
employeeName;
customerNumber;
customerBill;

4) How to write final variable(Field)
-------------------------------
final double PI = 3.14;
final int A = 90;

5) How to write final and static variable 

   MAX_VALUE;
   MIN_VALUE;
Each character must be capital and in between every word _ symbol should be there.

6) How to write package 

   Package name must be in small character. It is reverse of company name.
   com.ravi.basic;            
-----------------------------------------------------------------------
Token :
--------
A token is the smallest unit of the program that is identified by the compiler.

Every Java statements and expressions are created using tokens.

A token can be divided into 5 types 

1) Keywords
2) Identifiers
3) Literals
4) Punctuators
5) Operators

Keyword :- 
----------
A keyword is a predefined word whose meaning is already defined by the compiler.

In java all the keywords must be in lowercase only.

A keyword we can't use as a name of the variable, name of the class or name of the method.

true, false and null look like keywords but actually they are literals.


Identifiers :
--------------
A name in java program  by default considered as identifiers.

Assigned to variable, method, classes to uniquely identify them.

We can't use keyword as an identifier.

Ex:-

class Fan 
{
   int coil  ;
   
   void start()
   {
   }
}

Here Fan(Name of the class), coil (Name of the variable) and start(Name of the function) are identifiers.
------------------------------------------------------------------------------------
Rules for defining an identifier :
------------------------------------
1) Can consist of uppercase(A-Z), lowercase(a-z),  digits(0-9), $ sign, and underscore (_)
2) Begins with letter, $, and _
3) It is case sensitive
4) Cannot be a keyword
5) No limitation of length 
-----------------------------------------------------------------------
Literals :-
-----------
Assigning some constant value to variable is called Literal.

Java supports 5 types of Literals :

1) Integral Literal  Ex:-  int x = 15;

2) Floating Point Literal  Ex:- float x = 3.5f;

3) Character Literal Ex:- char ch = 'A';

4) Boolean Literal Ex:- boolean b = true;

5) String Literal Ex:- String x = "Naresh i Technology";

Note :- null is also a literal.
------------------------------------------------------------------------
20-12-2023
-----------
Integral Literal :
------------------
If any numberic literal does not contain decimal or fraction then it is called Integeral Literal.
Example :-  67, 89, 234.

In Integeral literal we have 4 data types 
byte (8 bits)
short (16 bits)
int (32 bits)
long (64 bits)




An integral literal we can specify or represent in different ways

a) Decimal literal (Base 10)
b) Octal literal (Base 8)
c) Hexadecimal literal (Base 16)
d) Binary Literal (Base 2) (Available from JDK 1.7 onwards)

Note :- As a developer we can represent an integral literal in different forms(decimal, octal, hexadecimal and binary) but JVM always produces the output in decimal form only.

Decimal Literal :- 
-------------------
The base of decimal literal is 10. we can accept any digit from 0-9

Octal Literal :-
----------------
The base is 8. Here we can accept digits from 0-7 only. In java if any integral literal prefeix with '0' (Zero) then it becomes octal lietral.

Example:-

int x = 015; //Valid
int y = 018;//Invalid [Digit '8' is out of the range]

Hexadecimal Literal :-
-------------------------
The base is 16. Here we can accept digits from 0-15 (0-9 and A-F). In java if any integral literal prefix with 0X or 0x (zero with capital X OR zero with small x) then it becomes hexadecimal literal.

Example :-

int x = 0X15; //Valid
int y = 0x14;//Valid
int z = 0Xadd; //Valid
int a = 0Xage; //Invalid ['g' is out of range]

Binary Literal :-
-----------------
It is introduced from jdk 1.7 onwards. The base or radix is 2. Here we can accept digits 0 and 1 only. In java if any integral Literal prefix with 0B or 0b (zero capital B or 0 small b) then it becomes binary literal.

Example :-

int x = 0B111; //Valid
int y = 0b101010; //Valid
int z = 0B12; //Invalid [digit 2 is out of range]
-------------------------------------------------------------------------
//Octal literal
public class Test1
{
	public static void main(String[] args) 
	{
		int one = 01;   
		int six = 06;  
		int seven = 07;
		int eight = 010;
		int nine = 011;
                System.out.println("Octal 01 = "+one);
                System.out.println("Octal 06 = "+six);
		System.out.println("Octal 07 = "+seven);
		System.out.println("Octal 010 = "+eight);
		System.out.println("Octal 011   = "+nine);
	}
}
-----------------------------------------------------------------------
//Hexadecimal
public class Test2
{
public static void main(String[] args)
	{
		int i = 0x10;     //16
		int j = 0Xadd;   //2781
		System.out.println(i); 
		System.out.println(j); 
	}
}
------------------------------------------------------------------------
//Binary Literal
public class Test3
{
public static void main(String[] args)
	{
		int i = 0b101; 
		int j = 0B111;
		System.out.println(i); //5
		System.out.println(j); //7

		
	}
}
------------------------------------------------------------------
By default every integral literal is of type int only but we can specify explicitly as long type by suffixing with l (small l) OR L (Capital L).

According to industry standard L is more preferable because l (small l) looks like 1(digit 1).

There is no direct way to specify byte and short literals explicitly. If we assign any integral literal to byte variable and if the value is within the range (-128 to 127) then it is automatically treated as byte literals because compiler internally converts from int to byte.

If we assign integral literals to short and if the value is within the range (-32768 to 32767) then automatically it is treated as short literals because compiler internally converts from int to short.
------------------------------------------------------------------------
21-12-2023
------------
/* By default every integral literal is of type int only*/
public class Test4
{
public static void main(String[] args)
	{
                byte b = 128; //error
		System.out.println(b);
		
		short s = 32768; //error
		System.out.println(s);
    }
}
-------------------------------------------------------------------------
//Assigning smaller data type value to bigger data type
public class Test5
{
public static void main(String[] args)
	{
   	    byte b = 125;
		short s = b;   
		System.out.println(s);
	}
}
------------------------------------------------------------------------
//Converting bigger type to smaller type
public class Test6
{
public static void main(String[] args)
	{
		short s = 128;
		byte b = (byte) s;  //Explicit type casting [Chance of data loss]
		System.out.println(b);
	}
}
-------------------------------------------------------------------------
public class Test7
 {
 public static void main(String[] args)
 {
		byte x = (byte) 127L;
		System.out.println("x value  = "+x);

		long l = 29L;
		System.out.println("l value  = "+l);

        int y = (int) 18L; 
		System.out.println("y value  = "+y);
 
  }
 }   
-------------------------------------------------------------------------
Is java pure Object-Oriented language ?
----------------------------------------------
No, Java is not a pure Object-Oriented language. In fact any language which accepts the primary data type like int, float, char is not a pure object oriented language hence java is also not a pure object oriented language.

Example of pure object oriented language : Ruby, smalltalk and so on

If we remove all 8 primitive data types from java then Java will become pure object oriented language.

In java we have a concept called Wrapper classes through which we can convert the primary data types into corresponding Wrapper Object.(Autoboxing 1.5V)

Primary data types                Corresponding Wrapper Object
byte				-		Byte
short				-		Short
int				-		Integer
long				-		Long
float				-		Float
double				-		Double
char				-		Character
boolean				-		Boolean

All these wrapper classes are available in java.lang package.
------------------------------------------------------------------------
//Wrapper claases
public class Test8 
{
	public static void main(String[] args) 
	{
		Integer x = 24;  
		Integer y = 24;
		Integer z = x + y;
		System.out.println("The sum is :"+z);	
		
		Boolean b = true;
		System.out.println(b);

		Double d = 90.90;
		System.out.println(d);
	}
}
-------------------------------------------------------------------------
How to know the minimum and maximum value as well as size of integral literal data types:
----------------------------------------------------------------
Thses classes (Wrapper classe) are providing the static and final variables through which we can find out the minimum, maximum value as well as size of the data types

Ex:- I want to find out the range and size of Byte class

Byte.MIN_VALUE = -128

Byte.MAX_VALUE = 127

Byte.SIZE = 8 (in bits format)

Here MIN_VALUE, MAX_VALUE and SIZE these are static and final variables available in these classes(Byte, Short, Integer and Long).
-------------------------------------------------------------------------
 //Program to find out the range and size of Integeral Data type
public class Test9 
{
	public static void main(String[] args) 
	{
		System.out.println("\n Byte range:");
		System.out.println(" min: " + Byte.MIN_VALUE);
		System.out.println(" max: " + Byte.MAX_VALUE);
		System.out.println(" size :"+Byte.SIZE);
 
		System.out.println("\n Short range:");
		System.out.println(" min: " + Short.MIN_VALUE);
		System.out.println(" max: " + Short.MAX_VALUE);
		System.out.println(" size :"+Short.SIZE);

		System.out.println("\n Integer range:");
		System.out.println(" min: " + Integer.MIN_VALUE);
		System.out.println(" max: " + Integer.MAX_VALUE);
		System.out.println(" size :"+Integer.SIZE);

		System.out.println("\n Long range:");
		System.out.println(" min: " + Long.MIN_VALUE);
		System.out.println(" max: " + Long.MAX_VALUE);
		System.out.println(" size :"+Long.SIZE);
		
	}
}
-------------------------------------------------------------------------
//We can provide _ in integral literal
public class Test10 
{
	public static void main(String[] args) 
	{
	    long mobile = 9812_3456_78L;
		System.out.println("Mobile Number is :"+mobile);
	}
}

Note :- From java 1.7V now we can provide _ symbol in numeric
        literal just to increase the readability of the code.
------------------------------------------------------------------
public class Test11 
{
	public static void main(String[] args) 
	{
		final int x = 127;  
		byte b = x;
		System.out.println(b);
	}
}

The above program will generate the output.
------------------------------------------------------------------------
22-12-2023
----------
// Converting from decimal to another number system
public class Test12 
{
      public static void main(String[] argv) 
      {
		   //decimal to Binary
           System.out.println(Integer.toBinaryString(5)); //101

		   //decimal to Octal  
           System.out.println(Integer.toOctalString(15)); //17

		   //decimal to Hexadecimal
           System.out.println(Integer.toHexString(2781)); //add 
      }
}
--------------------------------------------------------------------------
//var keyword [Introduced from java 10]
public class Test13 
{
	public static void main(String[] args) 
	{
		   var x = 12;
		   System.out.println(x);		   
	}
}
------------------------------------------------------------------
floating point literal :
------------------------
1) Any numeric literal, if contains decimal or fraction then it is called floating point literal.

Example :- 67.89, 78.23, 90.90

2) In floating point literal we have 2 data types :
     a) float (32 bits)
     b) double (64 bits)

3) By default every floating point literal is of type double only so the following statement will generate compilation error
            
	     float f = 2.3; //Invalid 

Now, we have 3 solutions 

              float f1 = 2.3f;
	      float f2 = 2.3F;
              float f3 = (float) 7.8;
  
4) Even though, every floating point literal is of type double only but in order to enhance the readability of the code, java software people has
provided two flavors to represent double literal explicitly.

               double d1 = 2.3D;
	       double d2 = 2.5d;

*5) While working with integral literal, we can represent integral literal in 4 different forms i.e. decimal, octal, hexadecimal and binary but in floating point literal we have only one form i.e decimal.

*6) We can assign integral literal to floating point literal but floating point literal we cannot assign to integral literal.

7) We can represent floating point literal in exponent form.

   Example :- 15e2              
	      15 X 10 X 10 (10 to the power 2)
--------------------------------------------------------------------------
public class Test 
{
	public static void main(String[] args) 
	{
		float f = 2.0; //error
		System.out.println(f);				
	}
}
-------------------------------------------------------------------------
public class Test1 
{
	public static void main(String[] args) 
	{
		//float a = 1.0; 
		float b = 15.29F;
		float c = 15.25f;
		float d = (float) 15.25;

		System.out.println(b+" : "+c+" : "+d);
       
	}
}
-------------------------------------------------------------------------
public class Test2 
{
	public static void main(String[] args) 
	{
		double d = 15.15;
		double e = 15.15d;
		double f = 15.15D;
		
		System.out.println(d+" , "+e+" , "+f);
	}
}
-------------------------------------------------------------------------
public class Test3 
{
	public static void main(String[] args) 
	{
		 double x = 0129.89;  

		 double y = 0167;

		 double z = 0178; //error

		System.out.println(x+","+y+","+z);
	}
}
-------------------------------------------------------------------------
class Test4 
{
	public static void main(String[] args) 
	{
		double x = 0X29;  

		double y = 0X9.15; //error
		
		System.out.println(x+","+y);
	}
}
------------------------------------------------------------------------
public class Test5 
{
	public static void main(String[] args) 
	{
		double d1 = 15e-3;
		System.out.println("d1 value is :"+d1);		

		double d2 = 15e3;
		System.out.println("d2 value is :"+d2);	
		
		
	}
}
-------------------------------------------------------------------------
public class Test6 
{
	public static void main(String[] args) 
	{
		double a = 0791; 

		double b = 0791.0; 

		double c = 0777;  

		double d = 0Xdead;  
		
		double e = 0Xdead.0; 
	}
}
-------------------------------------------------------------------------
public class Test7 
{
	public static void main(String[] args) 
	{
	   double a = 1.5e3;
	   float b = 1.5e3; //E 
	   float c = 1.5e3F; 	   
	   double d = 10; 	   
	   int e = 10.0;  //E
	   long f = 10D; //E
	   int g = 10F; //E  
	   long l = 12.78F; //E 
	}
}
-------------------------------------------------------------------------
//Range and size of floating point literal 
public class Test8 
{
	public static void main(String[] args)    
	{
		System.out.println("\n Float range:");
		System.out.println(" min: " + Float.MIN_VALUE);
		System.out.println(" max: " + Float.MAX_VALUE); 
		System.out.println(" size :"+Float.SIZE);

		System.out.println("\n Double range:");
		System.out.println(" min: " + Double.MIN_VALUE);
		System.out.println(" max: " + Double.MAX_VALUE);
		System.out.println(" size :"+Double.SIZE);
	}
} 
------------------------------------------------------------------------
Boolean Literal :
----------------
It is used to represent two states either true or false.

In boolean literal we have only one data type i.e boolean data type which accepts 1 bit of memory as well as it also depends on JVM implementation.

Unlike C and C++, we cannot assign 0 and 1 to boolean data type because in java any number without decimal is treated as integral literal

        boolean isEmpty = 0; [Invalid in Java but valid in C and C++]


We cannot assign String to boolean type as shown below.

         boolean isValid = "true"; //Invalid
------------------------------------------------------------------------
public class Test1
{
    public static void main(String[] args)
    {
        boolean isValid = true;   
        boolean isEmpty = false;
		
        System.out.println(isValid);
        System.out.println(isEmpty);
     }
}
-----------------------------------------------------------------------
public class Test2
{
    public static void main(String[] args)
    {
	boolean c = 0; //error
        boolean d = 1; //error
        System.out.println(c);
        System.out.println(d);       
    }
}
------------------------------------------------------------------------
public class Test3 
{
	public static void main(String[] args) 
	{
		boolean x = "true";  //error
		boolean y = "false";  //error
		System.out.println(x);
                System.out.println(y); 
	}
}
------------------------------------------------------------------------
23-12-2023
----------
Character Literal :
-------------------
It is also known as char literal.

Here we have only one data type i.e char data type which accepts 2 bytes of memory.

We can represent char literal in different ways which are as follows :

 a) Single character enclosed with single quotes.

    Example :- char ch = 'A';

 b) We can assign integral literal to char data type to represent the UNICODE value for that character. 
    In older language like C and C++, the range is 0 - 255 which is representing the ASCII value of the character.
    But Java supports UNICODE where the range is 0 - 65535.

    char ch = 65535; //Valid
    char ch = 65536; //InValid

 c) The char literal we can assign to integeral data type to know the UNICODE number value of that character.

    int ch = 'A';    -> 65

 d) All our escape sequnces we can represent as char literal.

    char ch = '\n';

 e) We can represent char literal in 4 digit hexadecimal number to represent UNICODE value where the format is :

                     '\uXXXX'

     Here \u stands for UNICODE where as X represents Digits.
--------------------------------------------------------------------------
public class Test1 
{
	public static void main(String[] args) 
	{
		char ch1 = 'a';
		System.out.println("ch1 value is :"+ch1); 

		char ch2 = 97;   
		System.out.println("ch2 value is :"+ch2); 

		
	}
}
-------------------------------------------------------------------------
class Test2 
{
	public static void main(String[] args) 
	{
		int ch = 'A';
		System.out.println("ch value is :"+ch);
	}
}
--------------------------------------------------------------------------
//The UNICODE value for ? character is 
public class Test3 
{
	public static void main(String[] args) 
	{
		char ch1 = 63;  
		System.out.println("ch1 value is :"+ch1);
		
		char ch2 = 64;  
		System.out.println("ch2 value is :"+ch2); 

		char ch3 = 65; 
		System.out.println("ch3 value is :"+ch3); 
	}
}

The UNICODE value for ? -> 63, @ -> 64
-----------------------------------------------------------------------
public class Test4 
{
	public static void main(String[] args) 
	{
		char ch1 = 47000;
        System.out.println("ch1 value is :"+ch1); 

		char ch2 = 0Xadd;  
		System.out.println("ch2 value is :"+ch2); 
	}
}

Here we will get the output as ? because the equivalent language translator is not available to represent these characters so we are getting the ? symbol.
------------------------------------------------------------------------
//Addition of two character in the form of Integer
public class Test5
{
public static void main(String txt[ ])
  {
	int x = 'A'; 
        int y = 'B';
        System.out.println(x+y); 
	System.out.println('A' + 'A'); 		
   } 
} 
------------------------------------------------------------------------
//Range of UNICODE Value (65535)
class Test6 
{
	public static void main(String[] args) 
	{
		char ch1 = 65535; 
		System.out.println("ch value is :"+ch1);

		char ch2 = 65536; //error
		System.out.println("ch value is :"+ch2);
	}
}
------------------------------------------------------------------------
//WAP in java to describe unicode representation of char in hexadecimal format
class Test7 
{
	public static void main(String[] args) 
	{
		char ch1 = '\u0002'; 
		System.out.println(ch1);

		char ch2 = '\uffff'; 
		System.out.println(ch2);

		char ch3 = '\u0041'; 
                System.out.println(ch3);  

		char ch4 = '\u0061';
		System.out.println(ch4); 
	}
}
----------------------------------------------------------------------
class Test8 
{
	public static void main(String[] args) 
	{
		char c1 = 'A';
		char c2 = 65;
		char c3 = '\u0041';

		System.out.println("c1 = "+c1+", c2 ="+c2+", c3 ="+c3);
	}
}
-----------------------------------------------------------------------
class Test9 
{
	public static void main(String[] args) 
	{
		int x = 'A';
		int y = '\u0041';
		System.out.println("x = "+x+" y ="+y);
	}
}
------------------------------------------------------------------------
//Every escape sequence is char literal
class Test10 
{
	public static void main(String [] args) 
	{
		char ch ='\n';
		System.out.println(ch);
	}
}
------------------------------------------------------------------------
public class Test11  
{
	public static void main(String[] args) 
	{
		System.out.println(Character.MIN_VALUE); //white space
		System.out.println(Character.MAX_VALUE); //?
		System.out.println(Character.SIZE); //16 bits
		
	}
}
-----------------------------------------------------------------------
//Java Unicodes
public class Test12 
{
	public static void main(String[] args) 
	{
		System.out.println(" Java Unicodes\n");

		for (int i = 31; i < 126; i++)
		{
			char ch = (char)i; // Convert unicode to character
			String str = i + "  "+ ch;  

			System.out.print(str + "\t\t");
			if ((i % 5) == 0) // Set 5 numbers per row
			System.out.println();
		}
	}
}
------------------------------------------------------------------------
Operator Related Concept :
------------------------------------------------------------------------
public class Demo 
{
	public static void main(String[] args) 
	{
	   char ch = 'A';
	   ch++;
	   System.out.println(ch);
	}
}

Incremenet and decrement operator will work with all data type except boolean.
------------------------------------------------------------------------
public class Demo 
{
	public static void main(String[] args) 
	{
	   char ch1 = 'A';
	   char ch2 = 'B';
	   System.out.println(ch1+ch2);
	}
}
------------------------------------------------------------------------
While working with Arithmetic Operator and Unary minus operator the minimum data type required is int OR in other words after the expression the result is promoted to int type.

public class Demo 
{
	public static void main(String[] args) 
	{
	  byte b = 1;
	  byte c = 2;
	  byte d = b + c; //error
	  int d = b + c;
	  System.out.println(d);
	}
}
--------------------------------------------------------------------------
public class Demo 
{
	public static void main(String[] args) 
	{
	  byte b = 1;
	  byte c = -b; //error
	}
}
------------------------------------------------------------------------
public class Test15
{
	public static void main(String args[])
	{
	  /*short b = 6;
      b = b + 7;  
	  System.out.println(b); */

	  byte b = 6;
	  b += 6;   //short hand operator  b += 7 is equal to (b = b + 7)
	  System.out.println(b);  
	}
}
------------------------------------------------------------------------
public class Demo 
{
	public static void main(String[] args) 
	{
	   int x = 5;

	       if(++x > 6 & ++x > 6) //Boolean AND [Both expression will 
	                                         be evaluated]
		{
		   
		}

		System.out.println(x);
	}
}
------------------------------------------------------------------------
26-12-2023
----------
String Literal :-
----------------
A string literal in Java is basically a sequence of characters. These characters can be anything like alphabets, numbers or symbols which are enclosed with double quotes. So we can say String is alpha-numeric collection of character.


How we can create String in Java :-
-----------------------------------
In java String can be created by using 3 ways :-

1) By using String Literal 

   String x = "Ravi";

2) By using new keyword 

   String y = new String("Hyderabad");

3) By using character array

   char z[] = {'H','E','L','L','O'};

------------------------------------------------------------------------
//Three Ways to create the String Object
public class StringTest1 
{
	public static void main(String[] args) 
	{
		String s1 = "Hello World";       //Literal
		System.out.println(s1);

		String s2 = new String("Ravi"); //Using new Keyword
		System.out.println(s2);

		char s3[] = {'H','E','L','L','O'}; //Character Array 
		System.out.println(s3);

	}
}
-----------------------------------------------------------------------
//String is collection of alpha-numeric character
public class StringTest2 
{
	public static void main(String[] args) 
	{
		String x="B-61 Hyderabad";
		System.out.println(x);
		
		String y = "123";  
		System.out.println(y);

		String z = "67.90";       
		System.out.println(z);

		String p = "A";        
		System.out.println(p);
	}
}
------------------------------------------------------------------------
//IQ
public class StringTest3
{
	public static void main(String []args)
	{		
		String s = 15+29+"Ravi"+40+40; 
		System.out.println(s);	
		
	}
}
------------------------------------------------------------------------
How to take the input from the user :
-------------------------------------
In order to take the input from the user, Java software people has provided a predefined class called Scanner available in java.util package. It is available from java 1.5v.

static variable of System class :
---------------------------------
As we know System is a predefined class available in java.lang package which provided the following static variables :

  a) System.out :- It is used to print normal message.
  b) System.err :- It is used to print error message. (Red Colour)
  c) System.in :- It is used to take the input from the source.

How to create an object for Scanner class :
-------------------------------------------
 Scanner sc = new Scanner(System.in);


Methods of Scanner class :
--------------------------
1) public String next() : Will read single word.

2) public String nextLine() : Will read complete line. (Multiple Words)

3) public byte nextByte() : Will read byte value.

4) public short nextShort() : Will read short value.

5) public int nextInt() : Will read int value.

6) public long nextLong() : Will read long value.

7) public float nextFloat() : Will read float value.

8) public double nextDouble() : Will read double value.

9) public boolean nextBoolean() : Will read boolean value.

10) public char next().charAt(0) : Will read a character.       


/*
public class Scanner
{
  public String next()
   {
     will return and read a single word from the user
   }
}

Scanner sc = new Scanner(System.in);  //Object creation
String word =   sc.next();
*/

-----------------------------------------------------------------------
Note :- java.lang is a default package so it is available in all the classes by default, as a user we need not to import java.lang package that means all the classes which are available in java.lang package we can use from everywhere.

Program on Scanner class :
---------------------------
//WAP to read your name from the user
import java.util.*;
public class ReadName 
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter your Name :");
		String name = sc.nextLine();
		System.out.println("Your Name is :"+name);
	}
}
------------------------------------------------------------------------
//WAP to read the gender [M/F] from the user
import java.util.Scanner;
public class ReadGender  
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter your Gender :");

		char gen = sc.next().charAt(0);
		System.out.println("Your Gender is :"+gen);
	}
}
------------------------------------------------------------------------
WAP to read Employee id and Name from the keyboard.
//WAP to read Employee id and Name from the keyboard.

public class ReadEmployeeData 
{
	public static void main(String[] args) 
	{
		java.util.Scanner sc = new java.util.Scanner(System.in);
 
		System.out.print("Enter Employee Id :");
		int empId =  sc.nextInt();	//123 \n
		
		System.out.print("Enter Employee Name :");
		String empName = sc.nextLine();  //Buffer Problem
		empName = sc.nextLine();

        System.out.println("Employee Id is :"+empId);
		System.out.println("Employee Name is :"+empName);

		
	}
}
-----------------------------------------------------------------------
4) Punctuators
--------------
It is also called as separators.

It is used to inform the compiler that how the things will be grouped together.

Example :-  (), {}, [], ; , ... (var args) 

-----------------------------------------------------------------------
5) Operator :
-------------
An operator is a symbol that describes how the calculation will be performed on the operands.

Example :- a + b;  //Here a and b both are operands where as '+' is operator 

Java supports the following operators :

1) Arithmetic Operator OR Binary Operator
2) Unary Operator
3) Assignment Operator
4) Relational Operator
5) Logical Operator (&&   ||    !)
6) Booelan Operatot (&    |) 
7) Bitwise Operator (~)
8) Ternary Operator
*9) new Operator
*10) Dot Operator (. [Member Access Operator])
*11) instanceof operator
-----------------------------------------------------------------------
27-12-2023
-----------
What is BLC and ELC class in Java :
-----------------------------------
BLC : It stands for Business Logic class, here we are responsible to 
      write the logic and this class will never contain main method.

ELC : It stands for Executable Logic class, here we need to define the 
      main method and the execution of the program will always starts from ELC class only.

-----------------------------------------------------------------------
Note :- FOR NON STATIC MEMBERS LIKE (NON STATIC VARIABLE AND NON STATIC METHOD) OBJECT IS REQUIRED ON THE OTHER HAND FOR STATIC MEMBER (STATIC METHOD AND STATIC VARIABLE) OBJECT IS NOT REQUIRED.
-----------------------------------------------------------------------
If a static method available in the same class then we can call the static method directly from another static method of the same class without object as shown in the program.

//A static method can be directly call within the same class
package com.ravi.pack1;

public class Test1
{
	public static void main (String[] arg)
	{
		square(5); 	    
	}

	public static void square(int x)
	{  
	  System.out.println(x*x);
	}
}
----------------------------------------------------------------------	
If a static method available in the same class then we can directly call from another static method, on the other hand static method available in another class then we need to call the static method with the help of class name as shown in the program below.

2 Files :
---------
FindSquare.java
---------------
package com.ravi.pack2;

//BLC(Business Logic class)
public class FindSquare
{
   public static void getSqureOfTheNumber(int x)
   {
	   System.out.println("Square of "+x+" is :"+(x*x));
   }
}




Test2.java
-----------
//A static method available in another class can be 
//call with class name

package com.ravi.pack2;

import java.util.Scanner;

//ELC(Executable Logic class)
public class Test2
{
	public static void main (String[] args)
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter the Number :");
		int num = sc.nextInt();		
		
		FindSquare.getSqureOfTheNumber(num); 
		sc.close();
	}
}
----------------------------------------------------------------------
Note :- In a single Java file we must have only one public class and remaining classes must be declared non-public.

Example :
----------
Test.java
----------
 
public class Test //Writing public is valid
{
}

class Welcome  //Welcome class we can't declare with public AM because
{                Welcome and Test both the classes are available in the 
}                same file Test.java
-----------------------------------------------------------------------
The program says the communication between BLC and ELC class using return statement.

2 Files :
---------
FindSquare.java
---------------
//A static method returning integer value 
package com.ravi.pack3;

//BLC
public class FindSquare
{
	public static int getSquare(int x)
	{
		return (x*x);
	}
}

Test3.java
----------

package com.ravi.pack3;

//ELC
public class Test3
{
	public static void main (String[] arg)
	{				
         for(int i=1; i<=10; i++)
          {
    	    int square = FindSquare.getSquare(i);
    	    System.out.println("Square of "+i+" is :"+square);
          }
	}
}
-----------------------------------------------------------------------
2 Files :
---------
Calculate.java
---------------
/*Program to find out the square and cube of 
  the number by following criteria
 * 
a) If number is 0 or Negative it should return -1
b) If number is even It should return square of the number
c) If number is odd It should return cube of the number
*/

package com.ravi.pack4;

//BLC
public class Calculate 
{
  public static int getSquareAndCube(int num)
  {
	  if(num==0 || num<0)
	  {
		  return -1;
	  }
	  else if(num %2 ==0)
	  {
		  return (num*num);
	  }
	  else
	  {
		  return (num*num*num);
	  }
  }
}

Test4.java
-----------
package com.ravi.pack4;

import java.util.Scanner;

//ELC
public class Test4 
{
	public static void main(String[] args) 
	{
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter a Number :");
        int num = sc.nextInt();
        
        int squareAndCube = Calculate.getSquareAndCube(num);
        System.out.println(squareAndCube);
	}	
}
----------------------------------------------------------------------
29-12-2023
----------
Finding the Area of Rectangle :
-------------------------------
2 Files :
--------
Rectangle.java
---------------
package com.ravi.pack5;

//BLC
public class Rectangle 
{
  public static double getArea(double height, double width)
  {
	  double area = height*width;
	  return area;
  }
}

Test5.java
----------
package com.ravi.pack5;

public class Test5 
{
	public static void main(String[] args)
	{
	 double areaOfRect = Rectangle.getArea(2.3, 8.9);
	 System.out.println("Area of Rectangle is :"+areaOfRect);
	}
}
--------------------------------------------------------------------------
//Program to verify number is even or odd

2 files :
---------
EvenOrOdd.java
--------------
package com.ravi.pack6;

//BLC
public class EvenOrOdd 
{
   public static boolean isEven(int num)
    {
        return (num % 2 == 0);
    }
}


Test6.java
----------
package com.ravi.pack6;

//ELC
public class Test6 
{
	public static void main(String[] args) 
	{
	 boolean val =   EvenOrOdd.isEven(4);	
	 System.out.println("4 is even :"+val);
	 
	 val =   EvenOrOdd.isEven(5);	
	 System.out.println("5 is even :"+val);
	}
}
--------------------------------------------------------------------------
How to provide userdefined format for decimal numbers ?
--------------------------------------------------------
java.text package has provided a predefined class called DecimalFormat
which is accepting format as a String parameter as shown below.

  DecimalFormat df = new DecimalFormat("00.00"); //"00.00" is the format which is available in String type (String pattern)

Now this DecimalFormat class contains non static method format() which accepts double as a parameter.

  DecimalFormat df = new DecimalFormat("00.00");
                df.format(double value);

2 Files :
----------
Circle.java
------------
//Area of Circle
package com.ravi.pack7;
public class Circle 
{
  public static String getArea(double rad)
  {
	if(rad == 0 || rad<0)
	{
		return ""+(-1);
	}
	else
	{
	  final double PI = 3.14;
	  double area = PI * rad * rad;
	  return ""+area;
	}
	  
  }
}


Test7.java
----------
package com.ravi.pack7;

import java.text.DecimalFormat;
import java.util.Scanner;

public class Test7 
{
	public static void main(String[] args) 
	{   
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter the radius :");
		int rad = sc.nextInt();
		
		String area = Circle.getArea(rad);
		
		
		//Convert the String into double
		double areaOfCircle = Double.parseDouble(area);
		
		
		DecimalFormat df = new DecimalFormat("00.00");		
		System.out.println("Area of Circle is :"+df.format(areaOfCircle));
       
	    sc.close();
	}
}
-------------------------------------------------------------------------
Program that describes method return type is String

2 Files :
---------
Student.java
------------
package com.ravi.pack8;

//BLC
public class Student 
{
 public static String getStudentDetails(int roll, String name, double fees)
  {
	//[Student name is : Ravi, roll is : 101, fees is :1200.90]
	 
	return "[Student name is :"+name+", roll is :"+roll+", fees is :"+fees+"]";                                   
		
  }   
}

Test8.java
----------
package com.ravi.pack8;

public class Test8 
{
	public static void main(String[] args)
	{
		String details = Student.getStudentDetails(111, "Raj", 18000.90);
		System.out.println("Student Details are :"+details);
	}

}
--------------------------------------------------------------------------
Printing the table in proper format :

2 Files :
----------
Table.java
----------
package com.ravi.pack9;

//BLC
public class Table 
{
  public static void printTable(int num) //9
  {
	  for(int i=1; i<=10; i++)
	  {
		 System.out.println(num+" X "+i+" = "+(num*i));
	  }
	  System.out.println(".................");
  }
}



Test9.java
----------
package com.ravi.pack9;

//ELC
public class Test9 
{
	public static void main(String[] args) 
	{		
		for(int i=1; i<=10; i++)
		{
			Table.printTable(i);
		}
	}

}
--------------------------------------------------------------------------
Types of variable in Java :
---------------------------
In Java based on data type, we have only 2 types of variables 

 1) Primitive type (byte, short, int , long and so on)

 Example :- int x = 10; [Primitive type will always hold the value]

 2) Reference Variable

 Example :- Employee e1 = new Employee(); [Reference variable will hold the                                                                   address]
            //Here e1 is a reference variable


Now further based on the Declaration position variable is divided into 4 types :

1) Class variable OR Static field
2) Instance variable OR Non-static field
3) Local/Stack/Automatic/Temporary variable
4) Parameter Varaiable.


class A
{
   int x = 10; //primitive + instance variable
   static int y = 20; primitive + class variable

   public void accept(int z)  // z is parameter variable
   {
       int a = 40; //local variable
   }
}


package com.ravi.co_variant;

import java.util.Scanner;

public class Employee 
{
    Employee e1 = new Employee(); //Instance + ref
    static Scanner sc = new Scanner(System.in); //class Variable + ref
    
	public static void main(String[] args) 
	{
		Employee e2 = new Employee(); //Local + Ref
		
		accept(e2);
	}

	public static void accept(Employee e3) //Parameter + ref
	{
		
	}
}
--------------------------------------------------------------------------
Operator and Control statement notes :
--------------------------------------

Operators :
-------------
It is a symbol which describes that how a calculation will be performed on operands.

Types Of Operators :
------------------------
1) Arithmetic Operator (Binary Operator)

2) Unary Operators

3) Assignment Operator

4) Relational Operator

5) Logical Operators   

6) Boolean Operators   

7) Bitwise Operators

8) Ternary Operator

9) Member Operator

10) new Operator

11) instanceof Operator
---------------------------------------------------------------
Arithmetic Operator OR Binary Operator :
-----------------------------------------------
It is known as Arithmetic Operator OR Binary Operator because it works with minimum two operands.

Ex:-   +, - , *, / and % (Modula Or Modulus Operator)
-----------------------------------------------------------------
//Arithmetic Operator
// Addition operator to join two Strings working as String concatenation optr
public class Test1 
{
	public static void main(String[] args) 
	{
		String s1 = "Welcome to";
		String s2 = " Java ";
		String s3 = s1 + s2;
		System.out.println("String after concatenation :"+s3);
		
	}
}
------------------------------------------------------------------
How to read the value from the user/keyboard (Accepting the data from client)
-------------------------------------------------------------------------------------------
In order to read the data from the client or keyboard, java software people has provided a predefined class called Scanner available in java.util package.

It is available from java 5v. 

static variables of System class :
------------------------------------
System is a predefined class which contains 3 static variables.

System.out :- It is used to print normal message on the screen.

System.err :- It is used to print error message on the screen.

System.in :- It is used to take input from the user.(Attaching the keyboard with System resource)


How to create the Object for Scanner class :
--------------------------------------------------
Scanner sc = new Scanner(System.in);  //Taking the input from the user


Scanner class provides various methods :
-----------------------------------------------
String next() :- Used to read a single word.

String  nextLine() :- Used to read complete line or multiple Words.

byte nextByte() :- Used to read byte value

short nextShort() :- Used to read short value

int nextInt() :- Used to read integer value

float nextFloat() :- Used to read float value

double nextDouble() :- Used to read double value

boolean nextBoolean() :- Used to read boolean value.

char next().charAt(0) :- Used to read a character
---------------------------------------------------------------------
//WAP to read your name from the keyboard
import java.util.*;
public class Test2  
{
	public static void main(String [] args)
	{
      Scanner sc = new Scanner(System.in);
	  System.out.print("Enter your Name :");
	  String name =  sc.next(); //will read single word
	  System.out.println("Your name is :"+name);
	}
}
------------------------------------------------------------------
27-10-2023
-----------
//WAP to read your name from the keyboard
import java.util.Scanner;
public class ReadCompleteName 
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter your Name :");
		String name = sc.nextLine();
		System.out.println("Your Name is :"+name);
	}
}

------------------------------------------------------------------
//Reading Employee data
import java.util.Scanner;
public class EmployeeData 
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);

        System.out.print("Enter Employee Id :");
		int id = sc.nextInt();
        
        System.out.print("Enter Employee Name :");
		String name = sc.nextLine(); //Buffer Problem 
		name = sc.nextLine(); 
		
		System.out.println("Employee Id is :"+id);
		System.out.println("Employee Name is :"+name);
	}
}
------------------------------------------------------------------
//Arithmetic Operator (+, -, *, / , %)
//Reverse of a 3 digit number
import java.util.*;
class Test3
{
	public static void main(String[] args) 
	{
		System.out.print("Enter a three digit number :");
		Scanner sc = new Scanner(System.in);
        
		int num =  sc.nextInt(); //num = 567

		int rem = num % 10;  //rem = 7
        System.out.print("The Reverse is :"+rem); //The reverse is :765

        num = num /10;    //num = 56
		rem = num % 10;  //rem = 6
        System.out.print(rem);

		num = num/10; //num = 5
		System.out.println(num);
	}
}

--------------------------------------------------------------
Unary Operator :
--------------------
The operator which works upon single operand is called Unary Operator.In java we have so many unary operators which are as follows :

1) Unary minus operator (-)       

2) Increment Operator (++)

3) Decrement Operator (--)
---------------------------------------------------------------
//*Unary Operators (Acts on only one operand)
//Unary minus Operator
class Test4 
{
	public static void main(String[] args) 
	{
		int x = 15;
		System.out.println(-x); 
		System.out.println(-(-x));
	}
}
---------------------------------------------------------------
//Unary Operators
//Unary Pre increment Operator
class Test5 
{
	public static void main(String[] args) 
	{
		int x = 15;
		int y = ++x;    //First increment then assignment
		System.out.println(x+":"+y);
	}
}
--------------------------------------------------------------
//Unary Operators
//Unary Post increment Operator
class Test6 
{
	public static void main(String[] args) 
	{
		int x = 15;
		int y = x++; //First assignment then increment
		System.out.println(x+":"+y);
	}
}
-------------------------------------------------------------
//Unary Operators
//Unary Pre increment Operator
class Test7 
{
	public static void main(String[] args) 
	{
		int x = 15;
		int y = ++15;   //error
		System.out.println(y);
	}
}
--------------------------------------------------------------
//Unary Operators
//Unary Pre increment Operator
class Test8
{
	public static void main(String[] args) 
	{
		int x = 15;
		int y = ++(++x); //error  
		System.out.println(y);
	}
}
--------------------------------------------------------------

//Unary Operators
//Unary post increment Operator
class Test9
{
	public static void main(String[] args) 
	{
		int x = 15;
		System.out.println(++x + x++); 
		System.out.println(x);    
        System.out.println("..................");
 
		int y = 15;
		System.out.println(++y + ++y); 
		System.out.println(y);   
	}
}

--------------------------------------------------------------
Note :- Increment and decrement operator we can apply with any data type except boolean.
---------------------------------------------------------------
//Unary Operators
//Unary post increment Operator
class Test10
{
	public static void main(String[] args) 
	{
		char ch ='A';
		ch++;
		System.out.println(ch); 
	}
}
---------------------------------------------------------------
//Unary Operators
//Unary post increment Operator
class Test11
{
	public static void main(String[] args) 
	{
		double d = 15.15;
		d++;
		System.out.println(d);
	}
		
}
 
---------------------------------------------------------------
//Unary Operators
//Unary Pre decrement Operator
class Test12 
{
	public static void main(String[] args) 
	{
		int x = 15;
		int y = --x; //First decrement then assignment
		System.out.println(x+":"+y);
	}
}
--------------------------------------------------------------
//Unary Operators
//Unary Post decrement Operator
class Test13
{
	public static void main(String[] args) 
	{
		int x = 15;
		int y = x--;
		System.out.println(x+":"+y); 
	}
}
---------------------------------------------------------------
Interview Question 
----------------------
Whenever we work with Arithmetic Operator or Unary minus operator, the minimum data type required is int, So after calculation of expression it is promoted to int type.

//IQ
class Test14
{
	public static void main(String args[])
	{
		byte i = 1;
		byte j = 1;
		byte k = i + j;  //error
		System.out.println(k);
	}
}
-------------------------------------------------------------
class Test15
{
	public static void main(String args[])
	{
		/*byte b = 6;
        b = b + 7;  //error      
		System.out.println(b); */

  byte b = 6;
  b += 7;//short hand operator  b += 7 is equal to (b = b + 7)
  System.out.println(b); 
	  
	}
}

Note :- In the above program it generates error while working with Arithmetic Operator but when we change the operator from 
Arithmetic to short hand operator then the expression result we can assign on byte data type.
--------------------------------------------------------------
class Test16
{
	 public static void main(String args[])
	{ 
		byte b = 1;
		byte b1 = -b; //error
             System.out.print(b1);  
	}
}
---------------------------------------------------------------
What is a local variable :
----------------------------
If a variable is declared inside a method  body(not as a method parameter) then it is called Local / Stack/ Temporary / Automatic variable.

Ex:-

public void input()
{
    int y = 12;
}

Here in the above example y is local variable.

Local variable we can't use outside of the function or method.

A local variable must be initialized before use otherwise we wiil get compilation error.

We can't use any access modifier on local variable except final.

Program
---------
public class Test17
{		 
	public static void main(String [] args)
	{
	  int x ; //must be initialized before use
	  System.out.println(x);

        public int y = 100;//only final is acceptable
        System.out.println(y);
	}	
}

Note :- In the above program we will get compilation error
------------------------------------------------------------------
Why we cannot use local variables outside of the method ?
----------------------------------------------------------
In java all the methods are executed as a part of Stack Memory. Stack Memory works on the basis of LIFO (Last In First Out).

Once the method execution is over, local variables are also deleted from stack frame so we cannot use local variables outside of the method.(Diagram 27-OCT-23)

class StackMemory
{
	public static void main(String[] args) 
	{
		System.out.println("Main method started..");
        m1();
		System.out.println("Main method ended..");
	}
	public static void m1()
	{
		System.out.println("m1 method started..");
        m2();
		System.out.println("m1 method ended..");
	}
	public static void m2()
	{		
		int x = 100;
		System.out.println("I am m2 method!!!"+x);
	}	
}

------------------------------------------------------------------
28-10-2023
-----------
//*Program on Assignment Operator
class Test18
{
	public static void main(String args[])
	 { 
        int x = 5, y = 3;  
        System.out.println("x = " + x);
        System.out.println("y = " + y); 
		
        x %= y;          //short hand operator  x = x % y
        System.out.println("x = " + x);     
		}
}
------------------------------------------------------------------
What is BLC class :
------------------
BLC stands for Business Logic class. A BLC class never contains main method. It is used to write the logic only.

What is ELC class :
------------------
ELC stands for Executable Logic class. An ELC class always contains main method. It is called ELC class because the execution of the program starts from ELC class.

Note :- WE SHOULD ALWAYS TAKE OUR JAVA CLASSES IN A SEPARATE FILE OTHERWISE THE RE-USABILITY OF THE CLASS IS NOT POSSIBLE.
------------------------------------------------------------------
Here we have 2 files :
----------------------
Circle.java(BLC)
------------------
package com.ravi.blc_elc;
/*
 Find the area of circle. Accept the radius value from the user
 if the radius is zero or negative then return -1. 
*/

//BLC
public class Circle 
{
   public static double getAreaOfCircle(int radius)
   {
	   if(radius <=0)
	   {
		   return -1;
	   }
	   else
	   {
		   final double PI = 3.14;
		   double areaOfCircle = PI * radius * radius;
		   return areaOfCircle;
	   }
   }
}

AreaOfCircle.java(ELC)
------------------------
package com.ravi.blc_elc;

import java.util.Scanner;

//ELC
public class AreaOfCircle 
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter the radius of the Circle :");
		int radius = sc.nextInt();
		
		double areaOfCircle = Circle.getAreaOfCircle(radius);
		System.out.println("Area of Circle is :"+areaOfCircle);
		sc.close();
	}

}
------------------------------------------------------------------
Relational Operator :- 
------------------------
These operators are used to compare the values. The return type is boolean. We have total 6 Ralational Operators.

1) >   (Greater than)

2) <   (Less than)

3) >= (Greater than or equal to)

4) <= (Less than or equal to)

5) == (double equal to)

6) != (Not equal to )

//*Program on relational operator(6 Operators)
class Test19  
{
	public static void main(String args[])
	{
      int a = 10;
      int b = 20;
      System.out.println("a == b : " + (a == b) ); //false
      System.out.println("a != b : " + (a != b) );  //true
      System.out.println("a > b : " + (a > b) );   //false
      System.out.println("a < b : " + (a < b) );   //true
      System.out.println("b >= a : " + (b >= a) ); //true
      System.out.println("b <= a : " + (b <= a) ); //false
    }
}
--------------------------------------------------------------
If condition :
---------------
It is decision making statement. It is used to test a boolean expression. The expression must return boolean type.

//Program to check a number is 0 or +ve or -ve
import java.util.Scanner;
class Test20
{
	public static void main(String args[])
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Please enter a Number :");

		int num = sc.nextInt();
		if(num == 0)
		System.out.println("It is zero");

		else if(num>0)
		System.out.println(num+" is positive");
		else
		System.out.println(num+" is negative");

		sc.close(); //To close Scanner resource
	}
}
--------------------------------------------------------------
/*program to calculate telephone bill
For 100 free call rental = 360
For 101 - 250, 1 Rs per call
For 251 - unlimited , 1.2 Rs per call
*/
import java.util.*;
class Test21
{
public static void main(String args[])
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter current Reading :");
		int curr_read = sc.nextInt();

		System.out.print("Enter Previous Reading :");
		int prev_read = sc.nextInt();

		int nc = curr_read - prev_read;	[curr_read > prev_read]
		System.out.println("Your Number of call for this month is :"+nc);		

		double bill = 0.0;
		if (nc <=100)
		{
			bill = 360;
		}
		else if(nc<=250)
		{
           bill = 360 + (nc-100)*1.0;
		}
        else if(nc >250)
		{
            bill = 360 + 150 + (nc-250)*1.2;
		}
         System.out.println("The bill is :"+bill);
	}
}
--------------------------------------------------------------
Nested if:
---------
If an 'if condition' is placed inside another if condition then it is called Nested if.
In nested if condition, we have one outer if and one inner if condition, the inner if condition will only execute when outer if condition returns true.

if(condition)  //Outer if condition
{
   if(condition) //inner if condition
   {
   }
   else //inner else
   {
   }
}
else //outer else
{
}
--------------------------------------------------------------
//Nested if
//big among three number
class Test22
{
public static void main(String args[])
	{
		int a =15;
		int b =12;
		int c =18;

		int big=0;   

		if(a>b)  //(Outer if condition)
		{			
			if(a>c)     //Nested If Block (inner if)        
				big=a;
			else
				big=c;
		}
		else    //already confirmed b is greater than a
		{
			if(b>c)   
				big=b;
			else
				big=c;
		}
	System.out.println("The big number is :"+big);
	}
}

Note :- In the above program to find out the biggest number among three number we need to take the help of nested if condition but the code becomes complex, to reduce the length of the code Logical Operator came into the picture.
--------------------------------------------------------------

Logical Operator :-
--------------------
It is used to combine or join the multiple conditions into a single statement. 

It is also known as short-Circuit logical operator.

In Java we have 3 logical Operators 

1) &&  (AND Logical Operator)

2) ||  (OR Logical Operator)

3) !   (NOT Logical Operator)

&&   :- All the conditions must be true. if the first expression is false it will not check right side expressions.

||    :- Among multiple conditions, at least one condition must be true. if the first expression is true it will not check right side expressions. 

!      :- It is an inverter, it makes true as a false and false as a true.

Note :- The && and || operator only works with boolean operand so the following code will not compile.

if(5 && 6)
{

}
---------------------------------------------------------------
//*Program on Logical Operator (AND, OR, Not Operator)
//Biggest number among 3 numbers

class Test23
{
public static void main(String args[])
	{
		java.util.Scanner sc = new java.util.Scanner(java.lang.System.in);
		System.out.print("Enter the value of a :");
		int a = sc.nextInt();
		System.out.print("Enter the value of b :");
		int b = sc.nextInt();
		System.out.print("Enter the value of c :");
		int c = sc.nextInt();
		
		int big =0;

		if(a>b && a>c)
			big = a;
		else if(b>a && b>c)
			big = b;
		else
			big = c;
		System.out.println("The big number is :"+big);
	}
}
---------------------------------------------------------------
//OR Operator (At least one condition must be true)
class Test24
{
public static void main(String args[])
	{		
		int a=10;
		int b=5;
		int c=20;
		System.out.println(a>b || a<c); //true
		System.out.println(b>c || a>c); //false
	}
}
-------------------------------------------------------------
// !Operator (not Operator works like an Inverter)
class Test25
{
   public static void main(String args[])
	{	
		System.out.println(!true);
	}
}
--------------------------------------------------------------
Boolean Operators :
-----------------------
Boolean Operators work with boolean values that is true and false. It is used to perform boolean logic upon two boolean expressions.

It is also known as non short circuit. There are two non short circuit logical operators.

&   boolean AND operator  (All  condions must be true but if first expression is false still it will check all right side expressions)

|    boolean OR operator    (At least one condition must be true but if the first condition is true still it will check all right side expression )
--------------------------------------------------------------
//* Boolean Operators
/*
& boolean AND operator 
| boolean OR operator

*/
//Works with boolean values

class Test26 
{
	public static void main(String[] args) 
	{
	      int z = 5;
		  if(++z > 5 || ++z > 6)   //Logical OR
		  {
			  z++;
		  }
		  System.out.println(z);  //7

          System.out.println("................");

		  z = 5;
		  if(++z > 5 | ++z > 6)   //Boolean OR
		  {
			  z++;
		  }
		  System.out.println(z); //8
    }
}
--------------------------------------------------------------
class Test27 
{
	public static void main(String[] args) 
	{
		int z = 5;
		if(++z > 6 & ++z> 6)
		{
			z++;			
		}
		System.out.println(z);
	}
}

---------------------------------------------------------------
30-OCT-23
----------
Bitwise Operator :-
---------------------
In order to work with binary bits java software people has provided Bitwise operator. It also contains 3 operators

& (Bitwise AND) :- Returns true if both the inputs are true.

|  (Bitwise OR) :- Returns false if both the inputs are false
 
^ (Bitwise X-OR) :- Returns true if both the arguments are opposite to each other.

//Bitwise Operator
class Test28 
{
	public static void main(String[] args) 
	{
        System.out.println(true & true); //true
	System.out.println(false | true); //true
	System.out.println(true ^ true); //true
      

		System.out.println(6 & 7);  //6
		System.out.println(6 | 7);  //7
		System.out.println(6 ^ 7); //1
	}
}
---------------------------------------------------------------
Bitwise complement operator :
-----------------------------
-> It will not work with boolean literal.

//Bitwise Complement Operator
public class Test29
{
    public static void main(String args[]) 
	{
		//System.out.println(~ true); Invalid
		System.out.println(~ -8);    
		
    }
}

-----------------------------------------------------------------
Ternary Operator OR Conditional Operator :
--------------------------------------------------
The ternary operator (? :) consists of three operands. It is used to evaluate boolean expressions. The operator decides which value will be assigned to the variable.It is used to reduced the size of if-else condition. 

//Ternary Operator OR Conditional Operator
public class Test30
{
    public static void main(String args[]) 
	{
		int a = 60;
		int b = 59;
		int max = 0;

		max=(a>b)?a:b;  //Type casting
		System.out.println("Max number is :"+max);

    }
}
--------------------------------------------------------------------
public class Test 
{		
    public static void main(String [] args)
	{
	   char ch = 'A';
	   float i = 12;
	   System.out.println(false?i:ch); //65.0  //type casting
	   System.out.println(true?ch:i);  //65.0 //type casting
     
	}
	
}
--------------------------------------------------------------------
Member access Operator Or Dot Operator :
--------------------------------------------------
It is used to access the member of the class so whenever we want to call the member of the class (fields + methods) then we should use dot(.) operator.

We can directly call any static method and static variable from the main method with the help of class name , here object is not required as shown in the program below.

If static variable or static method is present in the same class where main method is availble then we can directly call but if the static variable and static method is available in another class then to call those static members of the class, class name is required.

class Welcome                           
{
   static int x = 100;

   public static void access()
   {
     System.out.println(x);
   }
}
public class Test 
{		
    public static void main(String [] args)
	{
	   System.out.println(Welcome.x);
	   Welcome.access();
	}
	
}
--------------------------------------------------------------
//* new Operator

This Operator is used to create Object. If the member of the class (field + method) is static, object is not required. we can directly call with the help of class name.

On the other hand if the member of the class (variables + method) is not declared as static then it is called non-static member Or instance member , to call the non-static member object is required.

Program :
---------
class Welcome                           
{
   int x = 100;  //instance variable (Non-static field)

   public void access()  //instance method
   {
     System.out.println(x);
   }
}
public class Test 
{		
    public static void main(String [] args)
	{
		Welcome w = new Welcome();
		System.out.println(w.x);
		w.access();
	   
	}
	
}

-------------------------------------------------------------
instanceof operator :-

1)This Operator will return true/false

2) It is used to check a reference variable is holding the particular/corresponding type of Object or not.   

3) It is also a keyword.

4) In between the object reference and class name , we must have some kind of relation (assignment relation) otherwise we will get compilation error.

//* instanceof operator 
public class Test 
{      
	public static void main(String[] args) 
	{
		String str = "India";

		if(str instanceof String)
		{
			System.out.println("str is pointing to String object");
		}
		
        Integer i = 45;
		if(i instanceof Integer)
		{
			System.out.println("i is pointing to Integer object");
		}

        Double d = 90.67;
		if(d instanceof Number)  //IS-A relation between Double and Number class
		{
			System.out.println("d is pointing to Double object");
		}

	}
}
------------------------------------------------------------------
31-10-2023
-----------
Types of variables in java 
---------------------------
-> Based on the data type we can define the variable into two 
   categories 

   a) Primitive type variables
   b) Non-primitive type(Reference type) variable

-> Example of primitive type variables
   int x = 15; [byte, short, int, long, float, double, char and boolean]

-> Example of Reference type variable 
   Customer c = new Customer();

   Here 'c' is reference variable 

   Note :- Any variable if we declare with the help of class then it is called reference variable.

-> Based on the declaration position we can define a varible
   into 4 categories 

   a) Instance variable OR Non-Static field
   b) Class variable OR Static field
   c) Parameter variable
   d) Local variable  [1 more flavour = block level variable]


Program on primitive variable :
--------------------------------
package com.ravi.variable;

class Demo
{
	int x = 120; //Instance variable (non-static field)
	static int y = 200; //class variable (static field)
	
	public void acceptData(int z) //parameter variable
	{
		int localVar = 78;
		System.out.println("Parameter Variable :"+z);
		System.out.println("Local Variable :"+localVar);
	}
	
}

public class Primitive 
{
	public static void main(String[] args) 
	{
      System.out.println("Class Variable :"+Demo.y);	
      Demo d1 = new Demo();
      System.out.println("Instance variable "+d1.x);
      d1.acceptData(999);
	}

}
--------------------------------------------------------------------
Program on reference variable :
--------------------------------
package com.ravi.variable;

import java.util.Scanner;

class Employee
{
	String name = "Vijay"; //Instance variable
	static Scanner sc = new Scanner(System.in); //class variable
	
	public void getEmployeeName()
	{
		System.out.println("Employee Name is :"+name);
	}
	
	
}

public class Reference 
{
	public static void main(String[] args) 
	{
	    Employee e1 = new Employee();  //local variable
	    getEmployeeData(e1);
	}
	
	public static void getEmployeeData(Employee emp) //parameter variable
	{
		emp.getEmployeeName();
	}

}
--------------------------------------------------------------------
What is drawback of if condition :-
---------------------------------------
The major drawback with if condition is, it checks the condition again and again so It increases the burdon over CPU so we introduced switch-case statement to reduce the overhead of the CPU.

switch case :-
----------------
In switch case dpending upon the parameter the appropriate case would be executed otherwise default would be executed.

In this approch we need not to check each and every case, if the appropriate case is available then directly it would be executed.

break keyword is optional here but we can use as per requirement. It will move the control outside of the body of the switch.
-------------------------------------------------------------------
import java.util.*;
public class SwitchDemo 
{
	public static void main(String[] args) 
	{	
		Scanner sc = new Scanner(System.in);
        System.out.print("Please Enter a Character :"); 
		
		char colour = sc.next().toLowerCase().charAt(0);
				
		switch(colour)
		{
		case 'r' : System.out.println("Red") ; break;
		case 'g' : System.out.println("Green");break;
		case 'b' : System.out.println("Blue"); break;
		case 'w' : System.out.println("White"); break;
		default : System.out.println("No colour");
		}
		System.out.println("Completed") ;
	}
}
---------------------------------------------------------------
import java.util.*;
public class SwitchDemo1
{
public static void main(String args[]) 
  {	
		System.out.println("\t\t**Main Menu**\n");	
		System.out.println("\t\t**100 Police**\n");
		System.out.println("\t\t**101 Fire**\n");
		System.out.println("\t\t**102 Ambulance**\n");
		System.out.println("\t\t**139 Railway**\n");
		System.out.println("\t\t**181 Women's Helpline**\n");		

		System.out.print("Enter your choice :");
		Scanner sc = new Scanner(System.in);
		int choice = sc.nextInt();	
		
		switch(choice)
		{
		case 100:
		System.out.println("Police Services");
		break;
		case 101:
		System.out.println("Fire Services");
		break;
		case 102:
		System.out.println("Ambulance Services");
		break;
		case 139:
		System.out.println("Railway Enquiry");
		break;
		case 181:
		System.out.println("Women's Helpline ");
		break;
		default:
		System.out.println("Your choice is wrong");		
		} 
    }
}
----------------------------------------------------------------
import java.util.*;
public class SwitchDemo2 
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter the name of the season :");
		String season = sc.next().toLowerCase();

		switch(season)
		{
			case "summer" :
				 System.out.println("It is summer Season!!");
			 break;

			 case "rainy" :
				 System.out.println("It is Rainy Season!!");
			 break;
		}
	}
}
----------------------------------------------------------------

public class Test2 
{
	public static void main(String[] args) 
	{
		double val = 1;
		switch(val) //Error, can't pass long, float and double
		{
			 case 1:
				 System.out.println("Hello");
			 break;
		} 
	}
}
Note :- In the switch statement we can't pass long, float and double value. 
Strings are allowed from JDK 1.7 version. enums are allowed from java 5 version.
---------------------------------------------------------------
01-11-2023
-----------
Loops in java :
---------------
A loop is nothing but repeatation of statement based on some condition.

In java we have 4 types of loop :
----------------------------------
1) do-while loop (exit control loop)
2) while loop (entry control loop)
3) for loop
4) for each loop 

Program on do - while loop :
----------------------------
public class DoWhile 
{
	public static void main(String[] args) 
	{
        do
        {
			int x = 1;  //block level variable
			System.out.println("x value is :"+x);
			x++;

        }
        while (x<=10); //error x is out of the scope
	}
}

The above program will generate compilation error because here 'x' is a block level variable.
-------------------------------------------------------------------
public class DoWhile 
{
	public static void main(String[] args) 
	{
		int x = 1;  //local variable
        do
        {
			
			System.out.println("x value is :"+x);
			x++;

        }
        while (x<=10); //error x is out of the scope
	}
}
-------------------------------------------------------------------
Program on while loop :
------------------------
public class While 
{
	public static void main(String[] args) 
	{
		int x = 0;
		while(x>=-10)
		{
          System.out.println(x);
		  x--;
		}

	}
}
-------------------------------------------------------------------
//For loop
class For 
{
	public static void main(String[] args) 
	{
		for(int i=1; i<=10; i++)
		{
           if(i==5)
	           break;
		  System.out.println(i);
		}
	}
}
-------------------------------------------------------------------
Nested Loop :
-------------
If we place a loop inside another loop then it is called nested loop.
In nested loop with one value of outer loop the entire inner loop will be rotated.

for(int i=1; i<=5; i++)
{
   for(int j=1; j<=5; j++)
    {
    }
}

i=1  j=1     i=2  j=1 and so on
i=1  j=2
i=1  j=3
i=1  j=4
i=1  j=5
-------------------------------------------------------------------
public class NestedLoop 
{
	public static void main(String[] args) 
	{
		int week = 4;
		int days = 7;
		
		for(int i = 1; i<=week; i++)
		{
			System.out.println("Week :"+i);
			for(int j=1; j<=days; j++)
			{
				System.out.println("Day :"+j);
			}
            System.out.println();
		}
	}
}
----------------------------------------------------------------------
30-12-2023
----------
for each loop :
---------------
It is an enhanced for loop which is used to retrieve the values through the collection data.

It was introduced from java 1.5v.

It is used to fetch the values from collection data one by one so it is known as for each loop.

Program on for-each loop :
--------------------------
package com.ravi.for_each_loop;

import java.util.Arrays;

public class ForEachDemo 
{
	public static void main(String[] args) 
	{
		int []values = {89,67,45,23,15};
		
		Arrays.sort(values);		
		
		for(int value : values)
		{
			System.out.println(value);
		}
		
		String []fruits = {"Mango","Orange","Apple"};
		
		Arrays.sort(fruits);
		
		for(String fruit : fruits)
		{
			System.out.println(fruit);
		}
		
	}

}

Note :- Arrays is a predefined class available in java.util package which contains a predefined static method sort() through which we can sort the data in ascending order.
---------------------------------------------------------------------
Object Orineted Programming (OOPs) :
------------------------------------
What is an Object?
------------------
An object is a physical entity which exist in the real world.
Example :- Pen, Car, Laptop, Mouse, Fan and so on

An Object is having 3 characteristics :

   a) Identification of the Object (Name of the Object)
   b) State of the Object (Data OR Properties OR Variable of Object)
   c) Behavior of the Object (Functionality of the Object)

OOP is a technique through which we can design or develop the programs using class and object.

Writing programs on real life objects is known as Object Oriented Programming.

Here in OOP we concentrate on objects rather than function/method.

Advantages of OOP :
--------------------
1) Modularity  (Dividing the bigger task into smaller task)
2) Reusability (We can reuse the component so many times)
3) Flexibility (Easy to maintain)

Features of OOP :
-----------------
1) Class
2) Object
3) Abstraction
4) Encapsulation
5) Inheritance
6) Polymorphism


What is a class?
-----------------
A class is model/blueprint/template/prototype for creating the object.

A class is a logical entity which does not take any memory.

A class is a user-defined data type which contains data member and member function.

public class Employee
{
    Employee Data (Properties) 
         +
    Employee behavior (Function/Method)
}

A CLASS IS A COMPONENT WHICH IS USED TO DEFINE OBJECT PROPERTIES AND OBJECT BEHAVIOR.

Student.java
-------------
package com.ravi.oop;

public class Student 
{
	String name;  //Object Properties
	String roll;  //Object Properties
	
	//Object behavior
	public void talk()
	{
		System.out.println("Hi My name is "+name+" and my roll is "+roll);
	}
	
	public void writeExam()
	{
	 System.out.println("I am "+name+ " I am writing exam on every thursday");	
	}
   
   public static void main(String[] args)
   {
      Student raj = new Student();      
      //Initializing the Object properties
      raj.name = "Raj Gourav";
      raj.roll = "NIT230001";
      //calling the behavior
      raj.talk();  raj.writeExam();
      
      System.out.println("...........");
      
      Student priya = new Student();
    //Initializing the Object properties
      priya.name = "Priya Kumari";
      priya.roll = "NIT230002";
      //calling the behavior
      priya.talk();  priya.writeExam();
   }
}
---------------------------------------------------------------------
01-01-2024
-----------
Initializing the object property through method :
-------------------------------------------------
package com.ravi.oop_method;

public class Customer 
{
	//Instance variable
	int customerId;
	String customerName;
	
    //Initializing the object properties(instance variable )through method
	public void setCustomerData()
	{
		customerId = 111;
		customerName = "Rohit";
	}
	
	public void getCustomerData()
	{
		System.out.println("Customer Id is :"+customerId);
		System.out.println("Customer Name is :"+customerName);
	}
	

	public static void main(String[] args) 
	{
		Customer c1 = new Customer();
		c1.setCustomerData();
		c1.getCustomerData();
	}

}


Note :- Here we are initializing the object properties through method but in the last program, we were initializing the object properties through object reference.
-------------------------------------------------------------------------
What is Constrcutor? (Introduction Only)
----------------------------------------
If the name of the class and name of the method both are exactly same and it does not contain any return type then it is called Constructor.

Example :
---------
public class Employee
{
   public Employee() //Constructor 
   {
   }
}

Class name and Method name same in the following but it is not constructor :
-----------------------------------------------------------
public class Student
{
  public void Student()  //It is a method, not a constructor
   {
   }
}
------------------------------------------------------------------------
Default constructor added by the compiler :
-------------------------------------------
In Java, whenever we write a class and if don't write any type of constructor in that class then automatically one default constructor will be added by compiler.

*Every java class must contain at-least one constructor either explicitly written by user or implicitly added by compiler.

The access modifier of defualt constructor depends upon class access 
modifier.

Example :
-----------
class Student
{
}

javac Student.java (Compilation) 
javap Student.class(To see the default constructor)

class Student
{
   Student() //default constructor added by the compiler
   {
   }
}

Why compiler is adding default constructor to our class :
---------------------------------------------------------
We have 2 reasons, why compiler is adding default constructor :

1) Without default constructor, Object creation is not possible in java.
2) default constructor will initialize all the instance variables with
   default values.
  
   Data type - Default value
   byte  - 0
   short - 0
   int   - 0
   long  - 0
   float - 0.0
   double - 0.0
   char - (space) '\u0000'
   boolean - false
   String - null
   Object - null (For any class i.e reference variable the default value is null)
------------------------------------------------------------------------
//Program that describes default values will be provided by the default 
  constrauctor.

package com.ravi.oop_method;

public class Student 
{
    int studentId;
    String studentName;
    
    public void showStudentData()
    {
        System.out.println(studentId);
        System.out.println(studentName);
    }    
    
	public static void main(String[] args) 
	{
		Student raj = new Student();
		raj.showStudentData();
	}

}
------------------------------------------------------------------------
02-01-2024
-----------
How to provide userdefined values for our instance variable :
--------------------------------------------------------------
The default constructor added by the compiler will provide the default values for the instance variable, but these default values are not useful for the user so, user will take a separate method setEmployeeData() to re-initialize the instance variable according to his/her choice as shown in the program.

Employee.java
--------------
package com.ravi.oop;

public class Employee 
{
	int eid;
	String ename;
	
	//To perform re-initialization for instance variable
	public void setEmployeeData()
	{
		eid = 111;
		ename = "Ravi";
	}
	
	//To print the value of instance variable
	public void getEmployeeData()
	{
		System.out.println("Employee id is :"+eid);
		System.out.println("Employee Name is :"+ename);
	}
	
	
	public static void main(String[] args) 
	{
		Employee ravi = new Employee();
		ravi.getEmployeeData();  // 0 and null
		
		ravi.setEmployeeData();
                ravi.getEmployeeData(); //111 and Ravi
	}

}
-----------------------------------------------------------------------
Instance variable :
-------------------
If a non static variable declaread outside of a method and inside the class then it is called Instance variable.

As far as its scope is concerned, it is accessible directly anywhere withing the class as well as depends upon the accessibility level.

THE LIFE OF INSTANCE VARIABLE STARTS AT THE TIME OF CREATING THE OBJECT, IT IS THE PART OF THE OBJECT. WE CANNOT THINK ABOUT INSTANCE VARIABLE WITHOUT OBJECT.


public class Main
{
  int x = 100;

  public static void main(String [] args) 
  {
	 System.out.println(x);  //error [cannot use instance variable 
	                                   without object]
  }
}

-----------------------------------------------------------------------
Local variable :
----------------
If a variable is declared inside the method body (not as a method parameter) then it is called Local/Stack/Automatic/Temporary variable.

As far as its scope is concerned, it is accessible within the same method body only. (Not outside of the method)

A local variable must be initialized before use.

We cannot apply any kind of access modifier except final.
-----------------------------------------------------------------------
//Program on instance variable :
package com.ravi.oop;

import java.util.Scanner;

public class Player 
{
    int playerId;
    String playerName;
    double basePrice;
    
    public void setPlayerData()
    {
       Scanner sc = new Scanner(System.in);
       System.out.print("Enter Player id :");
       playerId = sc.nextInt();
       System.out.print("Enter Player name :");
       playerName = sc.nextLine();
       playerName = sc.nextLine();
       System.out.print("Enter Player price :");
       basePrice = sc.nextDouble();
       sc.close();
      
    }
    
    public void getPlayerData()
    {
    	System.out.println("Player id is :"+playerId);
    	System.out.println("Player name is :"+playerName);
    	System.out.println("Player Base price is :"+basePrice);
    }
        
	public static void main(String[] args) 
	{
	   Player p1 = new Player();
	   p1.setPlayerData();
	   p1.getPlayerData();

	}

}
-----------------------------------------------------------------------
Lab Program :
-------------
package com.ravi.oop;

public class Employee 
{
	int employeeId;
	String employeeName;
	double employeeSalary;
	char employeeGrade;
	
	public void setEmployeeData(int eid, String name, double sal)
	{
		employeeId = eid;
		employeeName = name;
		employeeSalary = sal;
	}
	
	public void calculateEmployeeGrade()
	{
		if(employeeSalary >= 100000)
		{
			employeeGrade = 'A';
		}
		else
		{
			employeeGrade = 'B';
		}
	}
	
	
	
	
	public void getEmployeeData()
	{
		System.out.println("Employee id is :"+employeeId);
		System.out.println("Employee name is :"+employeeName);
		System.out.println("Employee salary is :"+employeeSalary);
		System.out.println("Employee grade is :"+employeeGrade);
	}
		
	public static void main(String[] args) 
	{
		Employee e1 = new Employee();
		e1.setEmployeeData(1, "Raj", 1000000);
		e1.calculateEmployeeGrade();
		e1.getEmployeeData();
	}

}
------------------------------------------------------------------------
03-01-2024
-----------
How to write BLC and ELC class using OOP :
------------------------------------------
If we write everything (logic + main method) in a single class then it is not an object oriented approach even we are creating the object and accessing the member. 
We should always separate our BLC class with ELC class so, the reusability of BLC class is possible.

In the below program we are reusing Player class which is BLC class.

3 files :
----------
Player.java
------------
package com.ravi.blc_elc;

//BLC
public class Player 
{
   int playerId;
   String playerName;
   
   public void setPlayerData(int id, String name)
   {
	   playerId = id;
	   playerName = name;
   }
   
   public void getPlayerData()
   {
	System.out.println("Player id is :"+playerId);
	System.out.println("Player Name is :"+playerName);
   }  
   
}


PlayerDemo.java
---------------
package com.ravi.blc_elc;
//ELC
public class PlayerDemo 
{
	public static void main(String[] args) 
	{
		Player p1 = new Player();
		p1.setPlayerData(111, "Virat");
		p1.getPlayerData();
	}

}


Rohit.java
-----------
package com.ravi.blc_elc;

//ELC
public class Rohit 
{
	public static void main(String[] args) 
	{
		Player rohit = new Player();
		rohit.setPlayerData(45, "Rohit Shrama");
		rohit.getPlayerData();

	}

}
-----------------------------------------------------------------------
What is variable shadowing ?
-----------------------------
If the name of instance variable and local variable/parameter variable both are same then inside the method the local variable/parameter variable will hide instance variable that is known as Variable Shadow 
so, always local and parameter variables are having more priority as shown in the program below.

2 files :
----------
Student.java
------------
package com.ravi.variable_shadow;

public class Student 
{
  //Instance variables
  int roll = 111;
  String name = "Raj";
  
  public void accept()
  {
	  //Local Variables
	  int roll = 222;
	  String name = "Rahul";
	  
	  System.out.println(roll); //222
	  System.out.println(name); //Rahul
	  System.out.println(this.roll);///111
	  System.out.println(this.name);//Raj
  }
}

VariableShadow.java
--------------------
package com.ravi.variable_shadow;

//ELC 
public class VariableShadow 
{
	public static void main(String[] args) 
	{
		Student s1 = new Student();
		s1.accept();

	}
}

------------------------------------------------------------------------
this keyword in java :
----------------------
Whenever instance variable name and parameter variable name both are same then at the time of variable initialization our runtime environment gets confused that which one is instance variable and which one is parameter variable (Due to variable shadow). Inside the method body always local and parameter variable is higher priority.

To avoid the above said problem, Java software people introduced "this"
keyword.

this keyword always refers to the current object and instance variables are the part of the object so by using this keyword we can refer to instance variable.

We cannot use this keyword from static area (Static context).

2 Files :
---------
Manager.java
------------
package com.ravi.this_keyword;
//BLC
public class Manager 
{
  int managerId;
  String managerName;
  
  public void setManagerData(int managerId, String managerName)
  {
	  this.managerId = managerId;
	  this.managerName = managerName;	 
  }
  
  public void getManagerData()
  {
	  System.out.println("Manager Id is :"+managerId);
	  System.out.println("Manager Name is :"+managerName);
  } 
  
}





ManagerDemo.java
----------------
package com.ravi.this_keyword;

public class ManagerDemo 
{
	public static void main(String[] args) 
	{
		Manager m1 = new Manager();
		m1.setManagerData(999, "Scott");
		m1.getManagerData();
	}

}
-----------------------------------------------------------------------
Role of instance variable while creating the Object :
-----------------------------------------------------
In Java whenever we create the object, a separate copy of all the instance variables will be created with each and every object.

package com.ravi.instance_var;

public class Test 
{
    int x = 10;
    
	public static void main(String[] args) 
	{
		Test t1 = new Test();
		Test t2 = new Test();
		
		++t1.x;    --t2.x;
		
		System.out.println(t1.x); //11
		System.out.println(t2.x); //9
	}

}
-----------------------------------------------------------------------
Role of static variable while creating the object.
--------------------------------------------------
Whenever we create an object, a single copy of static variable will be created and it is shared by all the objects at the same time so, if any modification is done by any of the object reference then it will be applicable to ALL THE OBJECTS.

package com.ravi.instance_var;

public class Demo 
{
    static int x = 10;
    
	public static void main(String[] args) 
	{
		Demo d1 = new Demo();
		Demo d2 = new Demo();
		
		++d1.x;  --d2.x;
		
		System.out.println(d1.x);
		System.out.println(d2.x);
		
	}

}

Note :- Static variables are used to save the memory.

instance Veriable = Multiple Copies
static variable = Single copy with all the Objects
----------------------------------------------------------------------
When we should declare a variable as an instance variable and when we should declare a variable as a static variable ?

Instance Variable :
-------------------
If the value of the variable is different with respect to object then we should use instance variable.

Static Variable :
-----------------
If the value of the variable is common with respect to all the objects then we should use static variable.

Example :

class Student
{
   int roll;
   String name;
   String address;
   static String collegeName = "NIT";
   static String courseName = "Java";
}
------------------------------------------------------------------------
04-01-2024
----------
How to print object properties by using toString() method :
-----------------------------------------------------------
If we want to print our object properties then we should generate(override) toString() method in our class from Object class.

Now with the help of toString() method we need not write any display kind of method to print the object properties i.e instance variable.

In order to generate the toString() method we need to follow the steps
Right click on the program -> source -> generate toString()

In order to call this toString() method, we need to print the corresponding object reference by using System.out.println() statement.

Manager m = new Manager();
System.out.println(m); //Calling toString() method of Manager class

Employee e = new Employee();
System.out.println(e); //Calling toString() method of Employee class
-----------------------------------------------------------------------
2 Files :
---------
Customer.java
--------------
package com.ravi.printing_object_properties;

//BLC
public class Customer 
{
  int customerId;
  String customerName;
  double customerBill;

  public void setCustomerData(int customerId, String customerName, double customerBill)
  {
	  this.customerId = customerId;
	  this.customerName = customerName;
	  this.customerBill = customerBill;
  }

	@Override
	public String toString() 
	{
		return "Customer [customerId=" + customerId + ", customerName=" + customerName + ", customerBill=" + customerBill
				+ "]";
	}
  
}

CustomerDemo.java
------------------
package com.ravi.printing_object_properties;

//ELC
public class CustomerDemo 
{
	public static void main(String[] args) 
	{
		Customer c1 = new Customer();
		c1.setCustomerData(1, "John", 12000.78);
		System.out.println(c1); //toString() method of Customer
	}                           //class

}
------------------------------------------------------------------------
Data Hiding :
-------------
Data hiding is nothing but declaring our data members with private access modifier so our data will not be accessible from outer world that means no one can access our data directly from  outside of the class.

*We should provide the accessibility of our data through methods so we can perform VALIDATION ON DATA which are coming from outer world.

2 Files :
---------
Customer.java
--------------
package com.ravi.data_hiding;

public class Customer 
{
   private double balance = 1000;  //data hiding
   
   public void deposit(int amount)
   {
	  //Validation of data
	 if(amount<=0)
	 {
		 System.out.println("Amount cannot be deposited");
	 }
	 else
	 {
		 balance = balance + amount;
		 System.out.println("Balance after Deposit :"+balance);
	 }
   }
   public void withdraw(int amount)
   {
	   balance = balance - amount;
	   System.out.println("Balance after withdraw :"+balance);
   }
}


Bank.java
----------
package com.ravi.data_hiding;

public class Bank 
{
	public static void main(String[] args) 
	{
		Customer raj = new Customer();
		raj.deposit(1000);
		raj.withdraw(1000);
	}

}
-----------------------------------------------------------------------
Abstraction :
-------------
Showing the essential details without showing the background details is called abstraction. 

In our real world a user always interacts with functionality of the product but not the data so as a developer we should hide the data from end user by declaring them private.

On the other hand the function must be declared as public so our end user witll interact with the function/method.

In Java we can achieve abstraction by using two ways :

1) Abstract class and abstract methods :- By using abstract class and abstract method we can achieve abstraction 0 to 100%

2) By using interface :- By using interface we can achieve 100% 
   abstraction.

Example :
----------

public abstract class Lift 
{
   abstract void keyOne();
   abstract void keyTwo();
   abstract void keyThree();
   abstract void keyFour();
   abstract void keyFive();   
}

class SteelLift extends Lift
{

	@Override
	void keyOne() {
		// TODO Auto-generated method stub
		
	}

	@Override
	void keyTwo() {
		// TODO Auto-generated method stub
		
	}

	@Override
	void keyThree() {
		// TODO Auto-generated method stub
		
	}

	@Override
	void keyFour() {
		// TODO Auto-generated method stub
		
	}

	@Override
	void keyFive() {
		// TODO Auto-generated method stub
		
	}
	
}
-----------------------------------------------------------------
What is Constructor ?
---------------------
What is the advantage of writing constructor in our class ?
------------------------------------------------------------
If we don't write a constructor in our program then variable initialization and variable re-initialization both are done in two different lines.

If we write constructor in our program then variable initialization and variable re-initialization both are done in the same line i.e at the time of Object creation.

[Diagram 04-jan-24]
------------------------------------------------------------------------
05-01-2024
----------
Constructor :
-------------
If the name of the class and name of the method both are exactly same and, It should not contain any return type then it is called Constructor.

*The main purpose of constructor to initialize the instance variable of the class. (Initializing the object)

Every class must contain at least one constructor either added by compiler (default constructor) or written by user.

The access modifier of default constructor depends upon the access modifier of the class.

Explicitly, a constructor never containing any return type including void also but implicitly it returns current class object (this keyword)
as shown in the program 

package com.nit.interface_demo;

public class Test 
{
	public Test()
	{		
	}
	
	public String accept()
	{
		System.out.println("Accept");
		return "india";
	}

	public static void main(String[] args) 
	{
	   String x =  new Test().accept();	
	   System.out.println(x);
	}

}

A constructor may contain return keyword but not return keyword with value.

public class Test 
{
	public Test()
	{
	  return ;   //valid	
	}

	public static void main(String[] args) 
	{
		 Test t1 = new Test();
	}
}

A constructor is automatically called and executed at the time of creating the object.

public class Demo
{
   public Demo()
    {
    }
}

Demo d1 = new Demo(); //Here only Constructor will only
     d1.Demo(); //Not required
   
A constructor is called once per object that means if we create two objects then constructor will be called 2 times.
-----------------------------------------------------------------------
Types Of Constructor :
-----------------------
Constructors are of 3 types :

1) Default Constructor.
2) No Argument OR Parameter less OR Non Parameterized OR Zero Argument
   Constrcutor.
3) Parameterized Constructor.


1) Default Constructor :
------------------------
The constructor added by compiler to help java programmer to craete the object is called Default constructor.

Student.java
-------------
public class Student
{
}

javac Student.java (Compilation)

Student.class
-------------
public class Student
{
   public Student() //default Constructor added by compiler
   {
   }
}
-----------------------------------------------------------------------
2) No Argument Constructor :
----------------------------
A constructor written by user without parameter is called as No Argument constructor.
Default constructor and no argument constructor looks like same but default menas added by compiler and no argument written by user.

public class Employee
{
   private int employeeNumber;
   Employee() //No Argument Constructor
   {
     employeeNumber = 123;
   }
}

In this no argument approach, all the objects will be initialized with same value so it is not a recommended way because all objects must contain different value.

Person.java
------------
package com.ravi.constructor;

public class Person 
{
  private int personId;
  private String personName;
  
  public Person() //No Argument Constructor
  {
	  super();
	  personId = 111;
	  personName = "Scott";
  }

	@Override
	public String toString() {
		return "Person [personId=" + personId + ", personName=" + personName + "]";
	}  
  
}


NoArgumentConstructor.java
--------------------------
package com.ravi.constructor;

public class NoArgumentConstructor {

	public static void main(String[] args) 
	{
		Person scott = new Person();
		System.out.println(scott);
		
		Person smith = new Person();
		System.out.println(smith);

	}

}

In the above program we have two objects scott and smith but both the objects are initialized with scott data which is not recommended so we 
introduced parameterized constructor.
-----------------------------------------------------------------------
Parameterized Constructor :
---------------------------
If we pass one or more argument to the constructor then it is called parameterized constructor. By using parameterized constructor we can initialize all our objects with different value.

public class Customer
{
   int cid;
   String cname;

   public Customer(int cid, String cname) //Parameterized Constructor
   {
    this.cid = cid;
    this.cname = cname;
   }
}

2 Files :
-----------
Dog.java
--------
package com.ravi.parameterized_constructor;

public class Dog 
{
  private String dogName;
  private double dogHeight;
  private int dogAge;
  private String dogColor;
  
	public Dog(String dogName, double dogHeight, int dogAge, String dogColor) {
		super();
		this.dogName = dogName;
		this.dogHeight = dogHeight;
		this.dogAge = dogAge;
		this.dogColor = dogColor;
	}

	@Override
	public String toString() {
		return "Dog [dogName=" + dogName + ", dogHeight=" + dogHeight + ", dogAge=" + dogAge + ", dogColor=" + dogColor
				+ "]";
	} 
  
}

ParameterizedConstructor.java
------------------------------
package com.ravi.parameterized_constructor;

public class ParameterizedConstructor {

	public static void main(String[] args) 
	{
	  Dog tiger = new Dog("Tiger", 3.4, 5, "Grey");
	  System.out.println(tiger);
	  
	  Dog tommy = new Dog("Tommy", 2.4, 3, "Black");
	  System.out.println(tommy);

	}

}
----------------------------------------------------------------------
How to write setter and getter in java :
----------------------------------------
Setter :- To modify the existing object data.

getter :- To read the private data outside of the class.

public class Student 
{
    private int roll;
    private String name;  

   public void setRoll(int roll)
   {
     this.roll = roll;
   }

   public int getRoll()
   {
      return this.roll;
   }

}
----------------------------------------------------------------------
Program on setter and getter :
-------------------------------
2 Files :
Student.java
------------
package com.ravi.parameterized_constructor;

public class Student 
{
    private int roll;

	public int getRoll() //getter
	{
		return this.roll;
	}
	
	public void setRoll(int roll) //setter
	{
		this.roll = roll;
	}
   
   
}

SetterAndGetter.java
--------------------
package com.ravi.parameterized_constructor;

public class SetterAndGetter {

	public static void main(String[] args) 
	{
		Student s1 = new Student();
		s1.setRoll(111);
		System.out.println("Roll Number is :"+s1.getRoll());
	}

}
----------------------------------------------------------------------
06-01-2024
----------
Program that describes the use of Setter and Getter to define the type of Employee.

2 Files :
---------
Employee.java
--------------
package com.nit.stter_getter;

public class Employee 
{
  private double empSalary;

  //getter
  public double getEmpSalary() 
  {
		return empSalary;
  }
	
   //setter
   public void setEmpSalary(double empSalary) 
   {
		this.empSalary = empSalary;
   }  
}


TypeOfEmployee.java
--------------------
package com.nit.stter_getter;

import java.util.Scanner;

//ELC
public class TypeOfEmployee 
{
	public static void main(String[] args)
	{
		Employee e1 = new Employee();
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter the Employee Salary :");
		double sal = sc.nextDouble();
		
		e1.setEmpSalary(sal);
		
		double empSalary =  e1.getEmpSalary();
		
		if(empSalary >=40000)
		{
			System.out.println("You are a developer...");
		}
		else if(empSalary >=25000)
		{
			System.out.println("You are a Designer...");
		}
		else
		{
			System.out.println("You are a Tester...");
		}
	}
}
-------------------------------------------------------------------------
* Encapsulation :
---------------
Binding the data member with its associated function/method in a single unit is called encapsulation.

In other words we can say "Grouping the related things together is called Encapsulation". [Laptop]

In encapsulation data must be tightly coupled with associated function.

It provides us security because we can't access the data directly, data must be accessible via methods only.

We can achieve encapsulation in our program by using following

a) Declare all the data members as private (Tightly encapsulated class)
b) Define getters and setters for each instance variable to perform read and write operation.

Note :
-----
If we declare all the instance variables with private access modifier then it is called tightly encapsulated class.

On the other hand if some variables are declared with private access modifier and other variables are not declared with private access modifier then it is called loosely encapsulated class.
-------------------------------------------------------------------------
HAS-A Relation :
----------------
If we take the class name as a property to another class then it is called HAS-A relation.

Example 1 :
------------
class PanCard
{
}

class BankCustomer
{
  private PanCard panCard;
}

Example 2 :
------------
class Account
{

}
class Customer
{
   private Account account;
}
-------------------------------------------------------------------------
3 files :
---------
Student.java
------------
package com.ravi.has_relation;
//BLC
public class Student 
{
   private int studentId;
   private String studentName;
   private double studentFees;
   
  
   
	public Student(int studentId, String studentName, double studentFees) {
		super();
		this.studentId = studentId;
		this.studentName = studentName;
		this.studentFees = studentFees;
	}

	@Override
	public String toString() {
		return "Student [studentId=" + studentId + ", studentName=" + studentName + ", studentFees=" + studentFees
				+ "]";
	}
   
	
	
	
	
   
}

College.java
------------
package com.ravi.has_relation;

public class College 
{
  private String collegeName;
  private String collegeLocation;
  private Student student;   //HAS-A Relation
  
	public College(String collegeName, String collegeLocation, Student student) //student = s1
	{	    	
		super();
		this.collegeName = collegeName;
		this.collegeLocation = collegeLocation;
		this.student = student;	
	}

	@Override
	public String toString() {
		return "College [collegeName=" + collegeName + ", collegeLocation=" + collegeLocation + ", student=" + student
				+ "]";
	}
  
    
}


Main.java
---------
package com.ravi.has_relation;

public class Main 
{
	public static void main(String[] args) 
	{
		Student s1 = new Student(111,"Raj",23890);	
		
		College c1 = new College("NIT", "Hyderabad", s1);
		System.out.println(c1);
	}

}
-------------------------------------------------------------------------
Another program on HAS-A relation :
------------------------------------
Company.java
-------------
package com.ravi.has_relation;

public class Company 
{
  private String companyName;
  private String companyLocation;
  
	public Company(String companyName, String companyLocation) {
		super();
		this.companyName = companyName;
		this.companyLocation = companyLocation;
	}

	@Override
	public String toString() {
		return "Company [companyName=" + companyName + ", companyLocation=" + companyLocation + "]";
	}

	
  
  
}

Employee.java
--------------
package com.ravi.has_relation;

public class Employee 
{
  private int employeeId;
  private String employeeName;
  private double employeeSalary;
  private Company company;  //HAS-A Relation
  
	public Employee(int employeeId, String employeeName, double employeeSalary, Company company) //company = comp
	{
		super();
		this.employeeId = employeeId;
		this.employeeName = employeeName;
		this.employeeSalary = employeeSalary;
		this.company = company;	
		
	}

	@Override
	public String toString() {
		return "Employee [employeeId=" + employeeId + ", employeeName=" + employeeName + ", employeeSalary="
				+ employeeSalary + ", company=" + company + "]";
	}  
  
}

ELC.java
---------
package com.ravi.has_relation;

public class ELC {

	public static void main(String[] args) 
	{
		Company comp = new Company("TCS", "Hydearabad");	
		
		Employee e1 = new Employee(1, "Scott", 40000, comp);
		System.out.println(e1);

		Employee e2 = new Employee(2, "John", 40000, comp);
		System.out.println(e2);
	}
}
-----------------------------------------------------------------------
07-01-2024
----------
Passing an Object reference to the constructor :
-------------------------------------------------
According to our application requirement we can pass object reference 
to the constructor. The main purpose of passing an object reference to the constructor TO COPY THE CONTENT OF ONE OBJECT TO ANOTHER OBJECT.

class Student
{
  int x,y;
  
  public Student()
  {
  }
  public Student(int x, int y)
  {
  }
  public Student(Student st)  //PASSING AN OBJECT REFERENCE 
  {
  }

}
----------------------------------------------------------------------
Program which describes how to copy the Employee data into Manager data 
(Passing an object reference to the constructor)

3 Files :
---------
Employee.java
-------------
package com.ravi.copy_constructor;

public class Employee 
{
   private int employeeId;
   private String employeeName;
   
	public Employee(int employeeId, String employeeName) 
	{
		super();
		this.employeeId = employeeId;
		this.employeeName = employeeName;
	}

	public int getEmployeeId() {
		return employeeId;
	}

	public String getEmployeeName() {
		return employeeName;
	}
	
}

Manager.java
-------------
package com.ravi.copy_constructor;

public class Manager 
{
  private int managerId;
  private String managerName;
  
  public Manager(Employee emp)  //emp = e1
  {
	 managerId = emp.getEmployeeId();
	 managerName = emp.getEmployeeName();
  }

	@Override
	public String toString() {
		return "Manager [managerId=" + managerId + ", managerName=" + managerName + "]";
	}
  
}

CopyConstructor.java
--------------------

package com.ravi.copy_constructor;

public class CopyConstructor 
{
	public static void main(String[] args) 
	{
		Employee e1 = new Employee(111, "Scott");
		
		Manager m1 = new Manager(e1);
		System.out.println(m1);
	}

}
------------------------------------------------------------------------
This program describes how to copy the same object content to another 
(Same Player object to another Player object)

Player.java
-----------
package com.ravi.copy_constructor;

public class Player 
{
  private String name1, name2;
  
  public Player(String name1, String name2)
  {
	  this.name1 = name1;
	  this.name2 = name2;
  }
  
  public Player(Player p)  // p = p1
  {
	  this.name1 = p.name2;
	  this.name2 = p.name1;
  }

@Override
public String toString() {
	return "Player [name1=" + name1 + ", name2=" + name2 + "]";
}
  
  
  
}

Main.java
---------
package com.ravi.copy_constructor;

public class Main 
{
	public static void main(String[] args) 
	{
		Player p1 = new Player("Rohit","Virat");
		System.out.println(p1);
		
		Player p2 = new Player(p1);
		System.out.println(p2);
	}
}
---------------------------------------------------------------------
Lab Program :
-------------
The payroll system of an organization involves calculating the gross salary of each type of employee and the tax applicable to each. 

Note : Take parameterized constructor to initialize all fields. 

Create the following BLC classes as described below.

Class Employee
Fields: employeeId: int, employeeName : String, basicSalary : double, HRAPer : double, DAPer : double

Public Method: calculateGrossSalary() - returns a double
Calculate the gross salary as : basicSalary +HRAPer +DAPer

Class Manager
Fields: managerId: int, managerName : String, basicSalary : double, HRAPer : double,DAPer : double, projectAllowance: double

public Method: calculateGrossSalary() - returns a double
Calculate the gross salary as : basicSalary +HRAPer +DAPer + projectAllowance

Class Trainer
Fields: trainerId: int, trainerName : String, basicSalary : double, HRAPer : double,DAPer : double, batchCount: int, perkPerBatch: double

public Method: calculateGrossSalary() - returns a double
Calculate the gross salary as : basicSalary +HRAPer +DAPer +(batchCount * perkPerBatch)

Class Sourcing
Fields: sourceId: int, sourcaName : String, basicSalary : double, HRAPer : double,DAPer : double, enrollmentTarget: int, enrollmentReached: int, perkPerEnrollment: double
Public Method: calculateGrossSalary() - returns a double

Calculate the gross salary as : basicSalary +HRAPer +DAPer +(((enrollmentReached/enrollmentTarget)*100)*perkPerEnrollment)


Class TaxUtil
Fields: None
Public Methods:
calculateTax(Employee e) - returns a double
calculateTax(Manager m) - returns a double
calculateTax(Trainer t) - returns a double
calculateTax(Sourcing s) - returns a double

Tax Calculation Logic: If gross salary is greater than 50000 tax is 20% else, tax is 5%.

An ELC class TaxCalculation is given to you with the main Method. Use this class to test your solution.

6 files :
---------
Employee.java
--------------
package com.nit.lab;

public class Employee 
{
  private int employeeId;
  private String employeeName;
  private double basicSalary;
  private double HRAPer;
  private double DAPer;
  
  public Employee(int employeeId, String employeeName, double basicSalary, double hRAPer, double dAPer) {
	super();
	this.employeeId = employeeId;
	this.employeeName = employeeName;
	this.basicSalary = basicSalary;
	HRAPer = hRAPer;
	DAPer = dAPer;
}



public double calculateGrossSalary()
  {
	  return basicSalary +HRAPer +DAPer;
  }
}


Manager.java
-------------
package com.nit.lab;

public class Manager 
{
  private int managerId;
  private String managerName;
  private double basicSalary;
  private double HRAPer;
  private double DAPer;
  private double  projectAllowance;
  
  
  
  public Manager(int managerId, String managerName, double basicSalary, double hRAPer, double dAPer,
		double projectAllowance) {
	super();
	this.managerId = managerId;
	this.managerName = managerName;
	this.basicSalary = basicSalary;
	HRAPer = hRAPer;
	DAPer = dAPer;
	this.projectAllowance = projectAllowance;
}

public double calculateGrossSalary()
  {
	  return basicSalary +HRAPer +DAPer + projectAllowance;
  }

}


Trainer.java
-------------
package com.nit.lab;

public class Trainer 
{
	  private int trainerId;
	  private String trainerName;
	  private double basicSalary;
	  private double HRAPer;
	  private double DAPer;
	  private int batchCount;
	  private double perkPerBatch;
	public Trainer(int trainerId, String trainerName, double basicSalary, double hRAPer, double dAPer, int batchCount,
			double perkPerBatch) {
		super();
		this.trainerId = trainerId;
		this.trainerName = trainerName;
		this.basicSalary = basicSalary;
		HRAPer = hRAPer;
		DAPer = dAPer;
		this.batchCount = batchCount;
		this.perkPerBatch = perkPerBatch;
	}
	 
	public double calculateGrossSalary()
	  {
		  return basicSalary +HRAPer +DAPer +(batchCount * perkPerBatch);
	  }
	  
	  
}

Sourcing.java
--------------
package com.nit.lab;

public class Sourcing 
{
	private int employeeId;
	  private String employeeName;
	  private double basicSalary;
	  private double HRAPer;
	  private double DAPer;
	  private int enrollmentTarget;
	  private int enrollmentReached;
	  private double perkPerEnrollment;
	  
	  
	  
	  public Sourcing(int employeeId, String employeeName, double basicSalary, double hRAPer, double dAPer,
			int enrollmentTarget, int enrollmentReached, double perkPerEnrollment) {
		super();
		this.employeeId = employeeId;
		this.employeeName = employeeName;
		this.basicSalary = basicSalary;
		HRAPer = hRAPer;
		DAPer = dAPer;
		this.enrollmentTarget = enrollmentTarget;
		this.enrollmentReached = enrollmentReached;
		this.perkPerEnrollment = perkPerEnrollment;
	}



	public double calculateGrossSalary()
	  {
		 return basicSalary +HRAPer +DAPer +(((enrollmentReached/enrollmentTarget)*100)*perkPerEnrollment);

	  }
}

TaxUtil.java
------------
package com.nit.lab;

public class TaxUtil 
{
  public static double calculateTax(Employee e)
  {
	  if(e.calculateGrossSalary() > 50000)
	  {
		  return e.calculateGrossSalary()*0.20;
	  }
	  else
	  {
		  return e.calculateGrossSalary()*0.05;
	  }
  }
  public static double calculateTax(Manager m)
  {
	  if(m.calculateGrossSalary() > 50000)
	  {
		  return m.calculateGrossSalary()*0.20;
	  }
	  else
	  {
		  return m.calculateGrossSalary()*0.05;
	  }
  }
  public static double calculateTax(Trainer t)
  {
	  
	  if(t.calculateGrossSalary() > 50000)
	  {
		  return t.calculateGrossSalary()*0.20;
	  }
	  else
	  {
		  return t.calculateGrossSalary()*0.05;
	  }
  }
  public static double calculateTax(Sourcing s)
  {
	  if(s.calculateGrossSalary() > 50000)
	  {
		  return s.calculateGrossSalary()*0.20;
	  }
	  else
	  {
		  return s.calculateGrossSalary()*0.05;
	  }
  }	

}


TaxCalculation.java
-------------------
package com.nit.lab;

public class TaxCalculation {

	public static void main(String[] args) 
	{
		Employee e1 = new Employee(1, "John", 50000, 1000, 550);		
		double tax = TaxUtil.calculateTax(e1);
		System.out.println(tax);
		
		Manager m1 = new Manager(2, "John", 40000, 2200, 1200, 1500);
		tax = TaxUtil.calculateTax(m1);
		System.out.println(tax);
	}

}
-----------------------------------------------------------------------
08-01-2024
----------
Program on Setter :
--------------------
2 Files:

Course.java
------------
package com.ravi.setter;

public class Course 
{
  private String subjectName;
  private String facultyName;
  private int courseDuration;
  
	public Course(String subjectName, String facultyName, int courseDuration) {
		super();
		this.subjectName = subjectName;
		this.facultyName = facultyName;
		this.courseDuration = courseDuration;
	}

	@Override
	public String toString() {
		return "Course [subjectName=" + subjectName + ", facultyName=" + facultyName + ", courseDuration="
				+ courseDuration + "]";
	}

	public void setSubjectName(String subjectName) {
		this.subjectName = subjectName;
	}

	public void setFacultyName(String facultyName) {
		this.facultyName = facultyName;
	}

	public void setCourseDuration(int courseDuration) {
		this.courseDuration = courseDuration;
	}

	public String getSubjectName() {
		return subjectName;
	}
  
}


SetterExample.java
------------------
package com.ravi.setter;

public class SetterExample {

	public static void main(String[] args) 
	{
		Course javaPlacement = new Course("C", "Kishore Sir", 45);
		System.out.println(javaPlacement);
		
		if(javaPlacement.getSubjectName().equals("C"))
		{
			System.out.println("Ready for Core Java");
		}
		
		javaPlacement.setSubjectName("Core Java");
		javaPlacement.setFacultyName("Ravi");
		javaPlacement.setCourseDuration(90);
		System.out.println(javaPlacement);
		
		if(javaPlacement.getSubjectName().equals("Core Java"))
		{
			System.out.println("Be ready for Adv Java");
		}
		

	}

}
-----------------------------------------------------------------------
Method return as class name :
-----------------------------
We can take following return types for a method in Java :

1) void 

2) we can take all the primitive data types like byte, short and so on

3) we can take class name as return type of the method

   public class Test
   {
      int x;
      public Test(int x)
      {
         this.x = x;
      }
      
      public Test accept()
      {
         return new Test(12);
      }
   }

4) We can also take interface as a method return type.
-----------------------------------------------------------------------
//Program that describes how to return an object (instance variables) from a method 

Employee.java
--------------
package com.ravi.class_as_method_return_type;

import java.util.Scanner;

public class Employee 
{
  private int employeeId;  //1
  private String employeeName; //scott
  private double employeeSalary; //12000
  
  public Employee(int employeeId, String employeeName, double employeeSalary) 
	{
		super();
		this.employeeId = employeeId;
		this.employeeName = employeeName;
		this.employeeSalary = employeeSalary;
	} 
  
	
  public static Employee getEmployeeObject()
  {
    Scanner sc = new Scanner(System.in);
    System.out.print("Enter Id :");
    int id = sc.nextInt();
    System.out.print("Enter Name :");
    String name = sc.nextLine();
    name = sc.nextLine();
    
    System.out.print("Enter Salary :");
    double sal = sc.nextDouble();
         
    Employee e1 = new Employee(id, name, sal);
    return e1;	
  }


	@Override
	public String toString() {
		return "Employee [employeeId=" + employeeId + ", employeeName=" + employeeName + ", employeeSalary="
				+ employeeSalary + "]";
	} 
}


EmployeeDemo.java
------------------
package com.ravi.class_as_method_return_type;

import java.util.Scanner;

public class EmployeeDemo 
{
	public static void main(String[] args) 
	{
	   Scanner sc = new Scanner(System.in);
	   
	   System.out.print("How many objects you want ?");	   
	   int numberOfObject = sc.nextInt();
	   
	   for(int i=1; i<=numberOfObject; i++)
	   {
		 Employee emp = Employee.getEmployeeObject();
		 System.out.println(emp);
	   }
	}

}
----------------------------------------------------------------------
//Program that describes how to return an object (instance variables) from a method 

Book.java
---------
package com.ravi.class_as_method_return_type;

import java.util.Scanner;

public class Book 
{
  private String bookName;
  private String authorName;
  
	public Book(String bookName, String authorName) 
	{
		super();
		this.bookName = bookName;
		this.authorName = authorName;
	}
	
	public static Book getBookObject()
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter Book Name :");
		String bName = sc.nextLine();
		System.out.print("Enter Author Name :");
		String author = sc.nextLine();
		return new Book(bName,author);
		
	}

	@Override
	public String toString() {
		return "Book [bookName=" + bookName + ", authorName=" + authorName + "]";
	}
  
	
  
  
}


BookDemo.java
--------------
package com.ravi.class_as_method_return_type;

import java.util.Scanner;

public class BookDemo {

	public static void main(String[] args) 
	{		
		  Book b =  Book.getBookObject();
		  System.out.println(b);
		
	}
}
-----------------------------------------------------------------------
09-01-2024
-----------
Lab Program :(Method return type as a class + Passing Object ref)
------------------------------------------------------------------
A class called Customer is given to you. 

The task is to find the Applicable Credit card Type and create CardType object based on the Credit Points of a customer.

Define the following for the class.

Attributes : 
	customerName : String,private
	creditPoints: int, private

Constructor :
	parameterizedConstructor: for both cusotmerName & creditPoints in that order.

Methods :
	Name of the method : getCreditPoints
	Return Type : int
	Modifier   : public 
	Task : This method must return creditPoints
	
	Name of the method : toString, Override it, 
	Return type : String 
	Task :  return only customerName from this.

Create another class called CardType. Define the following for the class

Attributes :
	customer : Customer, private
	cardType : String, private
Constructor :
	parameterizedConstructor: for customer and cardType attributes in that order

Methods :
	Name of the method : toString  Override this.  
	Return type : String
	Modifier : public
	Task :  Return the string in the following format.
		The Customer 'Rajeev' Is Eligible For 'Gold' Card.


Create One more class by name CardsOnOffer and define the following for the class.

Method : 
	Name Of the method : getOfferedCard 
	Return type : CardType
	Modifiers: public,static
	Arguments: Customer object

	Task : 	Create and return a CardType object after logically finding cardType from creditPoints as per the below rules.
		creditPoints	    cardType
		100  - 500	-   Silver
		501  - 1000	-   Gold
		1000 >		-   Platinum
		< 100		-   EMI
		
Create  an ELC class which contains Main method to test the working of the above.

Customer.java
--------------
package com.ravi.lab;

public class Customer 
{
  private String customerName;
  private int creditPoints;
  public Customer(String customerName, int creditPoints) 
  {
		super();
		this.customerName = customerName;
		this.creditPoints = creditPoints;
  }
  
  public int getCreditPoints()
  {
	  return this.creditPoints;
  }

	@Override
	public String toString() 
	{
		return this.customerName;
	}  
}

CardType.java
-------------
package com.ravi.lab;

public class CardType 
{
   private Customer customer; //HAS-A Relation
   private String cardType;
   
	public CardType(Customer customer, String cardType) 
	{
		super();
		this.customer = customer;
		this.cardType = cardType;
	}

	@Override
	public String toString() 
	{
		//The Customer 'Rajeev' Is Eligible For 'Gold' Card.
		
		return "The Customer '"+this.customer+"' Is Eligible for '"+this.cardType+"' Card";
	}
	
   
}

CardsOnOffer.java
-----------------
package com.ravi.lab;

public class CardsOnOffer 
{
	public static CardType getOfferedCard(Customer obj)
	{
		int creditPoint = obj.getCreditPoints();
		
		if(creditPoint >=100 && creditPoint <=500)
		{
			return new CardType(obj, "Silver");
		}
		else if(creditPoint > 500 && creditPoint <=1000)
		{
				return new CardType(obj, "Gold");
		}
		else if(creditPoint > 1000)
		{
				return new CardType(obj, "Platinum");
		}
		else
		{
			return new CardType(obj, "EMI");
		}
	}
	

}




CreditCard.java
----------------
package com.ravi.lab;

import java.util.Scanner;

public class CreditCard {

	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter Customer Name :");
		String name = sc.nextLine();
		
		System.out.print("Enter Customer Credit Points :");
		int cp = sc.nextInt();
		
		Customer cust = new Customer(name, cp);
		
		CardType card = CardsOnOffer.getOfferedCard(cust);
		System.out.println(card);

	}
}
----------------------------------------------------------------
private constructor in java :
------------------------------
According to our requirement we can apply all private, default, protected and public access modifier on constructor.

If we declare a constructor with private access modifier then we can create single object for that class as shown in the program.

Test.java
---------
class Test
{
	private Test()
	{
		System.out.println("Private Constructor");
	}

	public static void main(String [] args)
	{
        new Test(); //Anonymous OR Nameless object
	}
}

We should declare a constructor with private access modifier due to the 
following two reasons :

1) If we want to create single object for that class (Singleton class)
2) If we want to declare all the methods as a static method inside the 
   class.

Assignment :
------------
Create a class Calculate which contains all static methods with private constructor.
Execute all the static methods with the help of class name.

Note :- A constructor cannot be declared with static and final modifier.
-----------------------------------------------------------------------
What is Instance OR non-static block in Java ?
----------------------------------------------
//Instance Block OR Non-static block

{

}

It is a special block in java which is executed automatically whenever an object is created. [Depends upon object creation]

It will be automatically placed in the 2nd line of the constructor, if it is available in the class.

The main purpose of instance block to initialize the instance variable of the class before constructor body execution so, it is also known as instance initializer.

Always the instance block will be executed before the constructor body execution.

If we have n number of instance block available in the class then it would be executed according to the order.

If we write the instance block in the body of the constructor then compiler will not placed in the 2nd line of Constructor. 

-----------------------------------------------------------------------
Program to show instance blocks are executed before the constructor body

InstanceBlockDemo1.java
-------------------------

package com.ravi;

class Test
{
	public Test()
	{
		System.out.println("No Argument constructor!!!");
	}
	
	{
		System.out.println("Instance block");
	}	
}

public class InstanceBlockDemo1 
{
	public static void main(String[] args) 
	{
		new Test();
		System.out.println("...............");
		new Test();

	}

}
------------------------------------------------------------------------
Program to show instance blocks are executed according to the order.

package com.ravi;

class Demo
{
	int x;
	public Demo()
	{
		System.out.println("x value is :"+x);
	}
	
	{
		x = 100;
		System.out.println(x);
	}
	
	{
		x = 200;
		System.out.println(x);
	}
	
	{
		x = 300;
		System.out.println(x);
	}
	
}


public class InstanceBlockDemo2 
{
	public static void main(String[] args) 
	{
		new Demo();

	}

}
------------------------------------------------------------------------
Program to show, if a user has defined instance block inside the constructor body then it will be executed as it is (Compiler will not perform any action)

package com.ravi;

class Foo
{
	Foo()
	{
		
		System.out.println("Constructor");
		
		{
			System.out.println("Instance block");
		}
	}
}


public class InstanceBlock3 {

	public static void main(String[] args) 
	{
		new Foo();

	}

}
------------------------------------------------------------------------
10-01-2024
-----------
4 files :
---------
Student.java
------------
package com.ravi.object_ref_method;

public class Student 
{
  private String name;
  private int marks;
  
  public Student(String name, int marks) 
  {
		super();
		this.name = name;
		this.marks = marks;
  }

	@Override
	public String toString() 
	{
		return this.name;
	}

	public String getName() {
		return name;
	}

	public int getMarks() {
		return marks;
	} 
	
	
  
}

StudentGrade.java
------------------
package com.ravi.object_ref_method;

public class StudentGrade 
{
  private Student student; //HAS-A 
  private char studentGrade;
  
	public StudentGrade(Student student, char studentGrade) 
	{
		super();
		this.student = student;
		this.studentGrade = studentGrade;
	}

	@Override
	public String toString() 
	{
	return "Student '"+this.student+"' has '"+this.studentGrade+"' Grade!";
	} 
  
}

CalculateStudentGrade.java
--------------------------
package com.ravi.object_ref_method;

public class CalculateStudentGrade 
{
   public static StudentGrade calculateGrade(Student s1)
   {
	   int marks = s1.getMarks();
	   
	   if(marks > 90)
	   {
		   return new StudentGrade(s1, 'A');
	   }
	   else if(marks > 75)
	   {
		   return new StudentGrade(s1, 'B');
	   }
	   else if(marks > 60)
	   {
		   return new StudentGrade(s1, 'C');
	   }
	   else
	   {
		   return new StudentGrade(s1, 'D');
	   }
   }
}


Main.java
---------
package com.ravi.object_ref_method;

import java.util.Scanner;

public class Main {

	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter Student Name :");
		String name = sc.nextLine();
		System.out.print("Enter Student Marks :");
		int marks = sc.nextInt();
		
		Student s1 = new Student(name, marks);
		
		StudentGrade grade = CalculateStudentGrade.calculateGrade(s1);
		System.out.println(grade);

	}

}
------------------------------------------------------------------------
What is Garbage Collector in Java ?
------------------------------------
In Java the programmer is only responsible to allocate the memory by using new keyword and constructor, memory de-allocation is not the responsibility of the programmer. It is automatically done by garbage collector.

As we know all the objects are created inside the HEAP Memory where as all our methods are executed inside stack memory.

The main purpose of GC(Garbage Collector) to scan the heap memory, identify which objects are eligible for GC and which objects are not eligible. (An object is eligible for GC if that object does not contain any references)


How many ways we can make an object eligible for GC :
-----------------------------------------------------
There are 3 ways we can make an object eligible for GC.

1) Assigning null literal to reference variable :
   Employee e1 = new Employee(111,"Ravi");
            e1 = null;

2) Creating an Object inside a method :

   public void createObject()
   {
      Employee e2 = new Employee();
   }
Here we are creating Employee object inside the method so, once the method execution is over then e2 will be deleted from the Stack Frame and the employee object will become eligible for GC.

3) Assigning new Object to the old existing reference variable:
   
   Employee e3 = new Employee();
   e3 = new Employee();

Earlier e3 variable was poting to Employee object after that a new Employee Object is created which is pointing to another memory location so the first object is eligible for GC.
------------------------------------------------------------------------
11-01-2024
----------
HEAP and STACK Diagram 
----------------------

HEAP and STACK Diagram for CustomerDemo.java
---------------------------------------------
class Customer
{
	private String name;
	private int id;

	public Customer(String name , int id) //constructor
	{
		this.name=name;
		this.id=id;
	}

	public void setId(int id)  //setter  
	{
		this.id=id;
	}

	public int getId() //getter
	{
		return id;
	}
}

public class CustomerDemo
{
	public static void main(String[] args) 
	{
		int val=100;

		Customer c = new Customer("Ravi",2);

        m1(c);
		
		//GC [1 object i.e 3000x is eligible for GC]

		System.out.println(c.getId());
	}

	public static void m1(Customer cust)
	{
		cust.setId(5);

	    cust = new Customer("Rahul",7);

		cust.setId(9);
		System.out.println(cust.getId());
	}
}  

// 9 5

Note :- String objects are not eligible for GC.
------------------------------------------------------------------------
HEAP and STACK diagram for Sample.java
---------------------------------------
public class Sample
{	
	private Integer i1 = 900;

	public static void main(String[] args) 
	{
		Sample s1 = new Sample();
		
		Sample s2 = new Sample();       

	    Sample s3 = modify(s2);   

		s1 = null;

        //GC [4 objects are eligible 1000x, 2000x, 5000x and 6000x]

		System.out.println(s2.i1);		
	}
    public static Sample modify(Sample s)
	{
		s.i1=9;
		s = new Sample();
		s.i1= 20;  
        System.out.println(s.i1);
		s=null;
		return s;
	}
}

// 20 9
------------------------------------------------------------------------
//HEAP and STACK Diagram for Test.java
--------------------------------------
public class Test 
{
	Test t;
	int val;

	public Test(int val)  
	{
		this.val = val;
	}

	public Test(int val, Test t)
	{
		this.val = val;
		this.t = t;
	}

	public static void main(String[] args) 
	{
		Test t1 = new Test(100);
		
		Test t2 = new Test(200,t1);

		Test t3 = new Test(300,t1);

		Test t4 = new Test(400,t2);

		t2.t = t3; //3000x
		t3.t = t4; //4000X
		t1.t = t2.t; //3000x
		t2.t = t4.t; //2000x

	System.out.println(t1.t.val);
	System.out.println(t2.t.val);
	System.out.println(t3.t.val);
	System.out.println(t4.t.val);
	}
	
}  
------------------------------------------------------------------------
12-01-2024
-----------
Heap and Stack Diagram for Employee.java
-----------------------------------------
public class Employee
{
	int id = 100;

	public static void main(String[] args) 
	{
		int val = 200;

		Employee e1 = new Employee();     

		e1.id = val;

		update(e1);	  
		
		System.out.println(e1.id);

        Employee e2 = new Employee(); 

		e2.id = 500;
        
		switchEmployees(e2,e1);	//3000x and 1000x

		    //GC [2 objects are eligible 4 GC i.e 2000x and 4000x]

			System.out.println(e1.id);
		    System.out.println(e2.id);
	    } 
		
	 public static void update(Employee e)  
	 {
        e.id = 500;
		e = new Employee();
		e.id = 400;
	 }

	 public static void switchEmployees(Employee e1, Employee e2)
	  {
		 int temp = e1.id;
		 e1.id = e2.id; //500 
		 e2 = new Employee();
		 e2.id = temp;
	  }
   }
-------------------------------------------------------------------------
*Why local and Parameter variables we cannot access outside of the method?

Local and parameter variables are the part of Stack Frame (Inside stack Memory), both the variables will be executed inside the frame only and once the method execution is over. It will be deleted from stack frame hence the scope of these variables will be inside that method frame only.

That is the reasin we cannot access local and Parameter variables outside of the method as shown in the program.

Test.java
----------
package com.ravi.method_parameter_local;

public class Test {

	public static void main(String[] args) 
	{
		System.out.println("Main method Started");
		m1();
		System.out.println("Main method Ended");
	}

	public static void m1()
	{
        System.out.println("M1 method Started");
		m2();
		System.out.println("M1 method Ended ");
	}
	
	public static void m2()
	{
		int x = 100;
		System.out.println("M2 Method is executed :"+x);
	}
	
}
-------------------------------------------------------------------------
The JVM Architecture is divided into 3 sections

1) Class Loader sub system (Here all the static members are executed)

2) Runtime Data Areas (Memory Areas)
    a) Method Area (Class Information)
    b) HEAP Area (Object and its related Information)
    c) Stack Area (Methods and its related information)
    d) PC Register (Current Thread Execution)
    e) Native Method Stack (Native Stack Exceution)

3) Execution Engine
   Interpreter (Slow in nature) + JIT Compiler 
--------------------------------------------------------------------------
HEAP and STACK Diagram for Beta.java
-------------------------------------
class Alpha
{
	int val;
	static int sval = 200;
	static Beta b = new Beta();

	public Alpha(int val)
	{
      this.val = val;
	}
}

public class Beta  
{
	public static void main(String[] args) 
	{
		Alpha am1 = new Alpha(9);
		Alpha am2 = new Alpha(2);

		Alpha []ar = fill(am1, am2);  

		ar[0] = am1; 
        System.out.println(ar[0].val); 
        System.out.println(ar[1].val);
	}

	public static Alpha[] fill(Alpha a1, Alpha a2)
	{
		a1.val = 15;

        Alpha fa[] = new Alpha[]{a2, a1};

		return fa;
	}
}
-----------------------------------------------------------------------
19-01-2024
----------
Relationship between the classes :
----------------------------------
In Java, in between the classes we have 2 types of relation 

1) IS-A Relation
2) HAS-A Relation

IS-A relation we can achieve using Inheritance.
HAS-A relation we can achieve using Association.

Example of IS-A relation :

class Vehicle
{

}
class Car extends Vehicle
{
}

In between Vehicle and Car we have IS-A relation because Car IS-A 
Vehicle.

Example of HAS-A relation :
class Vehicle
{
  private Engine engine;
}

In between Vehicle and Engine, We have HAS-A relation because Vehicle has an engine.
----------------------------------------------------------------------
Inheritance (IS-A Relation) :
--------------------------------
Deriving a new class (child class) from existing class (parent class) in such a way that the new class will acquire all the properties and features (except private) from the existing class is called inheritance.

It is one of the most imporatnt feature of OOPs which provides "CODE REUSABILITY".

Using inheritance mechanism the relationship between the  classes is parent and child. According to Java the parent class is called super class and the child class is called sub class.

In java we provide inheritance using 'extends' keyword.

*By using inheritance all the feature of super class is by default available to the sub class so the sub class need not to start the process from begning onwards.

Inheritance provides IS-A relation between the classes. IS-A relation is tightly coupled relation (Blood Relation) so if we modify the super class content then automatically sub class content will also modify.

Inheritance provides us hierarchical classification of classes, In this hierarchy if we move towards upward direction more generalized properties will occur, on the other hand if we move towards downwand more specialized properties will occur.
-----------------------------------------------------------------------
In java, We can classify inheritance into 5 types 

1) Single Level Inheritance
2) Multilevel Inheritance
3) Hierarchical Inheritance
4) Multiple Inheritance (Not supported by using classes)
5) Hybrid Inheritance

Note :- In java, by default java.lang.Object is the super class of all the classes we have in java.

Demo.java
----------
class Demo
{
}

Demo class is written by user but after compilation the .class file 
would be 

Demo.class
----------
class Demo extends java.lang.Object
{

}
----------------------------------------------------------------------
Program on Single Level Inheritance :
-------------------------------------
3 files :
---------
Parent.java
-----------
package com.ravi.single_level_inheritance;

public class Parent 
{
  public void home()
  {
	  System.out.println("3 BHK Home");
  }
}


Child.java
----------
package com.ravi.single_level_inheritance;

public class Child extends Parent 
{
  public void car()
  {
	  System.out.println("Audi car");
  }
}


SingleLevelInheritance.java
---------------------------
package com.ravi.single_level_inheritance;

public class SingleLevelInheritance 
{
	public static void main(String[] args)
	{
		Child c = new Child();
		c.home(); //parent property 
		c.car();  //child property

	}

}
-----------------------------------------------------------------------
//Initializing the super class property through Inheritance :
-------------------------------------------------------------
ConstructorTest.java [Single File Approach]
----------------------------------------------
package com.ravi.single_level_inheritance;

class Super
{
   public Super()
   {
	 System.out.println("Super class Constructor");
   }
}
class Sub extends Super
{
   public Sub()
   {
	   System.out.println("Sub class Constructor");
   }
}

public class ConstructorTest 
{
	public static void main(String[] args) 
	{
		Sub s1 = new Sub();
		
	}
}
------------------------------------------------------------------------
SingleLevelDemo.java [Single File Approach]
------------------------------------------
package com.ravi.single_level;

class Super
{
   int x, y;


	public Super(int x, int y) 
	{
		super();
		this.x = x;
		this.y = y;
	}  
}
class Sub extends Super
{
  public Sub()
  {
	  super(100,200);
  }


	@Override
    public String toString() 
	{
	return "Super [x=" + x + ", y=" + y + "]";
    }  
}

public class SingleLevelDemo 
{
  public static void main(String[] args) 
  {
	Sub s = new Sub();
	System.out.println(s);
  }
}
------------------------------------------------------------------------
SingleLevelInheritance.java
----------------------------
package com.ravi.single_level;

class Alpha
{
	private int x,y;
	
	public Alpha(int x, int y)
	{
		this.setX(x);
		this.setY(y);
	}

	public int getX() {
		return x;
	}

	public void setX(int x) {
		this.x = x;
	}

	public int getY() {
		return y;
	}

	public void setY(int y) {
		this.y = y;
	}
}
class Beta extends Alpha
{
	public Beta(int c, int d)
	{
		super(c,d);
	}
	
	public void show()
	{
		System.out.println("x value is :"+getX());
		System.out.println("y value is :"+getY());
	}
	
}

public class SingleLevelInheritance
{
	public static void main(String[] args)
	{
		new Beta(100,200).show();

	}

}
------------------------------------------------------------------------
Note :- While working with inheritance, private data member will not be available directly to the sub class, here we need to take the help of getter (Encapsulation).
If we want to make the data available to sub class then we should use
protected access modifier which is less restrictive than private.
------------------------------------------------------------------------
Program on Single level inheritance :
-------------------------------------
TemporaryEmployee
  |-employeeNumber
  |-employeeName
  |-employeeAddress
PermanentEmployee
  |-department
  |-designation

EmployeeDemo.java
------------------
package com.ravi.single_level;

class TemporaryEmployee
{
	protected int employeeNumber;
	protected String employeeName;
	protected String employeeAddress;
	
	public TemporaryEmployee(int employeeNumber, String employeeName, String employeeAddress) {
		super();
		this.employeeNumber = employeeNumber;
		this.employeeName = employeeName;
		this.employeeAddress = employeeAddress;
	}
}
class PermanentEmployee extends TemporaryEmployee
{
	protected String department;
	protected String designation;
	
	public PermanentEmployee(int employeeNumber, String employeeName, String employeeAddress, String department,
			String designation) {
		super(employeeNumber, employeeName, employeeAddress);
		this.department = department;
		this.designation = designation;
	}

	@Override
	public String toString() {
		return "PermanentEmployee [department=" + department + ", designation=" + designation + ", employeeNumber="
				+ employeeNumber + ", employeeName=" + employeeName + ", employeeAddress=" + employeeAddress + "]";
	}

}

public class EmployeeDemo 
{
	public static void main(String[] args) 
	{
		PermanentEmployee p = new PermanentEmployee(1, "Rohit", "Mumbai", "Cricket", "Batter");
		System.out.println(p);
	}

}
------------------------------------------------------------------------
22-01-2024
----------
super keyword in java :
-----------------------
It is used to access the member of super class.

We can use super keyword in 3 different ways :

a) To call the super class variable.
b) To call the super class method.
c) To call the super class constructor.

a) To call the super class variable.
-------------------------------------
If the super class variable name and sub class variable name both are same then it is called variable shadow, Here sub class variable will hide super class variable.

If we create an object for sub class then by default it will access sub class variable, if we want to access super class variable then we should use super keyword.

super keyword always refers to its immediate super class.

Just like this keyword we cannot use super keyword from static context.

Program that describes how to call super class variable :
---------------------------------------------------------
SuperVarDemo.java
-----------------
package com.ravi.super_demo;

class Father
{
  protected double balance = 50000;	
}
class Son extends Father
{
	protected double balance = 18000;	
	
	public void showBalance()
	{
		System.out.println("Son balance is :"+balance);
		System.out.println("Father balance is :"+super.balance); 
	}
}

public class SuperVarDemo 
{
	public static void main(String[] args)
	{
		Son s = new Son();
		s.showBalance();
	}

}
------------------------------------------------------------------------
b) To call the super class method :
------------------------------------
Whenever super class method name and sub class method name both are same and if we create an object for sub class then by defulat it will access sub class method.

If we want to access super class method then we should use super keyword.

Program to call super class method :
-------------------------------------
3 Files :
----------
Super.java
-----------
package com.ravi.super_demo;

public class Super 
{
  public void show()
  {
	  System.out.println("Super class show method");
  }
}

Sub.java
---------
package com.ravi.super_demo;

public class Sub extends Super
{
  public void show()
  {
	super.show();
    System.out.println("Sub class show method");
    this.subClassMethod();
  }
  
  public void subClassMethod()
  {
	  System.out.println("Another method of sub class");
  }

}

SuperMethod.java
----------------
package com.ravi.super_demo;

public class SuperMethodDemo {

	public static void main(String[] args) 
	{
		Sub s = new Sub();
		s.show();
	}

}


Note :- From the above program it is clear that super keyword is calling super class method where as this keyword is calling current class method.

super keyword :- used to refer super class member
this keyword :- Used to refer current class member.
-----------------------------------------------------------------------

**To call the super class constructor : (Constructor Chaining)
-----------------------------------------------------------------
Whenever we write a class in java and we don't write any kind of constructor to the class then the java compiler will automatically add one default constructor to the class.

THE FIRST LINE OF ANY CONSTRUCTOR IS RESERVERD EITHER FOR super() or this() keyword.

In the first line of any constructor if we don't specify either super() or this() then the compiler will automatically add super() to the first line of constructor.

Now the purpose of this super() [added by java compiler], to call the default constructor or No-Argument constructor of the super class.

In order to call the constructor of super class as well as same class, we have total 4 cases.


We have 4 cases :
-----------------
case 1 :
--------
super() :- Automatically added by compiler and it is used to access 
           default or no argument constructor of super class.

package com.ravi.super_demo;

class Parent
{
	public Parent()
	{
		System.out.println("Parent class constructor");
	}
}
class Child extends Parent
{
	public Child()
	{
		System.out.println("Child class constructor");
	}
}
public class SuperConstructor 
{
	public static void main(String[] args) 
	{
		Child c = new Child();
	}

}
------------------------------------------------------------------------
Case 2 :
--------
super(String name) :- Used to call parameterized constructor of super 
                      class.

package com.ravi.super_demo;

class A
{
	public A(String name)
	{		
		System.out.println("My name is :"+name);
	}
}
class B extends A
{
	public B()
	{
		super("Scott");
		System.out.println("No Argument constructor of B class");
	}
}

public class SuperConstructor 
{
	public static void main(String[] args) 
	{
		new B();
	}
}
-----------------------------------------------------------------------
Case 3 :
--------
this() :- Used to call no argument constructor of current class.

ThisConstructor.java
---------------------
package com.ravi.super_demo;

class A
{	
	public A()
	{	
		System.out.println("No Argument constructor of A class");
	}
	
	public A(String name)
	{	
		this();
		System.out.println("My name is :"+name);
	}
}
class B extends A
{
	public B(String name)
	{
		super(name);
		System.out.println("No Argument constructor of B class");
	}
}
public class ThisConstructor 
{
	public static void main(String[] args) 
	{
		new B("Scott");
	}

}
----------------------------------------------------------------------
case 4 :
--------
this(int x) :- Calling the parameterized constructor of current class

ThisDemo.java
-------------
package com.ravi.super_demo;

class Base
{
	public Base()
	{
		this(15);
		System.out.println("Base class No Argumenet");
	}
	public Base(int x)
	{
		System.out.println("Base class Parametrized :"+x);
	}	
}
class Derived extends Base
{
	
}


public class ThisDemo
{
	public static void main(String[] args) 
	{
		new Derived();
	}
}
------------------------------------------------------------------------
23-01-2024
----------
Program on single level inheritance :
-------------------------------------
package com.ravi.single_level;

class Shape
{
	protected int x;
	
	public Shape(int x)
	{
		this.x = x;
	}
}
class Square extends Shape
{
	public Square(int side)
	{
		super(side);
	}
	
	public void getAreaOfSquare()
	{
		double area = x * x;
		System.out.println("Area of Square is :"+area);
	}
	
}

public class SingleLevelInheritance 
{
	public static void main(String[] args) 
	{
		Square ss = new Square(10);
		ss.getAreaOfSquare();
	}

}
-------------------------------------------------------------------------
Program on Hierarchical Inheritance by using super keyword

package com.ravi.hierarchical_inheritance;

import java.util.Scanner;

class Shape
{
	protected int x;
	
	public Shape(int x)
	{
		this.x = x;
	}
}
class Square extends Shape
{
	public Square(int side)
	{
		super(side);
	}
	
	public void getAreaOfSquare()
	{
		double area = x * x;
		System.out.println("Area of Square is :"+area);
	}
	
}

class Circle extends Shape
{	
	public Circle(int radius)
	{
		super(radius);
	}
	
	public void getAreaOfCircle()
	{
		final double PI = 3.14;
		double area = PI * x * x;
		System.out.println("Area of Circle is :"+area);
	}
	
}

class Rectangle extends Shape
{
	protected int breadth;
   public Rectangle(int length, int breadth)
   {
	  super(length); 
	  this.breadth = breadth;
   }
   
   public void getAreaOfRectangle()
   {
	   double area = x * breadth;
	   System.out.println("Area of Rectangle is :"+area);
   }
   
}

public class HierarchicalInheritance {

	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		
		System.out.print("Enter the side of the Square :");
		int side = sc.nextInt();
		Square ss = new Square(side);
		ss.getAreaOfSquare();
		
		System.out.print("Enter the radius of the Circle :");
		int radius = sc.nextInt();
		Circle cc = new Circle(radius);
		cc.getAreaOfCircle();
		
		System.out.print("Enter the length and breadth of the Rectangle :");
		int length = sc.nextInt();
		int breadth = sc.nextInt();
		Rectangle rr = new Rectangle(length, breadth);
		rr.getAreaOfRectangle();
	}

}
-------------------------------------------------------------------------
HOW MANY WAYS WE CAN INITIALIZE THE OBJECT PROPERTIES ?
-------------------------------------------------------

The following are the ways to initialize the object properties :
----------------------------------------------------------------
public class Test
{
   int x,y;
}


1) At the time of declaration :

   Example :
   
  public class Test
   {
      int x = 10;
      int y = 20;
   }

   Test t1 = new Test();   [x = 10  y = 20]
   Test t2 = new Test();   [x = 10  y = 20]

Here the drawback is all objects will be initialized with same value.
-----------------------------------------------------------------------

2) By using Object Reference :

   public class Test
   {
      int x,y;
   }
   
   Test t1 = new Test();   t1.x=10;   t1.y=20;
   Test t2 = new Test();   t2.x=30;   t2.y=40;

   Here we are getting different values with respect to object but here
   the program becomes more complex.
-----------------------------------------------------------------------
3) By using methods :

   A) First Approach (Method without Parameter)
   ----------------------------------------------
   public class Test
   {
      int x,y;

      public void setData()  //All the objects will be initialized with
      {                         same value
         x = 100;  y = 200;
      }
   }

    Test t1 = new Test();  t1.setData();  [x = 100   y = 200]
    Test t2 = new Test();  t2.setData();  [x = 100   y = 200]
    

    B) Second Approach (Method with Parameter)
    -------------------------------------------
     public class Test
     {
      int x,y;

      public void setData(int x, int y)  
      {                        
         this.x = x;
	 this.y = y;
      }
   }

    Test t1 = new Test();  t1.setData(12,78);  [x = 12   y = 78]
    Test t2 = new Test();  t2.setData(15,29);  [x = 15   y = 29]

    Here the Drawback is initialization and re-initialization both are done in two different lines so Constructor introduced.
----------------------------------------------------------------------
4) By using Constructor 

   A) First Approach (No Argument Constructor)
   --------------------------------------------
   public class Test
   {
      int x,y;

      public Test()  //All the objects will be initialized with
      {                                             same value
         x = 100;  y = 200;
      }
   }

    Test t1 = new Test();    [x = 100   y = 200]
    Test t2 = new Test();    [x = 100   y = 200]
    

    B) Second Approach (Parameterized Constructor)
    -----------------------------------------------
     public class Test
     {
      int x,y;

      public Test(int x, int y)  
      {                        
         this.x = x;
	 this.y = y;
      }
   }

    Test t1 = new Test(12,78);    [x = 12   y = 78]
    Test t2 = new Test(15,29);    [x = 15   y = 29]

    This is the best way to initialize our instance variable because variable initialization and variable re-initialization both will be done in the same line as well as all the objects will be initialized with different values. 

    C) Third Approach (Copy Constructor)
    --------------------------------------

       public class Manager
       {
          private int managerId;
	  private String managerName;
          
	  public Manager(Employee emp)
	  {
	    this.managerId = emp.getEmployeeId();
	    this.managerName = emp.getEmployeeName();
          }
       }

Here with the help of Object reference (Employee class) we are 
initializing the properties of Manager class. (Copy Constructor)

        d) By using instance block (Instance Initializer)
	-------------------------------------------------
	
	public class Test
	{
	   int x,y;

           public Test()
	   {
	      System.out.println(x); //100
	      System.out.println(y); //200
	   }

           //Instance block
	   {
	       x = 100; 
	       y = 200;
	   }

------------------------------------------------------------------
5) By using super keyword :

   class Super
   {
     int x,y;

     public Super(int x , int y)
     {
        this.x = x;
	this.y = y;
     }
   }
   class Sub extends Super
   {
      Sub()
      {
         super(100,200); //Initializing the properties of super class
      }
   }

   new Sub();
-----------------------------------------------------------------------
Program on Hierarchical inheritance :
-----------------------------------
package com.ravi.hierarchical_inheritance;

class Employee
{
	protected double salary;
	
	public Employee(double salary)
	{
		this.salary = salary;
	}
	
}
class Developer extends Employee
{
	public Developer(double developerSalary)
	{
		super(developerSalary);
	}

	@Override
	public String toString() {
		return "Developer [salary=" + salary + "]";
	}
}
class Designer extends Employee
{
	public Designer(double designerSalary) 
	{
		super(designerSalary);		
	}

	@Override
	public String toString() {
		return "Designer [salary=" + salary + "]";
	}
}
public class HierarchicalDemo 
{
	public static void main(String[] args) 
	{
		System.out.println(new Developer(50000));
		System.out.println(new Designer(20000));
	}
}
------------------------------------------------------------------------
Program on multiplevel Inheritance :
------------------------------------
package com.ravi.multilevel;

class GrandFather
{
	public void land()
	{
		System.out.println("2 acres land");
	}
}
class Father extends GrandFather
{
	public void home()
	{
		System.out.println("3 BHK home");
	}
}
class Son extends Father
{
	public void bike()
	{
		System.out.println("KTM Bike");
	}
}

public class MultiLevel 
{
	public static void main(String[] args)
	{
		Son ss = new Son();
		ss.land();  ss.home();  ss.bike();
	}

}
-------------------------------------------------------------------------
Program on Multilevel Inheritance :
-----------------------------------
package com.ravi.multilevel;

class Student
{
	protected int studentId;
	protected String studentName;
	protected String studentAddress;
	
	public Student(int studentId, String studentName, String studentAddress) {
		super();
		this.studentId = studentId;
		this.studentName = studentName;
		this.studentAddress = studentAddress;
	}

	@Override
	public String toString() {
		return "Student [studentId=" + studentId + ", studentName=" + studentName + ", studentAddress=" + studentAddress
				+ "]";
	}
	
	
}
class Science extends Student
{
	protected int physics;
	protected int chemistry;
	public Science(int studentId, String studentName, String studentAddress, int physics, int chemistry) 
	{
		super(studentId, studentName, studentAddress);
		this.physics = physics;
		this.chemistry = chemistry;
	}
	@Override
	public String toString() 
	{
		return super.toString()+ "Science [physics=" + physics + ", chemistry=" + chemistry + "]";
	}	
	
	
	
}
class PCM extends Science
{
	protected int math;

	public PCM(int studentId, String studentName, String studentAddress, int physics, int chemistry, int math)
	{
		super(studentId, studentName, studentAddress, physics, chemistry);
		this.math = math;
	}

	@Override
	public String toString() 
	{
		return super.toString()+ "PCM [math=" + math + "]";
	}
}

public class MultilevelInheritance 
{
	public static void main(String[] args) 
	{
      PCM p = new PCM(1,"A","Koti",78,89,90);
      System.out.println(p);
	}

}
-----------------------------------------------------------------------
IQ
--
Why Java does not support multiple Inheritance ?
------------------------------------------------
Java does not support multiple inheritance using classes, because if a sub class inherits two or more than two super classes then the default constructor added by the compiler will generate ambiguity issue to call the super class constructor.(23-JAN)

It is a also known as Diamond Problem in java.

We can achieve multiple Inheritance by using interface concept.
----------------------------------------------------------------------
24-01-2024
----------
Access Modifier in java :
--------------------------
It is used to describe the accessibility level of the class as well as the member of the class.

In terms of accessibility, java software people has provided 4 access modifiers.

a) private  (Accessible within the same class only)
b) default  (Accessible within the same package only)
c) protected (Accessible from another package also but using inheritance)
d) public (No restriction accessible from everywhere)
   
private :
---------
It is an access modifier and it is the most restrictive access modifier because the member declared as private can't be accessible from outside of the class.
In Java we can't declare an outer class as a private or protected. Generally we should declare the data member(variables) as private.

In java outer class can be declared as public, abstract, final and sealed (must have sub class) only.

default :-
----------
It is an access modifier which is less restrictive than private. It is such kind of access modifier whose physical existance is not avaialble that means when we don't specify any kind of access modifier before the class name, variable name or method name then by default it would be default.

As far as its accessibility is concerned, default members are accessible within the same folder(package) only.

protected :
------------
It is an access modifier which is less restrictive than default because the member declared as protected can be accessible from the outside of the package (folder) too but by using inheritance concept.

2 Files which are available in 2 different packages :
------------------------------------------------------
Test.java
---------
package com.ravi.constructor;

public class Test 
{
  protected int x = 500;
}


ELC.java
---------
package com.ravi.inheritance;

import com.ravi.constructor.Test;

public class ELC extends Test
{
	public static void main(String[] args) 
	{
		ELC e = new ELC();
		System.out.println(e.x);
	}

}
----------------------------------------------------------------------------
public :
-------
It is an access modifier which does not contain any kind of restriction that is the reason the member declared as public can be accessible from everywhere without any restriction.

According to Object Oriented rule we should declare the classes and methods as public where as variables must be declared as private or protected according to the requirement.
----------------------------------------------------------------------------
System.out.println() using HAS-A Relation
------------------------------------------

class Test
{
  static String out = "India";
}

Test.out.length();

Note : length() is a predefined method of String class
----------------------------------------------------------------------------
class System
{
   static final PrintStream out;  //HAS-A relation
}

System.out.println();

Note :- println() is a predefined method of PrintStream class
------------------------------------------------------------------------
25-01-2024
----------
HAS-A relation between the classes :
------------------------------------------
In order to acheive HAS-A relation concept we should use Association.

Association (Relationship between the classes through Object reference)
-----------------------------------------------------------------------
Association :
---------------
Association is a connection between two separate classes that can be built up through their Objects. 

The association builds a relationship between the classes and describes how much a class knows about another class. 

This relationship can be unidirectional or bi-directional. In Java, the association can have one-to-one, one-to-many, many-to-one and many-to-many relationships.

Example:-
One to One: A person can have only one PAN card
One to many: A Bank can have many Employees
Many to one:  Many employees can work in single department 
Many to Many: A Bank can have multiple customers and a customer can have multiple bank accounts.

3 Files :
---------
Student.java
-------------
package com.ravi.association;

public class Student 
{
	private int studentId;
	private String studentName;
	private double studentFees;
	private int studentAge;
	
	public Student(int studentId, String studentName, double studentFees, int studentAge) {
		super();
		this.studentId = studentId;
		this.studentName = studentName;
		this.studentFees = studentFees;
		this.studentAge = studentAge;
	}

	@Override
	public String toString() {
		return "Student [studentId=" + studentId + ", studentName=" + studentName + ", studentFees=" + studentFees
				+ ", studentAge=" + studentAge + "]";
	}

	public int getStudentId() {
		return studentId;
	}

	public String getStudentName() {
		return studentName;
	}

	public double getStudentFees() {
		return studentFees;
	}

	public int getStudentAge() {
		return studentAge;
	}
}

Trainer.java
------------
package com.ravi.association;

import java.util.Scanner;

public class Trainer 
{
   public static void getStudentProfile(Student s)  //s = s1
   {
	 Scanner sc = new Scanner(System.in);
	 System.out.print("Enter Student id :");
	 int id = sc.nextInt();
	 
	 if(id == s.getStudentId())
	 {
		 System.out.println(s);
	 }
	 else
	 {
		 System.err.println("No such student is available!!!");
	 }
	 
	 
   }
}

AssociationDemo.java
--------------------
package com.ravi.association;

public class AssociationDemo {

	public static void main(String[] args) 
	{
		Student s1 = new Student(1,"John",12900,24);
		Trainer.getStudentProfile(s1);
		
		System.out.println(".......................");
		Trainer.getStudentProfile(new Student(2,"Scott",25000,25));
	}

}
-----------------------------------------------------------------------
Composition (Strong reference) :
--------------------------------
Composition in Java is a way to design classes such that one class contains an object of another class. It is a way of establishing a "HAS-A" relationship between classes.

Composition represents a strong relationship between the containing class and the contained class.If the containing object (Car object) is destroyed, all the contained objects (Engine object) are also destroyed.

A car has an engine. Composition makes strong relationship between the objects. It means that if we destroy the owner object, its members  will be also destroyed with it. For example, if the Car is destroyed the engine will also be destroyed as well.

3 Files :
---------
1) Engine.java
--------------
package com.ravi.composition;

public class Engine 
{
	private String engineType;
	private int engineHorsePower;

	public Engine(String engineType, int engineHorsePower) 
	{
		super();
		this.engineType = engineType;
		this.engineHorsePower = engineHorsePower;
	}

	@Override
	public String toString() {
		return "Engine [engineType=" + engineType + ", engineHorsePower=" + engineHorsePower + "]";
	}	
}

2) Car.java
-----------
package com.ravi.composition;

public class Car {
	private String carName;
	private int carModel;
	private Engine engine; // HAS-A Relation

	public Car(String carName, int carModel) 
	{
		super();
		this.carName = carName;
		this.carModel = carModel;
		this.engine = new Engine("Petrol",1200);  //Composition
	}

	@Override
	public String toString() {
		return "Car [carName=" + carName + ", carModel=" + carModel + ", engine=" + engine + "]";
	}

	
}

3) CompositionDemo.java
------------------------
package com.ravi.composition;

public class CompositionDemo {

	public static void main(String[] args) 
	{
	  Car c1 = new Car("Naxon", 2024);
	  System.out.println(c1);
	  
	  Car c2 = new Car("Ford",2023);
	  System.out.println(c2);
	}
}
-----------------------------------------------------------------------
Assignment :
------------
Person and Heart
Laptop and Motherboard
-----------------------------------------------------------------------
Aggregation (Weak Reference) :
-----------------------------------
Aggregation in Java is another form of association between classes that represents a "HAS-A" relationship, but with a weaker bond compared to composition. In aggregation, one class contains an object of another class, but the contained object can exist independently of the container. If the container object is destroyed, the contained object can still exist.

3 files :
----------
Employee.java
-------------
package com.ravi.aggregation;

public class Employee 
{
  private int employeeNumber;
  private String employeeName;
  private double employeeSalary;
  
	public Employee(int employeeNumber, String employeeName, double employeeSalary) {
		super();
		this.employeeNumber = employeeNumber;
		this.employeeName = employeeName;
		this.employeeSalary = employeeSalary;
	}

	@Override
	public String toString() {
		return "Employee [employeeNumber=" + employeeNumber + ", employeeName=" + employeeName + ", employeeSalary="
				+ employeeSalary + "]";
	}  
}

Company.java
-------------
package com.ravi.aggregation;

public class Company 
{
  private String companyName;
  private String companyLocation;
  private Employee employee;
  
	public Company(String companyName, String companyLocation, Employee employee) {
		super();
		this.companyName = companyName;
		this.companyLocation = companyLocation;
		this.employee = employee;
	}

	@Override
	public String toString() {
		return "Company [companyName=" + companyName + ", companyLocation=" + companyLocation + ", employee=" + employee
				+ "]";
	}  
}

Aggregation.java
-----------------
package com.ravi.aggregation;

public class Aggregation 
{
	public static void main(String[] args)
	{
		Employee e1 = new Employee(101, "Ravi", 12000);
		e1 = null;
		
		Employee e2 = new Employee(102, "Raj", 14000);		
		
		Company c1 = new Company("TCS", "Hyderabad", e2);
		System.out.println(c1);
	}

}
-----------------------------------------------------------------------
Polymorphism :
--------------
Poly means "many" and morphism means "forms".

It is a Greek word whose meaning is "same object having different behavior".

In our real life a person or a human being can perform so many task, in the same way in our programming languages a method or a constructor can perform so many task.

Eg:-

void add(int a, int b)

void add(int a, int b, int c)

void add(float a, float b)

void add(int a, float b)


Polymorphism can be divided into two types :

1) Static polymorphism OR Compile time polymorphism OR Early binding

2) Dynamic Polymorphism OR Runtime polymorphism OR Late binding


1) Static Polymorphism :
------------------------
The polymorphism which exist at the time of compilation is called Static OR compile time polymorphism.

In static polymorphism, compiler has very good idea that which method is invoked depending upon METHOD PARAMETER.

Here the binding of the method is done at compilation time so, it is known as early binding.

We can achieve static polymorphism by using Method Overloading concept.

Example of static polymorphism : Method Overloading.


2) Dynamic Polymorphism OR Runtime Polymorphism
------------------------------------------------
The polymorphism which exist at runtime is called Dynamic polymorphim Or Runtime Polymorphism.

*Here compiler does not have any idea about method calling, at runtime
JVM will decide which method will be invoked depending upon CLASS TYPE.

Here method binding is done at runtime so, it is also called Late Binding.

We can achieve dynamic polymorphism by using Method Overriding.

Example of Dynamic Polymorphism : Method Overriding
----------------------------------------------------------------------
Method Overloading :
--------------------
Writing two or more methods in the same class or even in the super and sub class in such a way that the method name must be same but the argument must be different.

While Overloading a method we can change the return type of the method.

If parameters are same but only method return type is different then it is not an overloaded method.

Method overloading is possible in the same class as well as super and sub class.

While overloading the method the argument must be different otherwise there will be ambiguity problem.

IQ
---
Can we overload the main method/static method ?
------------------------------------------------
We can overload the main method but JVM will always search the main method which takes String array as a parameter. 

Example :
------------
public static void main(String [] args)  //JVM will serach this method 
{
}

public static void main(String x)
{
}

public static void main(int y)
{
}
------------------------------------------------------------------------
Program on Constructor Overloading :
------------------------------------
Addition.java
-------------
package com.ravi.constructor_overloading;

public class Addition 
{
   public Addition(int x, int y)
   {	  
	   System.out.println("Sum of two integer is :"+(x+y));
   }
   
   public Addition(int x, int y, int z)
   {  
	   System.out.println("Sum of three integer is :"+(x+y+z));
   }
   
   public Addition(float x, float y)
   {	  
	   System.out.println("Sum of two float is :"+(x+y));
   }
}

Main.java
---------
package com.ravi.constructor_overloading;

public class Main 
{
	public static void main(String []  args) 
	{
		new Addition(2.3f, 7.8F);		
		new Addition(10, 20, 30);
		new Addition(12,90);
	}

}

-----------------------------------------------------------------------
Program on Constructor Overloading (Constructor Chaining)
---------------------------------------------------------
2 Files :
----------
Addition.java
--------------
package com.ravi.constructor_overloading1;

public class Addition 
{
   public Addition(int x, int y)
   {	  
	   System.out.println("Sum of two integer is :"+(x+y));
   }
   
   public Addition(int x, int y, int z)
   {
	   this(100,200);
	   System.out.println("Sum of three integer is :"+(x+y+z));
   }
   
   public Addition(float x, float y)
   {	
	   this(10,20,30);
	   System.out.println("Sum of two float is :"+(x+y));
   }
}

Main.java
---------
package com.ravi.constructor_overloading1;

public class Main {

	public static void main(String []  args) 
	{
		new Addition(2.3f, 7.8F);		
	}
}
--------------------------------------------------------------------------
29-01-2024
----------
Program on Method Overloading by changing the return type.
----------------------------------------------------------
2 files :
----------
Sum.java
---------
package com.ravi.method_overload;

public class Sum
{
  public int add(int x, int y)
  {
	  int z = x+y;
	  return z;	  
  }
  
  public String add(String x, String y) //data base
  {
	  String z = x+y;
	  return z;
  }

  public double add(double x, double y)
  {
	  double z = x+y;
	  return z;
  }
}
 
Main.java
---------
package com.ravi.method_overload;

public class Main 
{
	public static void main(String[] args) 
	{
		Sum s1 = new Sum();
		String add = s1.add("Data", "base");
		
		int x = s1.add(12, 12);
		
		double y = s1.add(12.89, 12.90);
		
		
		System.out.println(add+" : "+x+" : "+y);

	}
}

Note :- From the above program it is clear that we can change the return type of the method while overloading a method.
--------------------------------------------------------------------------
Var-Args :
------------
It was introduced from JDK 1.5 onwards.

It stands for variable argument. It is an array variable which can hold 0 to n number of parameters of same type or different type by using Object class.

It is represented by exactly 3 dots (...) so it can accept any number of argument (0 to nth) that means now we need not to define method body again and again, if there is change in method parameter value.

var-args must be only one and last argument.

We can use var-args as a method parameter only.
--------------------------------------------------------------------------
Program that describes var args can hold 0 to n number of parameters :
----------------------------------------------------------------------
2 files :
---------
Test.java
----------
package com.ravi.var_args;

public class Test 
{
  public void input(int... x)  //Array
  {
	  System.out.println("Var args executed");
  }
}

Main.java
----------
package com.ravi.var_args;

public class Main {

	public static void main(String ...x)
	{ 			
		Test t1 = new Test();
		t1.input();
		t1.input(12);
		t1.input(15,19);
		t1.input(10,20,30);
		t1.input(10,20,30,40);
		t1.input(10,20,30,40,50);
								
	}
}
--------------------------------------------------------------------------
Program that describes how to add patameter values using var args :
-------------------------------------------------------------------
2 Files :
---------
Test.java
---------
//add the parameter values using variable argument
package com.ravi.var_args1;

public class Test 
{
   public void acceptData(int ...values)
   {
	   int sum = 0;
	   for(int value : values)
	   {
		   sum = sum + value;
	   }
	   System.out.println("Sum of parametrs :"+sum);
   }
}

Main.java
----------
package com.ravi.var_args1;

public class Main 
{
	public static void main(String[] args) 
	{
		Test t1 = new Test();
		t1.acceptData();
		t1.acceptData(10,20);
		t1.acceptData(10,20,30);
		t1.acceptData(100,100,100,100);

	}
}
--------------------------------------------------------------------------
Program that describes var args must be only one and last argument.

Test.java
---------
package com.ravi.var_args2;

public class Test 
{
      //All commented codes are invalid
	/*
	  public void accept(float ...x, int ...y) { }
	  
	  public void accept(int ...x, int y)  { }
	  
	  public void accept(int...x, int ...y) {} */
	 
	 
	 

	public void accept(int x, int... y) // valid
	{
		System.out.println("x value is :"+x);
		for (int z : y) 
		{
			System.out.println(z);
		}
	}
}


Main.java
---------
package com.ravi.var_args2;

public class Main {

	public static void main(String[] args) 
	{
		Test t1 = new Test();
		t1.accept(100, 200,300,400,500);
	}
}
-------------------------------------------------------------------------
Program that describes var-args may also accept Hetrogeneous types of
Elements.
2 Files :
---------
Test.java
----------
package com.ravi.var_args3;

public class Test 
{
   public void acceptHetro(Object ...obj)
   {
	   for(Object o : obj)
	   {
		   System.out.println(o);
	   }
   }
}

Main.java
---------
package com.ravi.var_args3;

public class Main {

	public static void main(String[] args) 
	{
	  Test t1 = new Test();
	
	  t1.acceptHetro(true,45.90,12,'A', new String("Ravi"));		 
	}
}
-----------------------------------------------------------------------
30-01-2024
----------
Wrapper classes in java :
----------------------------
In java we have 8 primitive data types i.e byte, short, int, long, float, double, char and boolean.

Except these primitives, everything in java is an Object.

If we remove these 8 data types from java then Java will become pure Object Oriented language. 

Wrapper class is a technique through which we can convert the primitives to corresponding object. Now it can be divided into two types from 1.5 onwards

a) Autoboxing
b) Unboxing

Autoboxing 
--------------
When we convert the primitive data types into corresponding wrapper object then it is called Autoboxing as shown below.

Primitive type		Wrapper Object
----------------             ------------------
byte			-	Byte


short			-	Short

int			-	Integer

long			-	Long

float			-	Float

double			-	Double

char			-	Chracter

boolean			-	boolean
---------------------------------------------------------------------------
Converting Primitive to Wrapper type :
---------------------------------------
Integer class has provided predefined static method valueOf(int x), it is responsible to convert the primitive type into wrapper object.

public static Integer valueOf(int x)
------------------------------------------------------------------------
//Integer.valueOf(int);
public class AutoBoxing1
{
	public static void main(String[] args) 
	{
		int a = 12;
		Integer x = Integer.valueOf(a); //Upto 1.4 version
		System.out.println(x);

		
        int y = 15;
		Integer i = y;   //From 1.5 onwards compiler takes care
		System.out.println(i);		
	}
}
-----------------------------------------------------------------------
public class AutoBoxing2
	{  
		public static void main(String args[])
			{  
			    int y = 12;
				Integer x = y;           
				System.out.println(x);  	
				
				double e = 45.90;
				Double d = e;
				System.out.println(d);  

                boolean a = true;
				Boolean b = a;
				System.out.println(b);  
			}   
}  
------------------------------------------------------------------------
Converting String into Integer wrapper object :
------------------------------------------------
We can convert String into wrapper object by using two overloaded methods :

1) public static Integer valueOf(String str) 

   It will convert the String into Integer Wrapper object by using base 10 (default base).


2) public static Integer valueOf(String str, int radix/base)
   It will convert the String into Integer Wrapper object by using the 
   specified base or radix as shown in the program.

Note :- We can pass base OR radix upto 36
i.e A to Z (26) + 0 to 9 (10) -> [26 + 10 = 36], It can be 
calculated by using Character.MAX_RADIX.
Output will be generated on the basis of radix


//Integer.valueOf(String str)
//Integer.valueOf(String str, int radix/base)
public class AutoBoxing3 
{
	public static void main(String[] args) 
	{
			Integer a = Integer.valueOf(15);
			
			Integer b = Integer.valueOf("25");

            Integer c = Integer.valueOf("111",10); //Here Base we can take upto 36

			System.out.println(a);
			System.out.println(b);
			System.out.println(c);

	}
}

(Assignment)
Note :- Integer.parseInt(String str, int radix) is also used to convert 
        String into Integer by using specifid radix.

 System.out.println(Character.MAX_RADIX); //36
------------------------------------------------------------------------
public class AutoBoxing4 
{
	public static void main(String[] args) 
	{
		Integer i1 = new Integer(100);
		Integer i2 = new Integer(100);
		System.out.println(i1==i2);

		Integer a1 = Integer.valueOf(15);
		Integer a2 = Integer.valueOf(15);
		System.out.println(a1==a2);
	}
}
-----------------------------------------------------------------------
//Converting integer value to String
public class AutoBoxing5 
{
	public static void main(String[] args) 
	{
		int x = 12;
		String str = Integer.toString(x);
		System.out.println(str+2);
	}
}

Note :- Integer class has static method toString(int x) through which we can convert the int value into String type.
------------------------------------------------------------------------
public class CharacterAndBoolean 
{
  public static void main(String[] args) 
  {
	 
	  char ch = 'A';
	  Character valueOf = Character.valueOf(ch);
	  System.out.println(valueOf);
	                 
	  boolean b = true;
	  Boolean bool = Boolean.valueOf(b);
	  System.out.println(bool);
	 
  }
}
----------------------------------------------------------------------
31-01-2024
----------
Unboxing :
---------
Unboxing :
----------------
Converting wrapper object to corresponding primitive type is called Unboxing.

Wrapper            Primitive
Object               type               
----------            ----------
Byte		-	byte

Short		-	short

Integer		-	int

Long		-	long

Float		-	float

Double		-	double

Chracter	-	char

Boolean		-	boolean
----------------------------------------------------------------------
We have total 8 Wrapper classes.

Among all these 8, 6 Wrapper classes are the sub class of Number class
so all the following six wrapper classes (Which are sub class of Number class) are providing the following common methods.

1) public byte byteValue()

2) public short shortValue()

3) public int intValue()

4) public long longValue()

5) public float floatValue()

6) public double doubleValue()
--------------------------------------------------------------------
//Converting Wrapper object into primitive
public class AutoUnboxing1
{  
   public static void main(String args[])
	   {  
                        Integer obj = 15;   //Upto 1.4
			int x = obj.intValue();
			System.out.println(x);
		}   
}  
---------------------------------------------------------------------- public class AutoUnboxing2
{
	public static void main(String[] args) 
	{	
			Integer x = 25; 
			int y = x;         //JDK 1.5 onwards  
			System.out.println(y);  
	}
}
-----------------------------------------------------------------------
public class AutoUnboxing3
{
	public static void main(String[] args) 
	{	
			Integer i = 15;
			System.out.println(i.byteValue());
			System.out.println(i.shortValue());
			System.out.println(i.intValue());
			System.out.println(i.longValue());
			System.out.println(i.floatValue());
			System.out.println(i.doubleValue());			
	}
}
-----------------------------------------------------------------------
public class AutoUnboxing4
{
	public static void main(String[] args) 
	{
		Character c1 = 'A';
		char ch = c1.charValue();
		System.out.println(ch);
	}
}
----------------------------------------------------------------------
public class AutoUnboxing5
{
	public static void main(String[] args) 
	{
		Boolean b1 = true;
		boolean b = b1.booleanValue();
		System.out.println(b);
	}
}
----------------------------------------------------------------------
class BufferTest 
{
	public static void main(String[] args) 
	{		
		Integer i1 = 127;
		Integer i2 = 127;
		System.out.println(i1==i2); //true

		Integer i3 = 128;
		Integer i4 = 128;
		System.out.println(i3==i4); //false

		Integer i5 = 128;
		Integer i6 = 128;
		System.out.println(i5.equals(i6)); //true
	}
}

Note :- Whenver we will compare Integer wrapper object then we should use equals(Object obj) method.
-----------------------------------------------------------------------
public class Test 
{
	public static void main(String[] args) 
	{
		long l = 12; //Widening
		System.out.println(l);

		//Long L = 12;//error

		Long L = 12L; //Now 12 is of Long type
		System.out.println(L);

        
		double d = 12;
		System.out.println(d);

                Double D = 12.0;
		System.out.println(D);


	}
}

Note :- While with wrapper classes we need to provide appropriate type
        of value otherwise program will not compile

	Long l = 12; //Invalid
	Long l = 12L; //valid

	Double d = 123; //Invalid
	Double d = 123.90; //Valid
----------------------------------------------------------------------
Ambiguity issues while overloading a method :
---------------------------------------------
Whenever we work with method overloading and if we have ambiguity while 
calling the method then compiler has provided 2 rules to work with
Method overloading.

Rule 1:
-------
Most specific type (Specific type will get more priority)

double > float
float > long
long > int 
int > short
int > char 
short > byte

Rule 2 :
-------
While overloading a method, if we have an ambiguity issue then compiler provides the priority in the following order :

WAV [Widening -> Autoboxing -> Var args]

-----------------------------------------------------------------------
Programs :
-----------
package com.ravi.ambiguity;

class Test
{
	public void accept(byte b)
	{
		System.out.println("byte");
	}
	public void accept(short b)
	{
		System.out.println("short");
	}
}


public class AmbiguityDemo {

	public static void main(String[] args) 
	{
		Test t1 = new Test();
		t1.accept(15); //Error

	}

}

Note :- 15 which is by default of type int, we cannot assign to byte or short directly.
-----------------------------------------------------------------------
package com.ravi.ambiguity;

class Test
{
	public void accept(byte b)
	{
		System.out.println("byte");
	}
	public void accept(short b)
	{
		System.out.println("short");
	}
}


public class AmbiguityDemo {

	public static void main(String[] args) 
	{
		Test t1 = new Test();
		t1.accept((byte)15);
		t1.accept((short)19);

	}

}
-----------------------------------------------------------------------
package com.ravi.ambiguity;

class Test
{
	public void accept(int b)
	{
		System.out.println("int");
	}
	public void accept(long b)
	{
		System.out.println("long");
	}
}


public class AmbiguityDemo {

	public static void main(String[] args) 
	{
		Test t1 = new Test();
		t1.accept(15);

	}

}

Note :- Here int will be executed because int is the most specific type
-----------------------------------------------------------------------
package com.ravi.ambiguity;

class Test
{
	public void accept(String b)
	{
		System.out.println("String");
	}
	public void accept(Object b)
	{
		System.out.println("object");
	}
}


public class AmbiguityDemo {

	public static void main(String[] args) 
	{
		Test t1 = new Test();
		t1.accept("India");  t1.accept(null);

	}

}

Here in both the cases String will be executed.
-------------------------------------------------------------------
package com.ravi.ambiguity;

class Test
{
	public void accept(String b)
	{
		System.out.println("String");
	}
	
	public void accept(Integer b)
	{
		System.out.println("Integer");
	}
	
	public void accept(Object b)
	{
		System.out.println("object");
	}
}


public class AmbiguityDemo {

	public static void main(String[] args) 
	{
		Test t1 = new Test();  
		t1.accept(null); //error
		

	}

}

Note :- In between Integer and String, compiler is unable to find most specific type.
----------------------------------------------------------------------
package com.ravi.ambiguity;

class Test
{
	public void accept(int ...x)
	{
		System.out.println("int");
	}
	
	public void accept(float ...x)
	{
		System.out.println("float");
	}	
}


public class AmbiguityDemo {

	public static void main(String[] args) 
	{
		Test t1 = new Test();  
		t1.accept();

		

	}

}

Note :- int will be executed becoz int is more specific type
---------------------------------------------------------------------

package com.ravi.ambiguity;

class Test
{
	public void accept(double ...x)
	{
		System.out.println("double");
	}
	
	public void accept(float ...x)
	{
		System.out.println("float");
	}	
}


public class AmbiguityDemo {

	public static void main(String[] args) 
	{
		Test t1 = new Test();  
		t1.accept();

		

	}

}

Note :- float will be executed becoz float is more specific type
---------------------------------------------------------------------
package com.ravi.ambiguity;

class Test
{
	public void accept(int ...x)
	{
		System.out.println("int");
	}
	
	public void accept(boolean ...x)
	{
		System.out.println("boolean");
	}	
}


public class AmbiguityDemo {

	public static void main(String[] args) 
	{
		Test t1 = new Test();  
		t1.accept();
		

	}

}

Note :- We will get compilation error because in between int and boolean we don't have any relation
-----------------------------------------------------------------------
package com.ravi.ambiguity;

class Test
{
	public void accept(int ...x)
	{
		System.out.println("int");
	}
	
	public void accept(char ...x)
	{
		System.out.println("char");
	}	
}


public class AmbiguityDemo {

	public static void main(String[] args) 
	{
		Test t1 = new Test();  
		t1.accept();
		

	}

}
Note :- char will be executed becoz char is more specific type
----------------------------------------------------------------------
package com.ravi.ambiguity;

class Test
{
	public void accept(short ...x)
	{
		System.out.println("short");
	}
	
	public void accept(char ...x)
	{
		System.out.println("char");
	}	
}


public class AmbiguityDemo {

	public static void main(String[] args) 
	{
		Test t1 = new Test();  
		t1.accept(); //error
		

	}

}

Note :- No relation between char and short
----------------------------------------------------------------------
package com.ravi.ambiguity;

class Test
{
	public void accept(float a,  int b)
	{
		System.out.println("float - int");
	}
	
	public void accept(int a, float b)
	{
		System.out.println("int - float");
	}	
}


public class AmbiguityDemo {

	public static void main(String[] args) 
	{
		Test t1 = new Test();  
		t1.accept(20, 30); //error	
	}

}
----------------------------------------------------------------------
package com.ravi.ambiguity;

class Test
{
	public void accept(long l)
	{
		System.out.println("long [Widening]");
	}
	
	public void accept(Integer i)
	{
		System.out.println("Integer [Autoboxing]");
	}	
}


public class AmbiguityDemo {

	public static void main(String[] args) 
	{
		Test t1 = new Test();  
		t1.accept(20);
		

	}

}

Note :- Here Widening is having more priority than Autoboxing
----------------------------------------------------------------------
package com.ravi.ambiguity;

class Test
{
	public void accept(long l)
	{
		System.out.println("long [Widening]");
	}
	
	public void accept(int ...x)
	{
		System.out.println("int [var args]");
	}	
}


public class AmbiguityDemo {

	public static void main(String[] args) 
	{
		Test t1 = new Test();  
		t1.accept(20);
		

	}

}

Note :- Here Widening is having more priority than var args
-----------------------------------------------------------------------
package com.ravi.ambiguity;

class Test
{
	public void accept(Integer i)
	{
		System.out.println("int [Autoboxing]");
	}
	
	public void accept(int ...x)
	{
		System.out.println("int [var args]");
	}	
}


public class AmbiguityDemo {

	public static void main(String[] args) 
	{
		Test t1 = new Test();  
		t1.accept(20);
	}

}
-----------------------------------------------------------------------
01-02-2024
----------
* Method Overriding :
---------------------
Writing two or more methods in the super and sub class in such a way that method signature(method name along with method parameter) of both the methods  must be same in the super and sub classes. 

While working with method overriding generally we can't change the return type of the method but from JDK 1.5 onwards we can change the return type of the method in only one case that is known as Co-Variant.

Without inheritance method overriding is not possible that means if there is no inheritance there is no method overriding.
-------------------------------------------------------------------------
What is the advantage of Method Overriding ?
-------------------------------------------
The advantage of Method Overriding is, each class is specifying its own specific behavior.
-------------------------------------------------------------------------
Upcasting :- 
------------
It is possble to assign sub class object to super class reference variable using dynamic polymorphism. It is known as Upcasting.

Example:-    Animal a = new Lion();  //valid [upcasting]

Downcasting :
---------------
By default downcasting is not possible, Here we are trying to assign super class object to sub class reference variable but the same we can achieve by using explicit type casting. It is known as downcasting.

Eg:-    Lion l = new Animal(); //Invalid

	  Lion l = (Lion) new Animal(); //Valid because Explicit type casting

	  But by using above statement (Downcasting) whenever we call a method we will get a runtime exception called java.lang.ClassCastException. [Animal cann't be  cast to Lion]
--------------------------------------------------------------------------
//Method Overriding Program
---------------------------
MethodOverriding.java
---------------------

class Animal
{
	public void eat()
	{
       System.out.println("Generic Eating");
	}
}
class Lion extends Animal
{
	public void eat()
	{
       System.out.println("Non Veg type Animal");
	}   
}
public class MethodOverriding
{
    public static void main(String args[]) 
    {
    	Animal a = new Lion(); 
		a.eat(); 	
    }
}
-------------------------------------------------------------------------
Method Overriding Program 
------------------------------
MethodOverridingBird.java
-------------------------
class Bird
{
	public void fly()
	{
      System.out.println("Generic Bird is flying");
	}
}

class Parrot extends Bird
{
	public void fly()
	{
      System.out.println("Parrot Bird is flying");
	}
}

class Peacock extends Bird
{
	public void fly()
	{
      System.out.println("Peacock Bird is flying");
	}
}
public class MethodOverridingBird 
{
	public static void main(String[] args) 
	{
		Bird b;

        b = new Parrot(); b.fly();  //Dynamic Method Dispatch

		 b = new Peacock(); b.fly(); //Dynamic Method Dispatch


	}
}
------------------------------------------------------------------------
@Override Annotation :
--------------------------
In Java we have a concept called Annotation, introduced from JDK 1.5 onwards. All the annotations must be start with @ symbol.

@Override annotation is optional but it is always a good practice to write @Override annotation before the Overridden method so compiler as well as user will get the confirmation that the method is overridden method and it is available in the super class.

If we use @Override annotation before the name of the overridden method in the sub class and if the method is not available in the super class then it will generate a compilation error so it is different from comment because comment will not generate any kind of compilation error if method is not an overridden method, so this is how it is different from comment.
-------------------------------------------------------------------------
package com.ravi.method_overriding;

class RBI
{
	public void loan()
	{
		System.out.println("Bank should provide loan..");
	}
}
class SBI extends RBI
{
	@Override
	public void loan()
	{
		System.out.println("SBI provides loan @ 9.2 %");
	}
}
class BOB extends RBI
{
	@Override
	public void loan()
	{
		System.out.println("BOB provides loan @ 10.4 %");
	}
}
public class OverrideAnnotation 
{
	public static void main(String[] args) 
	{
		RBI r1;
		
		r1 = new SBI(); r1.loan();
		
		r1 = new BOB(); r1.loan();
		
	}

}
------------------------------------------------------------------------
Program that describes we cannot override private method:
---------------------------------------------------------
private methods are available within the same class only, it is not visible to the child class so we cannot override.

class Super
{
	private void show()
	{
		System.out.println("Show method of super class!!!!");
	}
}
class Sub extends Super
{
	@Override //error We cannot override private method
	public void show() 
	{
		System.out.println("Show method of sub class!!!!");
	}
}
public class VisibilityMode 
{
	public static void main(String[] args) 
	{
		Super s = new Sub();
		//s.show(); //error we can't access private method
	}
}
------------------------------------------------------------------------
Role of access modifier while overriding a method :
---------------------------------------------------
While overriding the method from super class, the access modifier of sub class method must be greater or equal in comparison to access modifier of super class method otherwise we will get compilation error.

public is greater than protected, protected is greater than default (public > protected > default)
[default < protected < public]

So the conclusion is we can't reduce the visibility while overriding a method.

Note :- private access modifier is not availble (visible) in sub class so it is not the part of method overriding.
-------------------------------------------------------------------------
package com.ravi.method_overriding;

class Shape
{
	public void draw()
	{
		System.out.println("Generic Draw");
	}
}
class Rectangle extends Shape
{
	@Override
	protected void draw()  //error only public is applicable
	{
		System.out.println("Drawing Rectangle");
	}
}
class Square extends Shape
{
	@Override
	protected void draw()
	{
		System.out.println("Drawing Square");
	}
}
public class ShapeDemo 
{
	public static void main(String[] args) 
	{
		Shape s = null;
		
		s = new Rectangle(); s.draw();
		s = new Square(); s.draw();
	}

}
------------------------------------------------------------------------
* Co-variant :
------------
Co-variant concept in method overriding :
------------------------------------------------
In general we cann't change the return type of method while overriding a method. if we try to change it will generate compilation error as shown in the program below.

package com.ravi.covariant;

class Super
{
	public void show()
	{
		System.out.println("Super class show method");
	}
}
class Sub extends Super
{
	@Override
	public int show()  //error []
	{
		System.out.println("Sub class show method");
		return 0;
	}
}

public class IncompatibleReturnType {

	public static void main(String[] args) 
	{
		// TODO Auto-generated method stub

	}

}
------------------------------------------------------------------------
Note :- return type int is not compatible void.
-----------------------------------------------------------------------
But from JDK 1.5 onwards we can change the return type of the method in only one case that the return type of both the METHODS(SUPER AND SUB CLASS METHODS) MUST BE IN INHERITANCE RELATIONSHIP (IS-A relation ship so it is compatible) called Co-Variant as shown in the program below.

Note :- Co-variant will not work with primitive data type, it will work only with classes
-----------------------------------------------------------------------
package com.ravi.covariant;

class Alpha
{}
class Beta extends Alpha
{}

class Super
{
	public Alpha show()
	{
		System.out.println("Super class show method");
		return new Alpha();
	}
}
class Sub extends Super
{
	@Override
	public Beta show() 
	{
		System.out.println("Sub class show method");
		return new Beta();
	}
}

public class IncompatibleReturnType {

	public static void main(String[] args) 
	{
		Super s = new Sub();
		s.show();

	}

}
-----------------------------------------------------------------------
package com.ravi.covariant;

class Student
{
	public Object course()
	{
		System.out.println("Generic Course");
		return null;
	}
}
class JavaStudent extends Student
{
	public Integer course()
	{
		System.out.println("Java Student");
		return null;
	}
}

public class CoVariant 
{
	public static void main(String[] args) 
	{
		Student s = new JavaStudent();  s.course();

	}

}
-----------------------------------------------------------------------
05-02-2024
----------
Variable Shadow :
-----------------
If the super class variable name and sub class variable name both are same then it is known as variable shadow.
With the reference variable, whenever we call variable then always it will take the preference of class type so, in the below example b is a reference variable of type Bird so Bird class variable will be invoked.
------------------------------------------------------------------------
package com.ravi.stream_intermediate;

class Bird
{
	String name = "General Bird";
	
	public String roam()
	{
		return "Generic Bird is roaming";
	}
}
class Parrot extends Bird
{
	String name = "Parrot Bird";  //Variable Shadow
	
	@Override
	public String roam()
	{
		return "Parrot Bird is roaming";
	}
}
public class MethodOverridingVariableShadow 
{
	public static void main(String[] args) 
	{
		Bird b = new Parrot();
		
		System.out.println(b.name + ": "+b.roam());

	}

}
-----------------------------------------------------------------------
* Can we override static method ?
              OR
* Can we override main method?
              OR
* What is Method Hiding in java?


Point 1)
--------
We cannot override static method but static methods can be inherited as shown in the program below.

class Alpha
{
	static void m1()
	{
		System.out.println("Alpha class method");
	}
}
class Beta extends Alpha
{
	
}

public class StaticMethodPresence {

	public static void main(String[] args) 
	{
		Beta.m1();  //calling with sub class name
		Beta b = new Beta(); //calling with sub class object ref
		b.m1();

	}

}
---------------------------------------------------------------------
Point 2) 

We cannot override any static method with non-static method otherwise 
we will get compilation error i.e. Overridden method is static.

class Alpha
{
	public static void m1()
	{
		System.out.println("m1 static method");
	}
}
class Beta extends Alpha
{
	public void m1()
	{
		System.out.println("m1 non-static method");
	}
}

public class StaticMethodOvderridingWithNonStaticMethod 
{
	public static void main(String[] args) 
	{
		
	}

}
----------------------------------------------------------------------
Point 3)
We cannot override any non-static method with static method otherwise we will get error Overriding method is static.

class Alpha
{
	public  void m1()
	{
		System.out.println("m1 non static method");
	}
}
class Beta extends Alpha
{
	public static void m1()
	{
		System.out.println("m1 static method");
	}
}
public class OverridingNonStaticWithStatic 
{
	public static void main(String[] args) 
	{
	
	}
}



So, the conclusion is we cannot overide static with non static method as well as non-static with static method because static method belongs to class and non-static method belongs to object.
-----------------------------------------------------------------------
Point 4)
--------
If we write static methods in the super and sub class with same signature and same or return type then it looks like static method is overridden but actually it is METHOD HIDING. The sub class static method is hidden from super class static method as shown in the program.
----------------------------------------------------------------------
class Super
{
	public static void m1()
	{
		System.out.println("Static method of Super class");
	}
}
class Sub extends Super
{
	//Method Hiding
	public static void m1()
	{
		System.out.println("Static method of Sub  class");
	}
}
public class Test
{
	public static void main(String[] args) 
	{
		Super s1 = new Sub();
		s1.m1();
		
	}
}

Here we will get the output :- static method of super class

Note :- We cannot apply @Override annoatation on static methods.
-----------------------------------------------------------------------
Progran that shows whenever we write static method in the sub class 
then it is method hiding.

class Super
{
	public static void m1()
	{
	}
}
class Sub extends Super
{
	public static int m1() //error cannot hide
	{
		return 0;
	}
}public class Test
{
	public static void main(String[] args) 
	{
		Super s1 = new Sub();
		s1.m1();
		
	}
}
----------------------------------------------------------------------
private method of a class is not available to sub class but static method of super class is available to sub class so we can hide the static method.

NOte :- main method can be overloaded but main method cannot be overridden (Method Hiding).
-----------------------------------------------------------------------
06-02-2024
-----------
final keyword in java :
-----------------------
It is used to provide some kind of restriction in our program.
We can use final keyword in ways 3 ways in java.

1) To declare a class as a final. (Inheritance is not possible)
2) To declare a method as a final (Overriding is not possible)
3) To declare a variable (Field) as a final (Re-assignment is not possible)

To declare a class as a final :
-------------------------------
Whenever we declare a class as a final class then we cann't extend or inherit that class otherwise we will get a compilation error.

We should declare a class as a final if the composition of the class (logic of the class) is very important and we don't want to share the feature of the class to some other developer to modify the original behavior of the existing class, In that situation we should declare a class as a final.

Declaring a class as a final does not mean that the variables and methods declared inside the class will also become as a final, only the class behavior is final that means we can modify the variables value as well as we can create the object for the final classes.

Note :- In java String and All wrapper classes are declared as final class.
----------------------------------------------------------------
final class A
{
	private int x = 100;
	public void setData()
	{
		x = 120;
		System.out.println(x);
	}
}
class B extends A 
{   
}
public class FinalClassEx
{
	public static void main(String[] args)
	{
		B b1 = new B();
		b1.setData();		
	}
}

Note : We will get compilation error because super class is final
-----------------------------------------------------------------
final class Test
{
	private int data = 100;

	public void setData(int data)
	{
		this.data = data;
		System.out.println("Data value is :"+data);
	}
}
public class FinalClassEx1 
{
	public static void main(String[] args) 
	{
		Test t1 = new Test();
		t1.setData(200);
	}
}

Note :- We can create an object for final class as well as we can
modify the final class data.
----------------------------------------------------------------
Sealed class in Java :
-----------------------
It is a new feature introduced from java 15.

It is an improvement over final keyword.

By using sealed keyword we can declare classes and interfaces as sealed.

It is one kind of restriction that describes which classes and interfaces can extends or implement from Sealed class Or interface

It is similar to final keyword with less restriction because here we can permit the classes to extend from the original Sealed class.

The class which is inheriting from the sealed class must be final, sealed or non-sealed.

The sealed class must have atleast one sub class.

We can also create object for Sealed class.

It provides the following modifier :

1) sealed : Can be extended only through permitted class.

2) non-sealed : Can be extended by any sub class, if a user wants to give permission to its sub classes 

3) permits : We can provide permission to the sub classes, which are inheriting through Sealed class.

4) final : we can declare permitted sub class as final so, it cannot be extended further.
----------------------------------------------------------------
SealedDemo1.java
-----------------
package com.ravi.sealed_demo;

sealed class Bird permits Parrot, Peacock
{
	public void roam()
	{
      System.out.println("Bird is roaming");		
	}
}
non-sealed class Parrot extends Bird
{
	public void roam()
	{
      System.out.println("Parrot is roaming");		
	}
}

non-sealed class Peacock extends Bird
{
	public void roam()
	{
      System.out.println("Peacock is roaming");		
	}
}

public class SealedDemo1 {

	public static void main(String[] args) 
	{
		Bird b ;
		
		b = new Parrot(); b.roam();
		b = new Peacock(); b.roam();
	}

}
---------------------------------------------------------------
package com.ravi.sealed_demo;

sealed class OnlineClass permits Laptop, Mobile
{
	public void attendOnlineJavaClass()
	{
		System.out.println("Online Java class on Sunday");
	}
}
non-sealed class Laptop extends OnlineClass
{
	@Override
	public void attendOnlineJavaClass()
	{
		System.out.println("Online Java class by Laptop");
	}
}

final class Mobile extends OnlineClass
{
	@Override
	public void attendOnlineJavaClass()
	{
		System.out.println("Online Java class by Mobile");
	}
}

public class SealedDemo2 
{
	public static void main(String[] args) 
	{
       OnlineClass cls = null;
       cls = new Laptop(); cls.attendOnlineJavaClass();
       cls = new Mobile(); cls.attendOnlineJavaClass();

	}

}

Note :- By using sealed class concept we can provide permission 
        to the sub classes which belongs to a particular category
----------------------------------------------------------------
2) To declare a method as a final (Overriding is not possible)
-----------------------------------------------------------------
Whenever we declare a method as a final then we can't override that method in the sub class otherwise there will be a compilation error.

We should declare a method as a final if the body of the method i.e the implementation of the method is very important and we don't want to override or change the super class method body by sub class method body then we should declare the super class method as final method.

class A
{
	protected int a = 10;
	protected int b = 20;

     public final void calculate()
	  {
		int sum = a+b;
		System.out.println("Sum is :"+sum);
	  } 
}
class B extends A
{	
	@Override
	public void calculate() 
	{
		int mul = a*b;
		System.out.println("Mul is :"+mul);	
	}
}
public class FinalMethodEx 
{
	public static void main(String [] args) 
	{
		 A a1 = new B();
		 a1.calculate();
	}
}
-----------------------------------------------------------------
class A
{
	protected int a = 10;
	protected int b = 20;

      private final void calculate()
	  {
		int sum = a+b;
		System.out.println("Sum is :"+sum);
	  } 
}
class B extends A
{
	public void calculate() 
	{
		int mul = a*b;
		System.out.println("Mul is :"+mul);	
	}
}
public class FinalMethodEx1 
{
	public static void main(String [] args) 
	{
		new B().calculate();
	}
}

The above program will compile fine and will generate output.
---------------------------------------------------------------
3) To declare a variable or Field as a final :
----------------------------------------------
3) To declare a variable(field) as a final :(Re-assignment is not possible)
-----------------------------------------------------------------
In older langugaes like C and C++ we use "const" keyword to declare a constant variable but in java const is a reserved word for future use so instead of const we should use "final" keyword.

If we declare a variable as a final then we can't perform re-assignment (i.e nothing but re-initialization) of that variable.

In java It is always a better practise to declare a final variable by uppercase letter according to the naming convention.

Some example of predefined final variables 

Byte.MIN_VALUE   -> MIN_VALUE is a static and final variable

Byte.MAX_VALUE  -> MAX_VALUE is a static and final variable

Example:- final int DATA = 10; (Now we can not perform re-assignment )
----------------------------------------------------------------
class A
{
	final int A = 10;      
	public void setData()
	{
		 A = 10;  //error[Re-assignment is not possible]
		 System.out.println("A value is :"+A);
	}
}
class FinalVarEx 
{
	public static void main(String[] args) 
	{
		A a1 = new A();
		a1.setData();
	}
}
---------------------------------------------------------------
class FinalVarEx1 
{
	public static void main(String[] args) 
	{
		final int A = 127;
		byte b = A;
		System.out.println(b);
	}
}
-----------------------------------------------------------------
07-02-2024
----------
Different kinds of final variable :
------------------------------------
package com.ravi.composition_using_final;

public class FinalVarTest 
{
    final int A = 12;
    static final int B = 24;
    
    public void accept(final int C)
    {
    	System.out.println("A value is :"+A);
    	System.out.println("B value is :"+FinalVarTest.B);
    	System.out.println("C value is :"+C);
    }
    
	public static void main(String[] args) 
	{
		final FinalVarTest v = new FinalVarTest();
		v.accept(36);
			
	}
}
-----------------------------------------------------------------
//Composition with final keyword so another Engine Object will not be created

package com.ravi.composition_using_final;

class Engine
{
	private int horsePower;
	private String engineType;
	
	public Engine(int horsePower, String engineType) 
	{
		super();
		this.horsePower = horsePower;
		this.engineType = engineType;
	}

	@Override
	public String toString() {
		return "Engine [horsePower=" + horsePower + ", engineType=" + engineType + "]";
	}
}
class Car 
{
	private String carName;
	private int carModel;
	private final Engine engine; //HAS-A Relation
	
	public Car(String carName, int carModel)
	{
		this.carName = carName;
		this.carModel = carModel;
		this.engine = new Engine(1200, "Battery"); //Composition
	}

	@Override
	public String toString() {
		return "Car [carName=" + carName + ", carModel=" + carModel + ", engine=" + engine + "]";
	}
}

public class CompositionDemo {

	public static void main(String[] args) 
	{
		Car c = new Car("Ford", 2024);
	}

}
---------------------------------------------------------------
Blank final variable :
-----------------------
If a final variable is declared without initialization then it is called blank final variable.

Example : final int A; //Blank final variable

The default constructor cannot initialized blank final variable because final variable initialization is possible only one time.

The final variable must be initialized either at the time of declaration or through constructor/instance block only.[Not through Methods]

If we have a blank final variable in the class then it must be initialized through all the constructors available in the class.

---------------------------------------------------------------
public class BlankFinalVar 
{
	final int A; 
	
	public static void main(String[] args) 
	{
		BlankFinalVar fv = new BlankFinalVar();
		System.out.println(fv.A);
	}
}

Note :- default constructor cannot provide default value for the blank final variable.
----------------------------------------------------------------
class Demo
{	
	final int A; // blank final variable
	
	public Demo()  //No Argument constructor
	{		
		A = 15;
		System.out.println(A);
	}

	public Demo(int x)  //parameterized constructor
	{		
		A = x;
		System.out.println(x);
	}   

}	
public class  BlankFinalVariable
{
	public static void main(String[] args) 
		{		
	         Demo d1 = new Demo(); //d1 -> A = 15 

			 Demo d2 = new Demo(8); //d2 -> A = 8	 
	    }
}

Note :- For blank final variable, user is resonsible to initialize at the time of declaration OR through instance block/Constructor only.
----------------------------------------------------------------
How to create an immutable(un-modifiable) class :
-------------------------------------------------
//Program to create an immutable(unchanged) class 

final class Citizen  
{    
	private final String aadharNumber;    //Blank final variable
	public Citizen(final String aadharNumber)
	{
		if(aadharNumber.length() == 12)
		{
		this.aadharNumber = aadharNumber;
		}
		else
		{
		   this.aadharNumber = aadharNumber;
		  System.err.println("Invalid Aadhar Number");
		}
	}

	public String getAadharNumber()
	{    
		return aadharNumber;    
	}    
}    
public class ImmutableClass  
{  
	public static void main(String ar[])  
		{  
			final Citizen ravi = new Citizen("987667897868");
			System.out.println("Ravi Aadhar Number is :"+ravi.getAadharNumber());	
			  
		}  
} 

Note :- we can make a class as immutable class by using following

  a) declare the class as a final
  b) declare the variable as private and  final
  c) declare the object reference as a final
----------------------------------------------------------------
Object class in java :
----------------------
Working with Object class and its methods :
--------------------------------------------------
There is a predefined class called Object available in java.lang package, this Object class is by default the super class of all the classes we have in java.

class Test 
{

}

Note :- Object is the super class for this Test class. by default this Object class is super class so explicitly we need not to mention.

Since, Object is the super class of all the classes in java that means we can override the method of Object class (Except final methods) as well as we can use the methods of Object class anywhere in java because every class is sub class of Object class.

The Object class provides some common behavior to each sub class Object like we can compare two objects , we can create clone (duplicate) objects, we can print object properties(instance variable), providing a unique number to each and every object(hashCode()) and so on.

---------------------------------------------------------------
What is method chaining ?
--------------------------
By using this concept we can call n number of method in a single statement.

The next method call always depends upon current method return type.

The final return type of the method will depend upon last method call.
--------------------------------------------------------------
public class MethodChainingDemo {

	public static void main(String[] args) 
	{
		String str = "india";
	    int len =	str.concat(" is great").toUpperCase().length();
	    System.out.println(len);
	    
	    String str1 = "india";
	    char ch = str1.concat(" is great").toUpperCase().charAt(1);
	    System.out.println(ch);
	}

}
----------------------------------------------------------------
public native final java.lang.Class getClass() :
-------------------------------------------------
It is a predefined method of Object class.

This method returns the runtime class of the object, the return type of this method is java.lang.Class.

This method will provide class keyword + Fully Qualified Name (package name + class name)

This getClass() method return type is java.lang.Class so further we can apply any other method of java.lang.Class class method.
---------------------------------------------------------------
2 files (Both are in different package)
-----------------------------------------
Demo.java (com.nit.reuse)
-------------------------
package com.nit.reuse;

public class Demo {

}

GetClassDemo1.java
-------------------

package com.ravi.object_class;

import com.nit.reuse.Demo;

public class GetClassDemo1 
{
	public static void main(String[] args) 
	{
		Demo d = new Demo();
		System.out.println(d.getClass());
	}

}
---------------------------------------------------------------
The following program will provide Fully Qualified name of the class.

String fullyQualifiedName = getClass().getName();

2 files :
----------
Demo.java(com.nit.reuse)

package com.nit.reuse;

public class Demo {

}

GetClassDemo2.java
-------------------
package com.ravi.object_class;

import com.nit.reuse.Demo;

public class GetClassDemo2 
{
  public static void main(String[] args) 
  {
	Demo d1 = new Demo();
	String name = d1.getClass().getName();
	System.out.println(name);
  }
}
---------------------------------------------------------------
public native int hashCode() :-
-----------------------------
It is a predefined method of Object class.

Every Object contains a unique number generated by JVM at the time of Object creation is called hashCode.

we can find out the hashCode value of an Object by using hashCode() method of Object class, return type of this method is int.
----------------------------------------------------------------
package com.ravi.object_class;

class Test
{
	
}
public class HashCodeDemo1 
{
	public static void main(String[] args)
	{
		Test t1 = new Test();
		Test t2 = t1;
		System.out.println(t1.hashCode()+" : "+t2.hashCode());
		
		System.out.println("...............");
		
		Test t3 = new Test();
		Test t4 = new Test();
		System.out.println(t3.hashCode()+" : "+t4.hashCode());
	}

}
---------------------------------------------------------------
09-02-2024
----------
3) public String toString() :
----------------------------
It is a predefined method of Object class.

it returns a string representation of the object. In general, the toString method returns a string that "textually represents" this object. The result should be a concise but informative representation that is easy for a person to read

toString() method of Object class conatins following logic.

public String toString()
{
	return getClass().getName()+" @ "+Integer.toHexString(hashCode());   
}

Please note internally the toString() method is calling the hashCode() and getClass() method of Object class.

In java whenever we print any Object reference by using System.out.println() then internally it will invoke the toString() method of Object class as shown in the following program.
-----------------------------------------------------------------
package com.ravi.object_class;

class Customer
{
	
}

public class ToSTringMethodDemo1 
{
	public static void main(String[] args) 
	{
		Customer c1 = new Customer();
		System.out.println(c1);
	}

}
-----------------------------------------------------------------
//Program on Overridden toString() method :
-------------------------------------------
package com.ravi.object_class;

class Student
{
   @Override
   public String toString()
   {
	   return "Student class object in String representation";
   }   
}

public class ToSTringMethodDemo2 
{
	public static void main(String[] args) 
	{
		Student s1 = new Student();
		System.out.println(s1);
	}

}
----------------------------------------------------------------
4) public boolean equals(Object obj) :
---------------------------------------
It is predefined method of Object class.

It is mainly used to compare two objects besed on the memory address just like == opeartor because internally, It uses == opeartor only.

The following program explains how to use equals(Object obj) method for Customer comparison.

package com.ravi.object_class;

class Manager {
	private int managerId;
	private String managerName;

	public Manager(int managerId, String managerName) {
		super();
		this.managerId = managerId;
		this.managerName = managerName;
	}

}

public class EqulasDemo1 {
	public static void main(String[] args) 
	{
	  Manager m1 = new Manager(111,"Scott");
	  Manager m2 = new Manager(222,"Smith");
	  Manager m3 = new Manager(111,"Scott");
	  
	  System.out.println(m1.equals(m2));
	  System.out.println(m1.equals(m3));

	}

}
-----------------------------------------------------------------
In the above program m1 and m3 is having same content but due to memory address comparison it is providing false.

If we want to compare these two objects based the content but not based on the memory address then we should override equals(Object obj) method of Object class.

Overriding equals(Object obj) for content comparison :
------------------------------------------------------
package com.ravi.equals;

class Customer
{
	private int customerId;
	private String customerName;
	
	public Customer(int customerId, String customerName) {
		super();
		this.customerId = customerId;
		this.customerName = customerName;
	}
	
	//Overriding equals() method for content comparison
	@Override
	public boolean equals(Object obj) //obj = c2 (2000x)
	{
		//First Object content
		int id1 = this.customerId;
		String name1 = this.customerName;
		
		//2nd object data
		Customer c2 = (Customer) obj;
		int id2 = c2.customerId;
		String name2 = c2.customerName;
		
		if(id1==id2  && name1.equals(name2))
		{
			return true;
		}
		else
		{
			return false;
		}
		
	}		
}
public class EqualsMethodDemo2 
{
	public static void main(String[] args) 
	{
		Customer c1 = new Customer(1,"Scott"); //1000x
		Customer c2 = new Customer(1,"Scott"); //2000x
		System.out.println(c1.equals(c2));

	}

}
-----------------------------------------------------------------
One more program for Overriding the equals() method :
-----------------------------------------------------
package com.ravi.equals;

class Student
{
	private int studentId;
	private String studentName;
	
	public Student(int studentId, String studentName) {
		super();
		this.studentId = studentId;
		this.studentName = studentName;
	}
	
	@Override
	public boolean equals(Object obj)
	{
		Student s2 = (Student) obj;
		
		if(this.studentId == s2.studentId && this.studentName.equals(s2.studentName))
		{
			return true;
		}
		else
		{
			return false;
		}
	}
}

public class EqualsDemo3 
{
	public static void main(String[] args) 
	{
		Student s1 = new Student(1,"Rohan");
		Student s2 = new Student(1,"Rohan");
		
		System.out.println(s1.equals(s2));
	}

}
-----------------------------------------------------------------
10-02-2024
-----------
instanceof Operator :
----------------------
It is a keyword as well as an operator.

It is used to verify whether a reference variable refers to a particular type of object or not?

It will return boolean value.

While working with instanceof operator there must be a IS-A 
relationship between reference variable and the class/interface type otherwise we will get compilation error. 

public class Test
{
	public static void main(String[] args) 
	{
		String str = "India";

        if(str instanceof String)
		{
			System.out.println("str is pointing to String object");
		}
        System.out.println("...........");

        String s1 = "Hyderabad";

		if(s1 instanceof Object)
		{
			System.out.println("s1 is pointing to String object");
		}
		else
		{
			System.out.println("s1 is pointing to StringBuffer object");
		}
		System.out.println("...........");

		Integer i = 90;
		if(i instanceof Number)
		{
			System.out.println(" i is pointing to Integer object");
		}

	}
}
----------------------------------------------------------------
WAP in java where we want to compare two objects of two different types 

package com.ravi.equlas_demo;

class Employee
{
	private Integer studentId;
	private String studentName;
	public Employee(Integer studentId, String studentName) {
		super();
		this.studentId = studentId;
		this.studentName = studentName;
	}
}

class Student
{
   private Integer studentId;
   private String studentName;
	public Student(Integer studentId, String studentName) {
		super();
		this.studentId = studentId;
		this.studentName = studentName;
	}   
	
	@Override
	public boolean equals(Object obj)
	{
		if(obj instanceof Student)
		{
			Student s2 = (Student)obj;
			if(this.studentId == s2.studentId && this.studentName.equals(s2.studentName))
			{
				return true;
			}
			else
			{
				return false;
			}
			
			
			
		}
		else
		{
			System.err.println("Comparison is not possible");
			return false;
		}
	}	
}

public class EqualsComparison 
{
	public static void main(String[] args) 
	{
		Student s1 = new Student(1, "Scott");
		Student s2 = new Student(1, "Scott");		
		Employee e1 = new Employee(1,"Scott");
		
		System.out.println(s1.equals(s2));
		System.out.println(s1.equals(e1));
		System.out.println(s1.equals(null));
	}
}

Note :

1) If we compare two different objects then compiler will generate warning as well as by using instanceof operator we can avoid this comparison.

2) null with instanceof operator will always return false.
----------------------------------------------------------------
Record class in java :
-----------------------
public abstract class Record extends Object.

It is a new feature introduced from java 17.(In java 14 preview version)

As we know only objects are moving in the network from one place to another place so we need to write BLC class with nessacery requirements to make BLC class as a Data carrier class.

Records are immutable data carrier so, now with the help of record we can send our immutable data from one application to another application.

It is also known as DTO (Data transfer object) OR POJO classes.

It is mainly used to concise our code as well as remove the boiler plate code.

In record, automatically constructor will be generated which is known as canonical constructor and the variables which are known as components are by default final.

In order to validate the outer world data, we can write our own constructor which is known as compact constructor.

Record will automatically generate the implemenation of toString(), equals(Object obj) and hashCode() method.

We can define static and non static method as well as static variable inside the record. We cannot define instance variable inside the record.

We cann't extend or inherit records because by default every record is implicilty final. It is extending from java.lang.Reocrd class

We can implement an interface by using record.

We don't have setter facility in record because by default variables are final.

3 files :
---------
EmployeeClass.java(C)
-----------------------
package com.ravi.record;

import java.util.Objects;

public class EmployeeClass {
	private int employeeId;
	private String employeeName;

	public EmployeeClass(int employeeId, String employeeName) {
		super();
		this.employeeId = employeeId;
		this.employeeName = employeeName;
	}

	public int getEmployeeId() {
		return employeeId;
	}

	public String getEmployeeName() {
		return employeeName;
	}

	@Override
	public String toString() {
		return "EmployeeClass [employeeId=" + employeeId + ", employeeName=" + employeeName + "]";
	}

	@Override
	public int hashCode() {
		return Objects.hash(employeeId, employeeName);
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		EmployeeClass other = (EmployeeClass) obj;
		return employeeId == other.employeeId && Objects.equals(employeeName, other.employeeName);
	}
}

EmployeeRecord.java(R)
-----------------------

package com.ravi.record;

              //Canonical Constructor
public record EmployeeRecord(int empId, String empName) 
{
	//Compact Constructor
	public EmployeeRecord
	{
		if(empId < 0)
		{
			System.err.println("Invalid ID");
		}
	}
}

RecordDemo.java(C)
------------------
package com.ravi.record;

public class RecordDemo 
{
	public static void main(String[] args) 
	{
		EmployeeClass e1 = new EmployeeClass(1, "Scott");
		EmployeeClass e2 = new EmployeeClass(1, "Scott");
		System.out.println(e1.equals(e2));
		System.out.println(e2);
		System.out.println(e1.getEmployeeName());
		
		
		System.out.println(".........................");
		EmployeeRecord r1 = new EmployeeRecord(2, "Smith");
		EmployeeRecord r2 = new EmployeeRecord(2, "Smith");
		System.out.println(r1.equals(r2));
		System.out.println(r2);
		System.out.println(r2.empName());
	}

}
----------------------------------------------------------------
12-02-2024
----------
Abstract class and abstract methods :
-------------------------------------------
A class that does not provide complete implementation (partial implementation) is defined as an abstract class.

An abstract method is a common method which is used to provide easiness to the programmer because the programmer faces complexcity to remember the method name.

An abstract method observation is very simple because every abstract method contains abstract keyword, abstract method does not contain any method body and at the end there must be a terminator i.e ; (semicolon)

In java whenever action is common but implementations are different then we should use abstract method, Generally we declare abstract method in the super class and its implementation must be provided in the sub classes.

if a class contains at least one method as an abstract method then we should compulsory declare that class as an abstract class.

Once a class is declared as an abstract class we can't create an object for that class.

*All the abstract methods declared in the super class must be overridden in the sub classes otherwise the sub class will become as an abstract class hence object can't be created for the sub class as well.

In an abstract class we can write all abstract method or all concrete method or combination of both the method. 

It is used to acheive partial abstraction that means by using abstract classes we can acheive partial abstraction(0-100%).

*An abstract class may or may not have abstract method but an abstract method must have abstract class.

Note :- We can't declare an abstract method as final, private and static (illegal combination of modifiers)
-----------------------------------------------------------------
BirdDemo.java
--------------
abstract class Bird
{
	public abstract void fly();	
}
class Parrot extends Bird
{
	@Override
	public void fly()
	{
		System.out.println("Parrot can fly");
	}
}
class Sparrow extends Bird
{
	@Override
	public void fly()
	{
		System.out.println("Sparrow can fly");
	}
}

public class BirdDemo 
{
	public static void main(String[] args) 
	{
		Bird b;

		b = new Parrot(); b.fly();
		b = new Sparrow(); b.fly();
	}
}
---------------------------------------------------------------
abstract class Car
{
	protected int speed = 80;

	public Car()
	{
		System.out.println("Car class Constructor!!");
	}

	public void getDetails()
	{
		System.out.println("It has 4 wheels and one Engine");
	}

	public abstract void run();
}

class Honda extends Car
{
	@Override
	public void run()
	{
		System.out.println("Honda Car is Running");
	}
}

public class InterviewQuestion 
{
	public static void main(String[] args) 
	{
		Car c = new Honda();
		System.out.println("Speed is :"+c.speed);
		c.getDetails();
		c.run();
	}
}

****Note :- In an abstract class if we have any constructor then it will be executed by sub class object using super keyword.
-----------------------------------------------------------------
13-02-2024
-----------
What is the advantage of writing constructor in abstract class?
----------------------------------------------------------------
If my abstract class contains any properties (state OR Data) then we can initialize those properties of abstract class with the help of sub class object by using super keyword as shown in the program below.

ShapeDemo.java
---------------

package com.ravi.abstract_demo;

abstract class Shape
{
	protected String shapeType;
	
	public Shape(String shapeType)
	{
		this.shapeType = shapeType;
	}
	
	public abstract String getTypeOfShape();	
}

class Rectangle extends Shape
{
	public Rectangle(String type)
	{
		super(type);
	}
	
	@Override
	public String getTypeOfShape() 
	{
		return shapeType;
	}
}

class Circle extends Shape
{
	public Circle(String type)
	{
		super(type);
	}
	
	@Override
	public String getTypeOfShape() 
	{
		return shapeType;
	}
}

public class ShapeDemo 
{
	public static void main(String[] args) 
	{
		Shape s = new Rectangle("Rectangle");
		System.out.println(s.getTypeOfShape());
		
		Shape s1 = new Circle("Circle");
		System.out.println(s1.getTypeOfShape());
	}
}
----------------------------------------------------------------
Program that describes if we don't override abstract methods then sub class will also become as abstract class

package com.ravi.abstract_demo;

abstract class Alpha
{
	public abstract void show();
	public abstract void demo();	
}

abstract class Beta extends Alpha
{
	@Override
	public void show() 
	{
	 System.out.println("Show method implemented in Alpha class");		
	}		
}
class Gamma extends Beta
{
	@Override
	public void demo() 
	{
	  System.out.println("Demo method implemented in Beta class");		
	}
}

public class AbstractDemo 
{
	public static void main(String[] args)
	{
		Gamma g = new Gamma(); g.show(); g.demo();
	}

}
-----------------------------------------------------------------
Program on abstract class and method, abstract method which is common for all.

5 files :
--------
Shape.java
----------
package com.ravi.abstract_demo_ex;

public abstract class Shape 
{
  protected int x;
  
  public Shape(int x)
  {
	  this.x = x;
  }
	
  public abstract void area();
}


Rectangle.java
---------------
package com.ravi.abstract_demo_ex;

public class Rectangle extends Shape
{
	protected int breadth;
	public Rectangle(int l, int b)
	{
		super(l);
		breadth = b;
	}

	@Override
	public void area() 
	{
		double area = x * breadth;
		System.out.println("Area of Rectangle is :"+area);
		
	}
}

Square.java
------------
package com.ravi.abstract_demo_ex;

public class Square extends Shape
{
	public Square(int side) 
	{
		super(side);		
	}
	
	@Override
	public void area() 
	{
		double area = x * x;
		System.out.println("Area of Square is :"+area);
		
	}

}



Circle.java
------------
package com.ravi.abstract_demo_ex;

public class Circle extends Shape
{
    final double  PI = 3.14;
	public Circle(int radius)
	{
		super(radius);
	}
	
	@Override
	public void area() 
	{
		double area = PI * x*x;
		System.out.println("Area of Circle is :"+area);
		
	}
}

ShapeDemo.java
--------------
package com.ravi.abstract_demo_ex;

public class ShapeDemo 
{
   public static void main(String[] args) 
   {
	  Shape s = null;
	  
	  s = new Rectangle(5, 9); s.area();
	  
	  s = new Square(40); s.area();
	  
	  s = new Circle(9); s.area();
   }
}
-----------------------------------------------------------------
Abstract class with array concept
----------------------------------
package com.ravi.abstract_array;

abstract class Animal
{
	public abstract void checkup();
}

class Bird extends Animal
{
	@Override
	public void checkup()
	{
		System.out.println("Bird Check up");		
	}	
}

class Lion extends Animal
{
	@Override
	public void checkup()
	{
		System.out.println("Lion Check up");		
	}
	
}

class Dog extends Animal
{
	@Override
	public void checkup()
	{
		System.out.println("Dog Check up");		
	}
	
}

class CheckUp
{
	public static void AnimalCheckUp(Animal animals[])
	{
		for(Animal animal : animals)
		{
			animal.checkup();
		}
	}
}

public class AbstractDemo 
{
	public static void main(String[] args) 
	{
		Bird []birds = {new Bird(), new Bird(), new Bird()};
		Lion []lions = {new Lion(), new Lion()};
		Dog [] dogs = {new Dog(), new Dog(), new Dog()};
		
		CheckUp.AnimalCheckUp(birds);
		CheckUp.AnimalCheckUp(lions);
		CheckUp.AnimalCheckUp(dogs);

	}

}
-----------------------------------------------------------------
15-02-2024
-----------
interface upto java 1.7
------------------------
An interface is a keyword in java which is similar to a class which defines working functionality of a class.

Upto JDK 1.7 an interfcae contains only abstract method that means there is a guarantee that inside an interfcae we don't have concrete or general or instance methods.

From java 8 onwards we have a facility to write default and static methods.

By using interface we can achieve 100% abstraction concept because it contains only abstract methods.

In order to implement the member of an interface, java software people has provided implements keyword.

All the methods declared inside an interface is by default public and abstract so at the time of overriding we should apply public access modifier to sub class method.

All the variables declared inside an interface is by default public, static and final.

We should override all the abstract methods of interface to the sub classes otherwise the sub class will become as an abstract class hence object can't be created.

We can't create an object for interface, but reference can be created.

By using interfcae we can acheive multiple inheritance in java.

We can achieve loose coupling using inetrface.

Note :- inside an interface we can't declare any blocks (instance, static), instance variables (No properties) as well as we can't write constructor inside an interface.
-----------------------------------------------------------------
3 Files :
---------
Moveable.java(I)
----------------
package com.ravi.interface_demo;

public interface Moveable 
{
   int SPEED = 100; //public + static + final
   void move();  //public + abstract
}


Car.java(C)
-----------
package com.ravi.interface_demo;

public class Car implements Moveable
{
	@Override
	public void move() 
	{
		//SPEED = 120;	//Invalid	
		System.out.println("Car speed is :"+SPEED);
	}

}


Main.java(C)
------------
package com.ravi.interface_demo;

public class Main {

	public static void main(String[] args) 
	{
		Moveable m = new Car();
		m.move();
		System.out.println(Moveable.SPEED);

	}

}
-----------------------------------------------------------------
package com.ravi.pack_inter;

import java.util.Scanner;

interface Bank
{
	public void deposit(int amount);
	public void withdraw(int amount);
}

class Customer implements Bank
{
    private double balance = 10000;
    
	@Override
	public void deposit(int amount) 
	{
		if(amount < 0)
		{
			System.err.println("Can't be deposited");
		}
		else
		{
			balance = balance + amount;
			System.out.println("After deposit :"+balance);
		}
	}

	@Override
	public void withdraw(int amount) 
	{
		if(amount < balance)
		{
		 balance = balance - amount;
		 System.out.println("Balance after withdraw :"+balance);
		}
		else
		{
			System.err.println("Insufficient Balance ");
		}
		
	}	
}

public class BankApplication 
{
	public static void main(String[] args) 
	{
		Customer c1 = new Customer();
		
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter the amount u want to deposit :");
		int dep = sc.nextInt();
		c1.deposit(dep);
		
		System.out.print("Enter the amount u want to withdraw :");
		int wit = sc.nextInt();
	    c1.withdraw(wit);
		
		
	}

}
---------------------------------------------------------------
Assignment :
-------------
Take one interface Calculator which contains the following abstract methods :
  
     void doSum(int x, int y);
     void doSub(int x, int y);
     void doMul(int x, int y);

Take one class to implement all the abstract methods of Calculator interface.
----------------------------------------------------------------
16-02-2024
----------
Program to achieve loose coupling using interface :
---------------------------------------------------
Program on loose coupling :
----------------------------
Loose Coupling :- If the degree of dependency from one class object to another class is very low then it is called loose coupling.

Tightly coupled :- If the degree of dependency of one class to another class is very high then it is called Tightly coupled.

According to IT industry standard we should always prefer loose coupling so the maintenance of the project will become easy.

7 Files :
----------
HotDrink.java(I)
-----------------
package com.ravi.loose_coupling;

public interface HotDrink 
{
  public abstract void prepare();
}

Tea.java(C)
-----------
package com.ravi.loose_coupling;

public class Tea implements HotDrink 
{
	@Override
	public void prepare() 
	{
		System.out.println("Preparing Tea");		
	}

}

Coffee.java(C)
--------------
package com.ravi.loose_coupling;

public class Coffee implements HotDrink {

	@Override
	public void prepare() 
	{
		System.out.println("Preparing Coffee");		
	}

}

Boost.java(C)
--------------
package com.ravi.loose_coupling;

public class Boost implements HotDrink 
{
	@Override
	public void prepare() 
	{
		System.out.println("Preparing Boost");		
	}
}

Horlicks.java(C)
-----------------
package com.ravi.loose_coupling;

public class Horlicks implements HotDrink 
{
	@Override
	public void prepare() 
	{
		System.out.println("Preparing Horlicks");		
	}
}

Restaurant.java(C)
-------------------
package com.ravi.loose_coupling;

public class Restaurant 
{
   public static void acceptObject(HotDrink hd)
   {
	  hd.prepare(); 
   }
}

Main.java(C)
------------
package com.ravi.loose_coupling;

public class Main {

	public static void main(String[] args) 
	{
		Restaurant.acceptObject(new Tea());
		Restaurant.acceptObject(new Coffee());
		Restaurant.acceptObject(new Boost());
        Restaurant.acceptObject(new Horlicks());
	}

}

It is always better to take method return type as interface so we can return any implementer class object as shown in the example below

public HotDrink  accept()
{

   return new Tea() OR new Coffee() OR new Horlicks() OR any future
   implementer class object...........................
}
-------------------------------------------------------------------
Multiple Inheritance using interface :
---------------------------------------
Upto java 7, interface does not contain any method body that means all the methods are abstract method so we can achieve multiple 
inheritance by providing the logic in the implementer class as shown in the below program (Diagram 16-FEB-24)

In a class we have a constructor so, it is providing ambiguity issue but inside an interface we don't have constructor so multiple inheritance is possible using interface.

package com.ravi.mi;

interface A
{
	void m1();
}

interface B
{
	void m1();
}

class Implementer implements A,B
{
	@Override
	public void m1() 
	{
		System.out.println("Multiple Inheritance is possible");		
	}
}
public class MultipleInheritance 
{
	public static void main(String[] args) 
	{
	   Implementer i = new Implementer();
	   i.m1();
	}
}
-------------------------------------------------------------------
Extending interface :
---------------------
One interface can extends another interface, it cannot implement because interface cannot provide implementation for the abstract method.

package com.ravi.mi;

interface Alpha
{
	void m1();
}
interface Beta extends Alpha
{
	void m2();
}

class C implements Beta
{
	@Override
	public void m1() 
	{
		System.out.println("m1 method implemented");		
	}

	@Override
	public void m2() 
	{
		System.out.println("m2 method implemented");			
	}	
}

public class ExtendingInterface 
{
	public static void main(String[] args) 
	{
      C c1 = new C();
      c1.m1();  c1.m2();
	}

}
-------------------------------------------------------------------
New Features of Java (interface from java 1.8 onwards)
------------------------------------------------------
Limitation of abstract method :
           OR
Maintenance problem with interface in an Industry upto JDK 1.7
--------------------------------------------------------------
The major maintenance problem with interface is, if we add any new abstract method at the later stage of development inside an existing interface then all the implementer classes have to override that abstract method otherwise the  implementer class will become as an abstract class so it is one kind of boundation.

We need to provide implementation for all the abstract method available inside an interface whether it is required or not?

To avoid this maintenance problem java software people introduced default method inside an interface.
-----------------------------------------------------------------------
What is default Method inside an interface?
------------------------------------------------
default method is just like concrete method which contains method body and we can write inside an interface from java 8 onwards.

default method is used to  provide  specific implementation for the implementer classes which are implmenting from interface because we can override default method inside the sub classes to provide our own specific implementation.

*By using default method there is no boundation to override the default method in the sub class, if we really required it then we can override to provide my own implementation.

by default, default method access modifier is public so at the time of overriding we should use public access modifier.

4 Files :
-----------
Vehicle.java(I)
---------------
package com.ravi.java8;

public interface Vehicle 
{
  public abstract void run();
  public abstract void horn();
  
  default void digitalMeter() //java 1.8
  {
	  System.out.println("Digital meter");
  }
}


Bike.java(C)
-------------
package com.ravi.java8;

public class Bike implements Vehicle 
{
	@Override
	public void run() 
	{
		System.out.println("Bike is running");		
	}

	@Override
	public void horn() 
	{
		System.out.println("PEEP PEEP");		
	}

}


Car.java(C)
------------
package com.ravi.java8;

public class Car implements Vehicle 
{
	@Override
	public void run() 
	{
		System.out.println("Car is running");		
	}
	
	@Override
	public void horn() 
	{
		System.out.println("POP POP");		
	}
   
	 @Override
	 public void digitalMeter() //java 1.8
	  {
		  System.out.println("Car is having digital Meter");
	  }
	
	
	
}


Main.java(C)
------------
package com.ravi.java8;

public class Main {

	public static void main(String[] args) 
	{
		Vehicle v;
		
		v = new Bike(); v.run(); v.horn();
		
		v = new Car(); v.run(); v.horn(); v.digitalMeter();
	}

}
----------------------------------------------------------------
17-02-2024
----------
The following program explains that default methods are having low priority than normal methods (Concrete Method). class is having more power than interface.

MethodPriority.java
--------------------
package com.ravi.interface_default;

class A
{
	public void m1()
	{
		System.out.println("M1 method of class A");
	}
}

interface B
{
	default void m1()
	{
		System.out.println("M1 method of interface B");
	}
}

class C extends A implements B
{
	
}

public class MethodPriority 
{
	public static void main(String[] args) 
	{
		C c1 = new C();
		c1.m1();
	}

}
---------------------------------------------------------------
Can we override Object class method using default method?
---------------------------------------------------------
No, we cannot override object class method as a default method inside an interface.

interface Alpha
{
	public default String toString()
	{
		return "NIT";
	}
	
}

Here we will get compilation error because a default method cannot override method of Object class.
---------------------------------------------------------------
Multiple inheritance is possible in java by using default method inside an interface, here we need to use super keyword to differenciate the super interface methods.


MultipleInheritanceUsingDefault.java
-------------------------------------
package com.ravi.interface_default;

interface Alpha
{
	default void m1()
	{
		System.out.println("M1 method of Alpha interface");
	}
}

interface Beta
{
	default void m1()
	{
		System.out.println("M1 method of Beta interface");
	}
}

class Implementer implements Alpha, Beta
{
	@Override
	public void m1() 
	{
		System.out.println("M1 method implemented");	
		Alpha.super.m1();
		Beta.super.m1();
	}	
}

public class MultipleInheritanceUsingDefault 
{
	public static void main(String[] args) 
	{
		new Implementer().m1();

	}
}
----------------------------------------------------------------
What is static method inside an interface?
------------------------------------------
We can define static method inside an interface from java 1.8 onwards.

static method is only available inside the interface where it is defined that means we cannot invoke static method from the implementer classes.

It is used to provide common functionality which we can apply/invoke from any ELC class.

By default static method of an inetrafce contains public  access
modifier.
---------------------------------------------------------------
Calling static method of an interface using interface

package com.ravi.static_demo;

interface Calculator
{
	static double doSum(int x, int y)
	{
		return (x+y);
	}
	
	
	static double doSub(int x, int y)
	{
		return (x - y);
	}
}


public class InterfaceStaticMethod 
{
	public static void main(String[] args) 
	{
		double sum = Calculator.doSum(12, 12);
		System.out.println("Sum is :"+sum);
		
	   double sub = Calculator.doSub(100, 50);
	   System.out.println("Sub is :"+sub);
		
	}

}
---------------------------------------------------------------
Program that describes static method of an interface is available to interface only.

package com.ravi.interface_demo;

interface Callable
{
	public static void call()
	{
		System.out.println("call static method");
	}
}

public class StaticDemoInClass implements Callable
{
	public static void main(String[] args) 
	{
		Callable.call();
		//call(); error
		
		StaticDemoInClass s = new StaticDemoInClass();
		//s.call();//error
		
	}

}

---------------------------------------------------------------
The following program explains we can execute main method inside an interface without writing a class

package com.ravi.loose_coupling;

public interface Printable 
{
	public static void main(String[] args) 
	{
	  System.out.println("Printing main method");	
	}

}
----------------------------------------------------------------
Interface Static Method:
------------------------
   a) Accessible using the interface name.
   b) Cannot be overridden by implementing classes.
   c) Can be called using the interface name only.

Class Static Method:
--------------------
   a) Accessible using the class name.
   b) Can be hidden (not overridden) in subclasses by redeclaring a static method with the same signature.
   c) Can be called using the super class, sub class name as well as sub class object also as shown in the program below.

class A
{
	public static void m1()
	{
		System.out.println("Static method A");
	}
}
class B extends A
{
	
}
public class Demo
{
	public static void main(String [] args)
	{
           B.m1();  //valid
	   new B().m1(); //valid
	}
}
----------------------------------------------------------------
19-02-2024
----------
Working with Anonymous class :
------------------------------
Case 1:
------
Anonymous inner class with Concrete class :
-------------------------------------------

package com.ravi.anonymous;

class Super
{
	public void show()
	{
		System.out.println("Show method of Super class");
	}
}

public class AnonymousConcreteClass 
{
	public static void main(String[] args)
	{
		//Anonymous inner class
		Super sub = new Super()
		{
		   @Override
		   public void show()
		   {
			   System.out.println("Show method of sub class");
		   }	   
		  
		};			
	
		sub.show();  
	}

}
----------------------------------------------------------------
Case 2 :

Anonymous inner class with abstract class :
-------------------------------------------
package com.ravi.anonymous;

abstract class Demo
{
	public abstract void show();
}

public class AnonymousWithAbstract 
{
	public static void main(String[] args)
	{
		Demo d1 = new Demo()
		{
			@Override
			public void show() 
			{
				System.out.println("Show method implemented");				
			}			
		};
		d1.show();
	}

}
----------------------------------------------------------------
Case 3:
-------
Anonymous inner class with interface concept :
---------------------------------------------
package com.ravi.anonymous;

interface Vehicle
{
	void run();
}

public class AnonymousWithInterface
{
	public static void main(String[] args) 
	{
		//Anonymous inner class
		Vehicle bike = new Vehicle()
		{
			@Override
			public void run() 
			{
				System.out.println("Bike is running");				
			}			
		};
		bike.run();
	}

}
---------------------------------------------------------------
What is a Functional Interface in java ?
----------------------------------------
A functional interafce is an interface which contains exactly one abstract method.

It may contain 'n' number of default and static method but it 
must contain only one abstract method. (SAM => Single abstract Method)

It can be represented by @FunctionalInterface annotation.

FunctionalInterfaceDemo.java
----------------------------
package com.ravi.anonymous;

@FunctionalInterface
interface Exam
{
	void writeExam();  //SAM	
}

public class FunctionalInterfaceDemo 
{
	public static void main(String[] args) 
	{
		Exam java = new Exam()
		{
			@Override
			public void writeExam() 
			{
				System.out.println("Java students are writing exam");			
			}
			
		};
		
		Exam python = new Exam()
		{
			@Override
			public void writeExam() 
			{
				System.out.println("Python students are writing exam");			
			}
			
		};
		
		java.writeExam();   python.writeExam();
	}

}
----------------------------------------------------------------
Lambda Expression :
----------------------
It is a new feature introduced in java from JDK 1.8 onwards.
It is an anonymous function i.e function without any name.
In java it is used to enable functional programming.
It is used to concise our code as well as we can remove boilerplate code.
It can be used with functional interface only.
If the body of the Lambda Expression contains only one statement then curly braces are optional.
We can also remove the variables type while defining the Lambda Expression parameter.
If the lambda expression method contains only one parameter then we can remove () symbol also.

In lambda expression return keyword is optional but if we use return keyword then {} are compulsory.

Independently Lamda Expression is not a statement.

It requires a target variable i.e functional interface reference only.

Lamda target can't be class or abstract class, it will work with functional interface only.
----------------------------------------------------------------
package com.ravi.lambda;

@FunctionalInterface
interface Drawable
{
	void draw();   
}
public class Lambda1 
{
	public static void main(String[] args)
	{
	   Drawable rect = ()-> System.out.println("Drawing Rectangle");
	   rect.draw();
	   
	   Drawable circle = ()-> System.out.println("Drawing Circle");
	   circle.draw();
	   
	   Drawable square = ()-> System.out.println("Drawing Square");
	   square.draw();
	}

}
----------------------------------------------------------------
package com.ravi.lambda;

@FunctionalInterface
interface Calculator
{
	public void doSum(int x, int y);
}

public class Lambda2 
{
  public static void main(String[] args) 
  {
	Calculator calc = (c,d)-> System.out.println(c+d);
	calc.doSum(12, 24);
  }
}
--------------------------------------------------------------
package com.ravi.lambda;

@FunctionalInterface
interface Length
{
	int getLength(String str);
}

public class Lambda3 
{
	public static void main(String[] args) 
	{
		Length l =   (str) -> 
		{
		   return  str.length();
		};
		
		System.out.println(l.getLength("Hyderabad"));

	}

}
----------------------------------------------------------------
20-02-2024
-----------
@FunctionalInterface
interface Moveable
{
	void move();  //SAM (Single Abstract Method)
}

public class Lambda1 
{
	public static void main(String[] args) 
	{
		Moveable car = ()-> System.out.println("Car is moving ");

		Moveable bike = ()-> System.out.println("Bike is moving ");

		Moveable bus = ()-> System.out.println("Bus is moving ");	
		
		car.move();  bike.move();  bus.move();
	}
}
----------------------------------------------------------------
@FunctionalInterface
interface Calculate
{
	 void add(int a, int b, double c);  	
}
public class Lambda2 
{
	public static void main(String[] args) 
	{
	   Calculate calc = (p, q, r) -> System.out.println("Sum is :"+(p+q+r));
	   
	   calc.add(12,89,67.90);
	}
}
----------------------------------------------------------------
import java.util.Scanner; 

@FunctionalInterface
interface Length
{
	 int getLength(String str);	
}

public class Lambda3 
{
	public static void main(String[] args)     
	{
		Length l = str -> str.length();		
		
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter your Name :");
		String name = sc.next();
		System.out.println("Your Name length is :"+l.getLength(name));
	}
}
---------------------------------------------------------------
Working with predefined Functional interface :
----------------------------------------------
What is type parameter?
---------------------------
It is a technique through which we can make our application indepenedent of data type. It is represented by <T>

In java we can pass Wrapper classes as well as User-defined class to this type parameter.

We cannot pass any primitive type to this type parameter. 

Program on Type Parameter :
---------------------------

TypeParameter.java
------------------

package com.ravi.type_parameter;

class Accept<T>
{
	private T var; 
	
	public Accept(T x)  // Student x -> new Student(1,"A");
	{
		var = x;
	}
	
	public T getVar()
	{
		return this.var;
	}
}

public class TypeParameter 
{
	public static void main(String[] args)
	{
	  Accept<Integer> intType = new Accept<>(15);
	  System.out.println(intType.getVar());
	  
	  Accept<Float> floatType = new Accept<>(3.4f);
	  System.out.println(floatType.getVar());
	  
	  Accept<Character> charType = new Accept<>('A');
	  System.out.println(charType.getVar());
	  
	  Accept<Student> stdType = new Accept<>(new Student(1, "A"));
	  System.out.println(stdType.getVar());
	  
	}

}

record Student(int id, String name)
{
	
}
----------------------------------------------------------------
Working with predefined functional interfaces :
------------------------------------------------------
In order to help the java programmer to write concise  java code in day to day programming java software people has provided the following predefined functional interfaces

1) Predicate<T>
2) Consumer<T> 
3) Function<T,R>   
4) Supplier<T>        
5) BiPredicate<T,U>  
6) BiConsumer<T, U>
7) BiFunction<T,U,R>

Note :-
-------
All these predefined functional interfaces are provided as a part of java.util.function sub package.

Predicate<T> functional interface  :
-------------------------------------------
It is a predefined functional interface available in java.util.function sub package.

It contains an abstract method test() which takes type parameter <T> and returns boolean value. The main purpose of this interface to test one argument boolean expression.

@FunctionalInterface
public interface Predicate<T>   
{
  boolean test(T x);
}


Note :- Here T is a "type parameter" and it can accept any type of User defined class as well as  Wrapper class like Integer, Float, Double and so on.

We can't pass primitive type.
----------------------------------------------------------------
package com.ravi.predefined_functional_interface;

import java.util.Scanner;
import java.util.function.Predicate;

public class PredicateDemo1 
{
	public static void main(String[] args) 
	{
	  //Verify whether a number is even or odd		
	  Predicate<Integer> isEven = x -> x%2==0;
	  Scanner sc = new Scanner(System.in);
	  System.out.println("Enter a number :");
	  int num = sc.nextInt();
	  System.out.println(num +" is even ?"+isEven.test(num));
	  sc.close();	  
	 
	}

}
---------------------------------------------------------------
package com.ravi.predefined_functional_interface;

import java.util.Scanner;
import java.util.function.Predicate;

public class PredicateDemo2 
{
	public static void main(String[] args)
	{
		//Verify whether my name is Ravi or not ?
		
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter your Name :");
		String name = sc.nextLine();
		
		Predicate<String> p1 =  str -> str.equals("Ravi");
		System.out.println("Are u ravi ?"+p1.test(name));
	}
}
----------------------------------------------------------------
21-02-2024
----------
package com.ravi.predefined_functional_interface;

import java.util.Scanner;
import java.util.function.Predicate;

public class PredicateDemo3 
{
	public static void main(String[] args) 
	{
	  //Verify whether the name starts with R or not
	  Predicate<String> p1 =  str -> str.startsWith("R");
	  
	  Scanner sc = new Scanner(System.in);
	  System.out.println("Enter your Name :");
	  String name = sc.next();
	  System.out.println("Your name starts with 'R' :"+p1.test(name));
	  
	}

}
----------------------------------------------------------------
Assignment :
------------
By using Predicate verify whether a year is leap year or not?
----------------------------------------------------------------
Consumer<T> functional interface :
-----------------------------------------
It is a predefined functional interface available in java.util.function sub package.

It contains an abstract method accept() and returns nothing. It is used to accept the parameter value or consume the value.

@FunctionalInterface
public interface Consumer<T>
{
    void accept(T x);
}
-----------------------------------------------------------------
ConsumerDemo1.java
-------------------
package com.ravi.predefined_functional_interface;

import java.util.function.Consumer;

record Product(int pid , String pname)
{
	
}


public class ConsumerDemo1 
{
	public static void main(String[] args) 
	{
	  Consumer<Integer> c1 =  x -> System.out.println("Integer :"+x);
	  c1.accept(12);
	  
	  Consumer<String> c2 = x -> System.out.println("String :"+x);
	  c2.accept("NIT");
	  
	  Consumer<Double> c3 = x -> System.out.println("Double :"+x);
	  c3.accept(12.90);
	  
	 Consumer<Product> c4 = x -> System.out.println(x);
	 c4.accept(new Product(111, "Laptop")); 
	  
	}
}
-----------------------------------------------------------------
Function<T,R> functional interface :
-----------------------------------------
Type Parameters:
T - the type of the input to the function.
R - the type of the result of the function.

It is a predefined functional interface available in java.util.function sub package.

It provides an abstract method apply that accepts one argument(T) and produces a result(R).

Note :- The type of T(input) and the type of R(Result) both will be decided by the user.

@FunctionalInterface
public interface Function<T,R>
{
   R apply(T x);        
}
-----------------------------------------------------------------
package com.ravi.predefined_functional_interface;

import java.util.Scanner;
import java.util.function.Function;

public class FunctionDemo 
{
	public static void main(String[] args) 
	{
	   //cube of a number
		Function<Integer,Integer> fn1 = num -> num*num*num;		
		
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter a number :");
		int num = sc.nextInt();
		System.out.println("Cube of "+num+" is :"+fn1.apply(num));
		sc.close();
	}

}
-----------------------------------------------------------------
package com.ravi.predefined_functional_interface;

import java.util.Scanner;
import java.util.function.Function;

public class FunctionDemo2 
{
	public static void main(String[] args) 
	{
	 //finding the length of the String
	  Function<String,Integer> fn1 = str -> str.length();
	  
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter your Name :");
		String name = sc.nextLine();
		System.out.println("Length of "+name+" is :"+fn1.apply(name));
		sc.close();
	}

}
----------------------------------------------------------------
Assignment :
-----------
Program by using Function<T,R> functional interface to verify whether the name starts with R or not?
-----------------------------------------------------------------
Supplier<T> prdefined functional interface :
--------------------------------------------
It is a predefined functional interface available in java.util.function sub package. It provides an abstract method get() which does not take any argument but produces/supply a value of type T.

@FunctionalInterface
public interface Supplier<T>
{
   T get();
}

----------------------------------------------------------------
package com.ravi.predefined_functional_interface;

import java.util.function.Supplier;

record Employee(int eid, String ename)
{
	public String getStudentInfo()
	{
	  return eid+" : " +ename;
	}
}

public class SupplierDemo1 
{
	public static void main(String[] args)
	{
		Supplier<Employee> s1 =() -> new Employee(111, "Scott");
		Employee emp = s1.get();
		System.out.println(emp.getStudentInfo());

	}

}
-----------------------------------------------------------------
package com.ravi.predefined_functional_interface;

import java.util.Scanner;
import java.util.function.Supplier;

record Player(int pid, String pname)
{
	
}

public class SupplierDemo2 
{
	public static void main(String[] args) 
	{
		Supplier<Player> p1 = ()->
		{
			Scanner sc = new Scanner(System.in);
			System.out.println("Enter Player Name :");
			String pname = sc.nextLine();
			System.out.println("Enter Player Id :");
			int pid = sc.nextInt();
			
			Player player = new Player(pid, pname);
			
			return player;
		};
		
		System.out.println(p1.get());

	}

}
-----------------------------------------------------------------
22-02-2024
----------
BiPredicate<T,U> functional interface :
-----------------------------------
It is a predefined functional interface available in java.util.function sub package.

It is a functional interface in Java that represents a predicate (a boolean-valued function) OF TWO ARGUMENTS.

The BiPredicate interface has method named test, which takes two parameters and returns a boolean value, basically this BiPredicate is same with the Predicate, instead, it takes 2 arguments for the test.

@FunctionalInterface
public interface BiPredicate<T, U> 
{
    boolean test(T t, U u);
}

Type Parameters:

T - the type of the first argument to the predicate
U - the type of the second argument the predicate
-----------------------------------------------------------------
import java.util.function.*;
public class Lambda11 
{
	public static void main(String[] args)   
    {
        BiPredicate<String, Integer> filter = (x, y) -> 
		{
            return x.length() == y;  
        };

        boolean result = filter.test("Ravi", 4);
        System.out.println(result);  

        result = filter.test("Hyderabad", 10);
        System.out.println(result);
	}
}
------------------------------------------------------------------
import java.util.function.BiPredicate;

public class Lambda12
{
  public static void main(String[] args) 
  {
    // BiPredicate to check if the sum of two integers is even
    BiPredicate<Integer, Integer> isSumEven = (a, b) -> (a + b) % 2 == 0;

        System.out.println(isSumEven.test(2, 3));    
        System.out.println(isSumEven.test(5, 7));   
    }
}
----------------------------------------------------------------
BiConsumer<T, U> functional interface :
---------------------------------------
It is a predefined functional interface available in java.util.function sub package.

It is a functional interface in Java that represents an operation that accepts two input arguments and returns no result.

It takes a method named accept, which takes two parameters and performs an action without returning any result.

@FunctionalInterface
public interface BiConsumer<T, U> 
{
    void accept(T t, U u);
}
-----------------------------------------------------------------
import java.util.function.BiConsumer;

public class Lambda13
{
   public static void main(String[] args) 
   {
     BiConsumer<Integer, String> updateVariables = (num, str) -> 
		 {
            num = num * 2;
            str = str.toUpperCase();
            System.out.println("Updated values: " + num + ", " + str);
        };

        
        int number = 15;
        String text = "nit";

        updateVariables.accept(number, text);

        // Values after the update (note that the original values are unchanged)
        System.out.println("Original values: " + number + ", " + text);
    }
}
------------------------------------------------------------------
BiFunction<T, U, R> Functional interface :
---------------------------------
It is a predefined functional interface available in java.util.function sub package.

It is a functional interface in Java that represents a function that accepts two arguments and produces a result.

The BiFunction interface has a method named apply that takes two arguments and returns a result.

@FunctionalInterface
public interface BiFunction<T, U, R> 
{
    R apply(T t, U u);
}
------------------------------------------------------------------
import java.util.function.BiFunction;

public class Lambda14
{
  public static void main(String[] args) 
  {
        // BiFunction to concatenate two strings
    BiFunction<String, String, String> concatenateStrings = (str1, str2) -> str1 + str2;

        String result = concatenateStrings.apply("Hello", " Java");
        System.out.println(result);  


      // BiFunction to find the length two strings
    BiFunction<String, String, Integer> concatenateLength = (str1, str2) -> str1.length() + str2.length();

        Integer result1 = concatenateLength.apply("Hello", "Java");
        System.out.println(result1);  

  }
}
-----------------------------------------------------------------
Method Reference :
------------------
It is a new feature introduced from java 8 version.

It is used to concise our code.

We can use this technique in the body of Lambda expression just to refer an existing method (already available method) to pass as an implementation of Functional interface.

The entire method body will be automatically placed into Lambda Expression.

It will enhance Code Reusability.

It uses ::(Double colon operator) to refer.

There are 3 types of Method Reference :
----------------------------------------
1) Static method reference (ClassName::staticMethodName)
2) Instance method reference (instance::instanceMethodName)
3) Constructor Reference  (ClassName::new)


How Lambda will be converted into Method Reference :
-----------------------------------------------------
Lambda Expression                      Method Reference

s -> s.toLowerCase();                  String::toLowerCase

s -> s.length();                       String::length

(s1,s2) -> s1.compareTo(s2);           String.compareTo


Basic Example of Method reference by comparing Lambda :
-------------------------------------------------------
3 files :
--------
Worker.java(I)
--------------
package com.ravi.method_ref;

@FunctionalInterface
public interface Worker 
{
  void work(double salary);
}


Employee.java(C)
----------------
package com.ravi.method_ref;

public class Employee 
{
  public void work(double salary)
  {
	  System.out.println("Employee Salary is :"+salary);
  }
}


MethodReference.java
---------------------
package com.ravi.method_ref;

public class MethodReference 
{
	public static void main(String[] args)
	{
	  //By using Lambda
	  Worker w1 = sal -> System.out.println("Worker salary is :"+sal);
	  w1.work(40000);
	  
	  //By using Method Reference
	  Worker w2 = new Employee()::work;
	  w2.work(50000);
	}

}
----------------------------------------------------------------
23-02-2024
-----------
Method reference using static method :
--------------------------------------
3 files :
----------
Callable.java(I)
----------------
package com.ravi.static_method_reference;

public interface Callable 
{
   void call(String name);
}


StaticMethod.java(C)
--------------------
package com.ravi.static_method_reference;

public class StaticMethod 
{
  public static void getName(String name)
  {
	  System.out.println(name+" is calling..");
  }
}


StaticMethodReference.java(C)
-----------------------------

package com.ravi.static_method_reference;

public class StaticMethodReference {

	public static void main(String[] args) 
	{
		//By using Lambda
		Callable c1 =  str -> StaticMethod.getName(str);
		c1.call("Ravi");
		
		//By using Method reference
		Callable c2 = StaticMethod::getName;
		c2.call("Scott");
		
		
	}

}
-----------------------------------------------------------------
Method Reference by using instance Method :
-------------------------------------------
Trainer.java(I)
---------------
3 files :
---------
package com.ravi.instance_method_reference;

public interface Trainer 
{
  void getTraining(String name, int experience);
}


InstanceMethod.java
--------------------
package com.ravi.instance_method_reference;

public class InstanceMethod 
{
   public void getTraining(String name, int experience)
   {
	   System.out.println("Trainer name is :"+name+" having "+experience+" years of experience.");
   }
}

InstanceMethodReferenceDemo.java
----------------------------------
package com.ravi.instance_method_reference;

public class InstanceMethodReferenceDemo 
{
    public static void main(String[] args) 
    {
    	//Using Lambda Expression
    	Trainer t1 = (name,  exp)-> System.out.println("Trainer name is :"+name+" and total experience is :"+exp);
    	t1.getTraining("ABC", 5);
    	
    	
    	//By using Method reference 
    	Trainer t2 = new InstanceMethod()::getTraining;
    	t2.getTraining("Ravi", 10);   	
    	
    }
}
----------------------------------------------------------------
By using Constructor (ClassName::new)
--------------------------------------
package com.ravi.constructor_reference;

@FunctionalInterface
interface A 
{
    Test createObject();
}

class Test 
{
    public Test() 
    {
        System.out.println("Test class Constructor invoked");
    }
}
public class ConstructorReferenceDemo1
{
    public static void main(String[] args) 
    {
        //By using Lambda
        A a1 = ()-> new Test();
        
        a1.createObject(); 
        
        System.out.println("...................");        
        
        //By Using Method Reference
        A a2 = Test::new;   //calling Test class constructor 
        a2.createObject(); 
    }
}
------------------------------------------------------------------
Interface from java 9v version
-------------------------------
Yes, From java 9 onwards we can also write private static and private non-static methods inside an interface.

These private methods will improve code re-usability inside interfaces.

For example, if two default methods needed to share common and confidential code, a private method would allow them to do so, but without exposing that private method to its implementing classes.

Using private methods in interfaces have four rules :

1) private interface method cannot be abstract.
2) private method can be used only inside interface.
3) private static method can be used inside other static and non-static interface methods.
4) private non-static methods cannot be used inside private static methods.
------------------------------------------------------------------
//Program that describes how many methods we can write inside interface upto java 9

package com.ravi.method_reference;

public interface Moveable 
{
   //abstract method
   public abstract void m1();
   
   //default method [1.8]  //by default public
   public default void m2()
   {
	   System.out.println("It is a default method");
	   m4();
	   m5();
   }
  
   //static method [1.8]  //by default public
   public static void m3()
   {
	   System.out.println("It is a Static method");
	   m4();
	   
   }
   
   //private static method [Java 9]
   private static void m4()
   {
	   System.out.println("Private static method");
   }
   
   //private non static method [Java 9]
   private void m5()
   {
	   System.out.println("Private  non static method");
   }
   
}
-----------------------------------------------------------------
Program on private method inside an interface :
------------------------------------------------
3 files :
---------
Moveable.java(I)
----------------
package com.ravi.java9;

public interface Moveable 
{
	void move();
	
	default void m1()
	{
		System.out.println("It is a default method");
		m3();
		m4();
	}
	
	static void m2()
	{
		System.out.println("It is a static method");
		m4();
	}

	private void m3()
	{
		System.out.println("Private non static method");
	}
	
	private static void m4()
	{
		System.out.println("Private  static method");
	}
}


Move.java(C)
-------------
package com.ravi.java9;

public class Move implements Moveable
{
	@Override
	public void move() 
	{
		System.out.println("Moving with my Vehicle");		
	}

}


Main.java
---------
package com.ravi.java9;

public class Main {

	public static void main(String[] args)
	{
		Moveable m = new Move();
		m.move();
		m.m1();
		
		Moveable.m2();
	}
}
----------------------------------------------------------------
24-02-2024
-----------
*What is marker interface in java ?
-----------------------------------
What is marker interface ?
-------------------------------
An interface which does not contain any method and field is called marker interface. In other words, an empty interface is known as marker interface or tag interface.

*It describes run-time type information about objects, so the JVM have additional information about the object. [like object is clonable OR object is serializable OR Object is RandomAccess]

Example :
----------
public interface Drawable  //Marker interface
{
}

Note :-In java we have Clonable and Serializable, RandomAccess are predefined marker interface.
----------------------------------------------------------------
Does An Interface extends Object Class In Java.?
-------------------------------------------------
No Interface does not inherits Object class,but it provide accessibility to all methods of Object class.

This is because, for every public method in Object class, there is an implicit abstract and public method declared in every interface which does not have direct super interfaces. (Java language Specification 9.2 about interface members)

package com.ravi.interface_object_method;

interface A 
{
  	
}

public class InterfaceWithObjectMethod 
{
   public static void main(String[] args) 
   {
	  A a = null;
	  a.equals(null);
	  a.hashCode();
	  a.toString();
	  a.getClass();
  }
}
----------------------------------------------------------------
package com.ravi.interface_object_method;

public interface I 
{
  @Override
  public String toString();
  
  @Override
  public int hashCode();
  
  @Override
  public boolean equals(Object obj);
}
----------------------------------------------------------------
Can a functional interface contains the method of Object class?
---------------------------------------------------------------
Yes, Functional interface contains the method of Object class. 

package com.ravi.functional_interface;

@FunctionalInterface
public interface Callable 
{
   public abstract void call();
   
   public String toString();
   
   public int hashCode();
   
   public boolean equals(Object obj);
   
}

From the avove interface, It is clear that inside a Functional interface we can re-declare the method of Object class.
---------------------------------------------------------------
****What is difference between abstract class and interface ?
---------------------------------------------------------------
The following are the differences between abstract class and interface.

1) An abstract class can contain instance variables but interface variables are by default public , static and final.

2) An abstract class can have state (properties) of an object but interface can't have state of an object.

3) An abstract class can contain constructor but inside an interface we can't define constructor.

4) An abstract class can contain instance and static blocks but inside an interface we can't define any blocks.

5) Abstract class can't refer Lambda expression but using Functional interface we can refer Lambda Expression.	

6) We can write concrete method inside an abstract class but inside an interface we can't write concrete public method, only abstract , default, static and private methods are allowed.

--------------------OOPs ENDED---------------------------------
26-02-2024
----------
JVM Architecture with Class loader sub system :
------------------------------------------------
The three main components of JVM 

1) class loader sub system

2) Runtime Data Areas(Memery Areas)

3) Execution engine

class loader sub system internally performs 3 task

a) Loading     b) Linking      c) Initialization   (Diagram 26th FEB)

Loading:
----------
In order to load the required .class file, JVM makes a request to class loader sub system. The class loader sub system follows delegation hierarchy algorithm to load the required .class files from different areas.

To load the required .class file we have 3 different kinds of class loaders.

1) Bootstrap/Primordial class loader

2) Extension/Platform class loader

3) Application/System class loader

Bootstrap/Primordial class Loader :-
---------------------------------
It is responsible to load the required .class file from java API that means all the predfined classes (provided by java software people) .class file will be loaded by Bootstrap class loader.
It is the super class of Extension class loader as well as It has the highest priority among all the class loader.

It will load the .class file from the following Path
C-> Program files -> java -> jdk -> lib -> jrt-fs.jar

Extension/Platform  class  Loader :-
--------------------------------------
It is responsible to load the required .class files from ext (extension) folder. Inside the extension folder we have  jar file(Java level zip file) given by some third party or user defined jar file.
It is the super class of Application class loader as well as It has more priority than Application class loader.


Note :- Command to create the jar file 

           jar cf NIT.jar  FileName.class

Here FileName.class will be placed inside the jar file.

Application/System class Loader :-
--------------------------------------
It is responsible to load the required .class file from class path level i.e Environment variable. It has lowest priority as well as It is the sub class of Extension/Platform class loader.


How Delegation Hierarchy algorithm works :-
---------------------------------------------------
Whenever JVM makes a request to class loader sub system to load the required .class file into JVM memory, first of all, class loader sub system makes a request to Application class loader, Application class loader will delegate(by pass) the request to the Extension class loader, Extension class loader will also delegate the request to Bootstrap class loader.

Bootstrap class loader will load the .class file from lib folder(jrt.jar) and then by pass the request to extension class loader, Extension class loader will load the .class file from ext folder(*.jar) and by pass the request to Application class loader, It will load the .class file from environment variable into JVM memory. 

Note :- 
------
If all the class loaders are failed to load the .class file into JVM memory then we will get a Runtime exception i.e java.lang.ClassNotFoundException
----------------------------------------------------------------
The following program explains that java.lang.Class can hold any .class file.

package com.ravi.jvm_arch;


class Player{}

class Employee{}

class Student{}

public class DotClassHolder 
{
	public static void main(String[] args) 
	{
		Class cls = null;

		cls = Player.class;
		System.out.println(cls.getName());
		
		cls = Employee.class;
		System.out.println(cls.getName());
		
		cls = Student.class;
		System.out.println(cls.getName());
		
	}

}
----------------------------------------------------------------
WAP in java that describes our user defined .class file is loaded by Applicatin class loader.

package com.ravi.jvm_arch;

public class Demo 
{
	public static void main(String[] args) 
	{
		ClassLoader loader = Demo.class.getClassLoader();
		System.out.println("Demo .class is loaded by :"+loader);
	}
}

getClassLoader() is a predefined method of class called Class available in java.lang package and it's return type is ClassLoader. 
----------------------------------------------------------------
WAP to show that Platform class loader is the super class for
Application class loader.

package com.ravi.jvm_arch;

public class Demo 
{
	public static void main(String[] args) 
	{
		ClassLoader loader = Demo.class.getClassLoader();
		System.out.println("Demo .class is loaded by :"+loader);      
		//Application CL
		
		System.out.println("Super class for Application  CL is :"+loader.getParent()); //Platform CL
		
		System.out.println("Super class for Platform CL is :"+loader.getParent().getParent()); //null
	}
}

Note :- For BootStrap CL, implementaion is not provided by java 
        software people becuase it is for internal use.
----------------------------------------------------------------
Linking :
---------
verify :-
-------
It ensures the correctness of the .class files, If any suspicious activity is there in the .class file then It will stop the execution immediately by throwing an exception i.e java.lang.VerifyError.

There is something called ByteCodeVerifier(Component of JVM), responsible to verify the loaded .class file i.e byte code. Due to this verify module JAVA is highly secure language. 

java.lang.VerifyError is the sub class of java.lang.linkageError
----------------------------------------------------------------
prepare: (static variable memory allocation + Initialization )
--------
It will allocate the memory for all the static data members, here all the static data member will get the default values so if we have 
static int x = 100;

then for variable x  memory will be allocated and now it will initialize with default value i.e 0.
---------------------------------------------------------------
Resolve :-
-----------
All the symbolic references will be converted to direct references or actual reference.

javap -verbose  FileName.class

Note :- By using above command we can read the internal details of .class file.
----------------------------------------------------------------------
Initialization :-
-----------------
In Initialization, all the static data member will get their actual (Original) value as well as if any static block is present in the class then the static block will start executing from here.
---------------------------------------------------------------
28-02-2024
-----------
Static Block in Java :
-----------------------
Static Block :
--------------
It is a very special block which will be automatically executed at the time of loading the .class file into JVM memory.

Example :
static
{
}

Static blocks are executed only once because class loading is possible only once.

The main purpose of static block to initialize the static data member of the class so it is also known static initializer.

A blank static final variable can also be initialized through static block only.

If a class contains multiple static blocks then it will be executed according to the order.

Automatically static block will not be executed everytime, whenever class will be loaded (user request) then only static block will be executed.

static block will be executed before main method or any static method.

The compiler will generate illegal forward reference, if a user try to access the static variable value from static block without declaration.

[Without declaration of static variable, we can initialize the static variable inside static block (because memory is already allocated in the prepare phase) but accessing of static variable is not possible]
-----------------------------------------------------------------
//static block
class Foo
{	
	Foo()
	{
		System.out.println("No Argument constructor..");
	}

	{
		System.out.println("Instance block..");
	}

	static
	{
		System.out.println("Static block...");
	}
}
public class StaticBlockDemo   
{
	public static void main(String [] args)
	{ 		
		System.out.println("Main Method Executed ");				
	}
}

Note :- In the above program static block will not be executed becuase Foo.class file is not loaded into JVM Memory.
----------------------------------------------------------------
class Test
{
	static int x;

	static
	{
		x = 100;
		System.out.println("x value is :"+x);
	}
	
	static
	{
		x = 200;
		System.out.println("x value is :"+x);
	}

	static 
	{
		x = 300;
		System.out.println("x value is :"+x);
	}

	
}
public class StaticBlockDemo1   
{
	public static void main(String[] args) 
	{
		System.out.println(Test.x);
	}
}

Note :- static blocks are executed according to the order.
-----------------------------------------------------------------
class Foo
{	
	static int x;

    static
	{		
		System.out.println("x value is :"+x);
	}	
}

public class StaticBlockDemo2 
{
	public static void main(String[] args) 
	{
		 new Foo();
	}
}

Note :- static variables are also initialized with default value.
-----------------------------------------------------------------
class Demo
{
	
	final static int a ;	//Blank final variable

	static
	{	
		a = 100;
		System.out.println(a); 
	}
}	
public class  StaticBlockDemo3
{
	public static void main(String[] args) 
		{		
	         System.out.println("a value is :"+Demo.a);		
	    }
}

Note :- blank final variable must be initialized through static 
        block only.
----------------------------------------------------------------
Interview Quaestion :
----------------------
//AD  BC  EF
class  A         
{
	static 
	{
		System.out.println("A");
	}

	 
	{
		System.out.println("B");
	}

	A() 
	{		
		System.out.println("C");
	}
}
class B extends A
{
	static 
	{
		System.out.println("D");
	}

	 
	{
		System.out.println("E");
	}

	B() 
	{		
		System.out.println("F");
	}

}
public class StaticBlockDemo4 
{
	public static void main(String[] args) 
	{
		new B();
	}
}
-----------------------------------------------------------------
//illegal forward reference

class Demo 
{	
    static 
	{   
		i = 100;
		
	}

    static int i;
}

public class StaticBlockDemo5
{

    public static void main(String[] args) 
	{
        System.out.println(Demo.i);
	}
}

Note :- In the prepare phase, static variable memory is already 
        allocated so initialization is possible.
-----------------------------------------------------------------
class Demo 
{
    static 
	{   
		i = 100; //Initialization is possible
		System.out.println(i); //Invalid Illegal Forward Reference
    }

    static int i;
}

public class StaticBlockDemo6
{

    public static void main(String[] args) 
	{
		System.out.println(Demo.i);
	}
}

Note :- Without declaration of static variable, it is not possible to perform any kind of read/access operation otherwise 
we will get Illegal forward reference.
-----------------------------------------------------------------
class StaticBlockDemo7 
{
	static 
	{
      System.out.println("Static Block");
	}

	public static void main(String[] args) 
	{
		System.out.println("Main Method");
	}
}
-----------------------------------------------------------------
Can we execute a Java program without main method ?
---------------------------------------------------------------
 We can't execute a java program without main method, Upto jdk 1.6 it was possible to execute a java program without main method by writing the static block. 
 
 From JDK 1.7 onwards now we can't execute java program without main method because JVM verifies the presence of the main method before initializing the class.

Eg:-
class WithoutMain
{
        static
	{
	System.out.println("Hello world");
	System.exit(0);
	}
}
The above program was possible to execute upto JDK 1.6.
-----------------------------------------------------------------
29-02-2024
----------
How many ways we can load the .class file into JVM memory :
----------------------------------------------------------------
There are multiple ways to load the .class file into JVM memory.The following are the common examples :-

1) By using java tools [java command]
2) By using Constructor [Object creation]
3) By accessing the static member of the class.
4) By using Inheritance
5) By Reflection API


1) By using Java tools 
    javac Test.java 
    java Test [Load the Test.class file into JVM memoy]

 
2) By using Constructor [Object creation]

3) By Calling static variable and static method using class name.

class Demo
{
	static int x = 10;
	static
	{
		System.out.println("Static Block of Demo class Executed!!! :"+x);
	}
}
public class ClassLoading 
{
	public static void main(String[] args) 
	{	
		//new Demo();
	  System.out.println(Demo.x);	
	}
}
---------------------------------------------------------------
4) By Using Inheritance
----------------------------   
When we create the Object for Sub class then, first of all super class .class file will be loaded then only sub class .class file will be loaded.

Note :- Always Object is the first class to be loaded into JVM memory

class Alpha
{
	static
	{
		System.out.println("Static Block of super class Alpha!!");
	}
}
class Beta extends Alpha 
{
	static
	{
		System.out.println("Static Block of Sub class Beta!!");
	}
}
class InheritanceLoading 
{
	public static void main(String[] args) 
	{
		 new Beta();
	}
}
----------------------------------------------------------------

5) By Reflection API (Explicit class loading)
-----------------------------------------------

Java software people has provided a predefined class called "Class" available in java.lang package.

This class called Class contains a predefined static method forName(String className), through which we can load the required .class file into JVM memory dynamically.

It throws a checked exception i.e java.lang.ClassNotFoundException

Class.forName("com.ravi.Test");  //Fully Qualified Name
----------------------------------------------------------------
package com.ravi.class_loading;

class Demo
{
	static
	{
		System.out.println("Static Block of Demo class");
	}
}

public class ClassLoader {

	public static void main(String[] args) throws Exception
	{
		Class.forName("com.ravi.class_loading.Demo");

	}

}
----------------------------------------------------------------
What is factory Method in java ?
--------------------------------
The method which returns the class name itself by creating the object for that particular class is called Factory Method.

Class cls = Class.forName("com.ravi.Test");

Here Test.class will be loaded into JVM memory and it will return Class class object so further we can call any method of 
java.lang.Class class.

public class FactoryMethod {

	public static void main(String[] args) throws Exception
	{
		Class name = Class.forName("java.lang.String");
		System.out.println(name.getName());

	}

}

Any method which is returning the class object then it is known as Factory Method.
---------------------------------------------------------------
*What is the limitation of 'new' keyword ?
                       OR
What is the difference between new keyword and newInstance() method?
                      OR
How to create the Object for the classes which are coming dynamically from the database or from some file.

The limitation with new keyword is, It demands the class name at the begning or at the time of compilation so new keyword is not suitable to create the object for the classes which are coming from database or files at runtime.

In order to create the object for the classes which are coming at runtime from database or files, we should use newInstance() method available in java.lang.Class class.
---------------------------------------------------------------
class Student
{
}
public class Test 
{
	public static void main(String[] args) throws Exception
	{
	   Object obj = Class.forName(args[0]).newInstance();
	   System.out.println("Object created for :"+obj.getClass().getName());
	}
}

javac Test.java
java Test Student (Here Student class we are passing through Command Line Argument)
----------------------------------------------------------------
class Student
{
	public void greet()
	{
		System.out.println("Welcome Student");
	}
}
public class Test 
{
	public static void main(String[] args) throws Exception
	{
	   Object obj = Class.forName(args[0]).newInstance();
	   Student s1 = (Student) obj;
	   s1.greet();
	 
	}
}

Here Student class object is created so we can call greet() non static method of Student class.
----------------------------------------------------------------
01-03-2024
----------
* What is the difference between java.lang.ClassNotFoundException and java.lang.NoClassDefFoundError :



java.lang.ClassNotFoundException :-
-----------------------------------------
It occurs when we try to load the required .class file at runtime by using Class.forName() statement or loadClass() static of ClassLoader class and if the required .class file is not available at runtime then we will get an exception i.e java.lang.ClassNotFoundException

Note :- It does not have any concern at compilation time, at run time, JVM will simply check whether the required .class file is available or not.

Program :
----------
class Foo
{
	static
	{
		System.out.println("static block gets executed...");
	}
}
public class ClassNotFoundExceptionDemo 
{
	public static void main(String[] args) throws Exception
	{
		Class.forName("Player");
	}
}

Note :- In the above program Player.class file is not available so, forName(String className) method is unable to load the Player.class file hence we will get ClassNotFoundException.
---------------------------------------------------------------
java.lang.NoClassDefFoundError :
--------------------------------------
It occurs when the class was present at the time of COMPILATION but at runtime the required .class file is not available(manually deleted by user) Or it is not available in the current directory (folder) then we will get an exception i.e java.lang.NoClassDefFoundError.

NoClassDefFoundErrorDemo.java
-----------------------------
class Hello
{
	public void m1()
	{
		System.out.println("m1 method of Hello class...");
	}
}
public class NoClassDefFoundErrorDemo 
{
	public static void main(String[] args) 
	{
		Hello h = new Hello();
		h.m1();
	}
}

After compilation delete Hello.class OR put the Hello.class file
in another folder/location.

So the conclusion is :
java.lang.ClassNotFoundException does not have any concern at compilation time where as java.lang.NoClassDefFoundError was checking the class name at the time of compilation.
---------------------------------------------------------------
Variable Memory Allocation and Initialiozation :
-------------------------------------------------
1) static field OR Class variable : 
-----------------------------------
Memory allocation done at prepare phase of class loading and initialized with default value.

2) Non static field OR Instance variable 
-----------------------------------------
Memory allocation done at the time of object creation using new keyword (Instantiation) and initialized as a part of Constructor

3) Local Variable 
------------------
Memory allocation done at stack area and user is responsible to initialize the variable before use.

4) Parameter variable 
----------------------
Memory allocation done at stack area  and end user is responsible to pass the value at runtime.
----------------------------------------------------------------
Runtime Data Areas :
--------------------
This runtime data area is divided into 5 different memories :

  a) Method Area
  b) Heap Area
  c) Stack Area
  d) PC Register
  e) Native Method Stack

Runtime Data Areas :
--------------------
a) Method Area :
-------------------
In this area all class level information is available. Actually the .class file is dumpped here hence we have all kinds of information related to class is available like name of the class, name of the immediate super class, package name, method name , variable name, static variable, all method available in that particular class and so on.

This method area return type java.lang.Class class , this java.lang.Class class object can hold any .class file 
(Class c = AnyClass.class)

There is only one method area per JVM.
---------------------------------------------------------------
2 Files :
---------
Employee.java
--------------
package com.ravi.class_description;

public class Employee 
{
	private int x,y,z;
	
	private static int a,b,c;
	
	public void accept() {}
	
	public void input() {}
	
	public void display() {}
	
	public void getData() {}	

}

ClassInformation.java
----------------------
package com.ravi.class_description;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class ClassInformation 
{
	public static void main(String[] args) throws Exception
	{
		Class cls = Class.forName(args[0]);
		System.out.println("Class Name is :"+cls.getName());
		System.out.println("Package Name is :"+cls.getPackageName());

		Method[] methods = cls.getDeclaredMethods();
		
		int count = 0;
		
		for(Method method : methods)
		{
			count++;
			System.out.println(method.getName());
		}
		System.out.println("Total number of methods :"+count);
		count = 0;
		
		Field[] fields = cls.getDeclaredFields();
		
		for(Field field : fields)
		{
			count++;
			System.out.println(field.getName());
		}
		System.out.println("Total number of fields :"+count);
	}

}


Note :- getDeclaredMethods() is a predefined method available in java.lang.Class class , the return type of this method is Method array where Method is a predefined class available in java.lang.reflect sub package

getDeclaredFieldss() is a predefined method available in java.lang.Class class , the return type of this method is Field array where Method is a predefined class available in java.lang.reflect sub package

*getDeclaredConstructors() is a predefined method available in java.lang.Class class , the return type of this method is Constructor array where Method is a predefined class available in java.lang.reflect sub package.
----------------------------------------------------------------
04-03-2024
----------
HEAP Area :
-----------
In java whenever we create the Object, all object related data like instance variable and instance methods are strored in HEAP Area.
This is the 2nd layer architecture of JVM so from this area we can access the static memeber of the class but vice versa is not possible.

We have only one Heap Area per JVM.
---------------------------------------------------------------------
Stack Area :
------------
In java all the methods are executed as a part of Stack Area. Whenever we call a method then it creates Stack Frame. Each Stack Frame contains 3 parts 
              a) Local variable.
	      b) Frame Data.
	      c) Operand Stack.

We have n number of stack area in one JVM.

JVM creates a separate runtime stack for Each and every thread.
----------------------------------------------------------------------
Garbage Collector :-
----------------------
In older languages like C++, It is the responsibility of the programmer to allocate the memory as well as to de-allocate the memory otherwise there may be chance of getting OutOfMemoryError.

But in Java a user is not responsible to de-allocate the memory that means memory allocation is the responsibility of user but  memory de-allocation is automatically done by Garbage Collector.

Garbage collection is the process of looking at heap memory, identifying which objects are in use and which are not, and deleting the unused objects (The object which does not contain any references).

It is an automatic memory management in java. JVM internally contains a thread called Garbage collector which is daemon thread, It is responsible to delete the unused objects or the objects which are not containing any references in the heap memory.

Note :- GC uses an algorithm mark and sweep to make an un-used objects eligible for Garbage Collection.

The garbage Collector thread is visiting our program at regular interval to delete the unused objects but as a programmer we can call garbge collector explicitly to visit our program by using the following code.

System.gc(); //explicitly calling the garbage collector

gc() is a predefined static method of System class.
--------------------------------------------------------------
There are 3 ways to make an Object eligible for Garbage Collector:
----------------------------------------------------------------
1) Assigning a null literal to reference variable

    Employee e1 = new Employee();
    e1 = null;

 2) Creating an object inside the method

      public void createObject()
      {
          Employee e2 = new Employee();
      }
Note :- Once the method execution is over automatically Object is eligible for Garbage Collector

3) Assigning new object to the Existing reference variable

     Employee e3 = new Employee();

     e3 = new Employee();
----------------------------------------------------------------
HEAP and Stack Diagram for Employee.java
-----------------------------------------
public class Employee
{
	int id = 100;
	
	public static void main(String[] args) 
	{
		int val = 200;

		Employee e1 = new Employee();     

		e1.id = val;

		update(e1);	  
		
		System.out.println(e1.id);

        Employee e2 = new Employee(); 

		e2.id = 500;
        
		switchEmployees(e2,e1);	//3000x, 1000x

		    //GC [2 objects 2000x and 4000x are eligible for GC]

			System.out.println(e1.id);
		    System.out.println(e2.id);
	    } 
		
	 public static void update(Employee e)  
	 {
        e.id = 500;
		e = new Employee();
		e.id = 400;
	 }

	 public static void switchEmployees(Employee e1, Employee e2)
	  {
		 int temp = e1.id;
		 e1.id = e2.id; 
		 e2 = new Employee();
		 e2.id = temp;
	  }
   }
---------------------------------------------------------------
HEAP and STACK diagram for Beta.java
-------------------------------------
class Alpha
{
	int val;
	static int sval = 200;
	static Beta b = new Beta();

	public Alpha(int val)
	{
      this.val = val;
	}
}

public class Beta      
{
	public static void main(String[] args) 
	{
		Alpha am1 = new Alpha(9);
		Alpha am2 = new Alpha(2);

		Alpha []ar = fill(am1, am2); 

		ar[0] = am1; 
        System.out.println(ar[0].val); 
        System.out.println(ar[1].val);
	}

	public static Alpha[] fill(Alpha a1, Alpha a2)
	{
		a1.val = 15;

        Alpha fa[] = new Alpha[]{a2, a1}; 

		return fa;
	}
}
---------------------------------------------------------------
05-03-2024
----------
PC Register :
-------------
It stands for Program counter Register.

In order to hold the current executing instruction of running thread we have separate PC register for each and every thread.

Native Method Stack :
----------------------
Native method means, the java methods which are written by using native languages like C and C++. In order to write native method we need native method library support.

Native method stack will hold the native method information in a separate stack.
---------------------------------------------------------------
Execution Engine :
------------------
Interpreter 
------------
In java, JVM is an interpreter which executes the program line by line. JVM (Interpreter) is slow in nature because at the time of execution if we make a mistake at line number 9 then it will throw the execption at line number 9 and after solving the execption again it will start the execution from line number 1 so it is slow in execution that is the reason to boost up the execution java software people has provided JIT compiler.

JIT Compiler :
--------------
It stands for just in time compiler. The main purpose of JIT compiler to boost up the execution so the execution of the program will be completed as soon as possible.

JIT compiler holds the repeated instruction like method signature, variables and make it available to JVM at the time of execution so the overall execution becomes very fast.
----------------------------------------------------------------
Exception Handling :
--------------------
What is an execption ?
----------------------
An execption is a runtime error.

An execption is an abnormal situation or un-expected situation in a noraml execution flow.

An exception encounter due to dependency, if one part of the program is dependent to another part then there might be a chance of getting Exception.

AN EXCEPTION ALSO ENCOUNTER DUE TO WRONG INPUT GIVEN BY THE USER.
---------------------------------------------------------------
Exception Hierarchy :
--------------------
This Exception hierarchy is available in the diagram (Exception_Hierarchy.png)

Note :- As a developer we are responsibe to handle the Exception. System admin is responsibe to handle the error because we cannot recover from error.
----------------------------------------------------------------
06-03-2024
-----------
Exception Criteria :
---------------------
1) java.lang.ArithmeticException
   Whenever we divide a number by 0 (an int value) then we will 
   get java.lang.ArithmeticException.

   Example :   System.out.println(10/0);	

2) java.lang.ArrayIndexOutOfBoundsException
   Whenever we try to acees the index of Array but if the index is
   not available (out of bound) then we will get ArrayIndexOutOfBoundsException.

   int arr[] = {10,20,30};
   System.out.println(arr[3]);

3) java.lang.NumberFormatException
   Whenever we try to convert String value into corresponding 
   integer but the String value is not in a proper format
   then we will get java.lang.NumberFormatException

   String str = "Ravi";
   int no = Integer.parseInt(str);

4) java.lang.NullPointerException
   If a reference variable is pointing to null and from that reference variable, if we call any non static method then we will get
   java.lang.NullPointerException

   String str = null;
   System.out.println(str.length());

5) java.lang.NegativeArraySizeException
   The size of the array must not be negative.

   int []arr = new int[-9];

6) java.util.InputMismatchException
   If we take the input but the user and input is not in a proper format then we will get java.util.InputMismatchException

   Scanner sc = new Scanner(System.in);
   System.out.println("Enter Your Age :");
   int age = sc.nextInt();  //input is eleven
   System.out.println("Age is :"+age);
-----------------------------------------------------------------
Exception is the super class of all the execptions whether it is a predefined exception or user-defined exception in Java.

package com.ravi.exception;

public class ExceptionDemo 
{
	public static void main(String[] args) 
	{
		Exception e = new ArithmeticException();
		System.out.println(e);
		
		Exception e1 = new ArrayIndexOutOfBoundsException();
		System.out.println(e1);

	}

}
------------------------------------------------------------------
WAP that describes that whenever an exception encounter in the program then program will be terminated in the middle.

package com.ravi.exception;

import java.util.Scanner;

public class ExceptionTermination {

	public static void main(String[] args)
	{
		System.out.println("Main method started..");
		Scanner sc = new Scanner(System.in);
		
		System.out.print("Enter the value of x :");
		int x = sc.nextInt();
		
		System.out.print("Enter the value of y :");
		int y = sc.nextInt();
		
		int res = x/y; //[if y value is 0 then program will halt]
		System.out.println("Result is :"+res);
		
		System.out.println("Main method ended..");
		sc.close();
	}

}

Note :- In the above program if the value of y will be 0 then our program will halt in the middle, it is called abnormal termination so, JVM is having default exception handler, which will terminate the program and provide the appropriate message.
------------------------------------------------------------------
OOP has provided some mechanism to work with exception which are as follows :

1) try block
2) catch block
3) finally (try with resources 1.7)
4) throw
5) throws

try block :
-----------
Whenever our statement is error suspecting statement OR Risky statement then we should write that statement inside the try block.

try block must be followed either by catch block or finally block or both.

*try block is responsible to trace our code line by line, if any execption encounter then TRY BLOCK WILL CREATE APPROPRIATE EXECPTION OBJECT WITH THE HELP OF JVM, AND THROW THIS EXCEPTION OBJECT to the nearest catch block.

After the execption in the try block, the remaining code of try block will not be executed because control will directly transfer to the catch block.

In between try and catch block we cannot write any kind of statement.

catch block :
--------------
The main purpose of catch block to handle the exception which is thrown by try block.

catch block will only executed if there is an exception in the try block.
-----------------------------------------------------------------
package com.ravi.exception;

import java.util.Scanner;

public class ExceptionTermination {

	public static void main(String[] args)
	{
		System.out.println("Main method started..");
		Scanner sc = new Scanner(System.in);
		
		try
		{
			System.out.print("Enter the value of x :");
			int x = sc.nextInt();
			
			System.out.print("Enter the value of y :");
			int y = sc.nextInt();
			
			int res = x/y; 
			System.out.println("Result is :"+res);
			System.out.println("Inside try");
		}
		catch(Exception e)
		{
			System.out.println("Inside catch");
			System.err.println(e);
		}
		
		System.out.println("Main method ended..");
		sc.close();
	}

}

Note :- The above program in the protection of try-catch so, even we have an exception (y=0) but program will be terminated normally.
------------------------------------------------------------------
package com.ravi.exception;

public class ExceptionTermination {

	public static void main(String[] args)
	{
		try
		{
			//System.out.println(10/0);
			throw new ArithmeticException();
			
		}
		catch(Exception e)
		{
			System.err.println("Catch");
			System.err.println(e);
		}
		
		
	}

}

The above program describes how to create and throw an exception object explicitly. try block is doing the same implicitly.
------------------------------------------------------------------
07-03-2024
----------
The main purpose of Exception Handling to provide user-friendly message to the client.

package com.ravi.exception;

import java.util.Scanner;

public class CustomerDemo 
{
	public static void main(String[] args) 
	{
	  System.out.println("Welcome User, Welcome Here!!!");
	  Scanner sc = new Scanner(System.in);
	  
	  try
	  {
		  System.out.print("Enter the value of x :");
		  int x = sc.nextInt();
		  
		  System.out.print("Enter the value of y :");
		  int y = sc.nextInt();
		  
		  int res = x /y;
		  System.out.println("Result is :"+res);
		  
	  }
	  catch(Exception e)
	  {
		System.err.println("Please don't put zero");  
	  }
	  sc.close();
	  System.out.println("Thank you for visiting application");
	}
}
-----------------------------------------------------------------
Throwable class method :
------------------------
Throwable class has provided the following three methods :

1) public String getMessage() :- It will provide only error message.

2) public void printStackTrace() :-  It will provide the complete details regarding exception like exception class name, exception message, exception class location, exception method name and exception line number.

3) public String toString() :- It will convert the exception into
                               String representation.
------------------------------------------------------------------
package com.ravi.basic;

public class PrintStackTrace 
{
	public static void main(String[] args) 
	{
		System.out.println("Main method started...");		
		try
		{
			String x = "Ravi";
			int y = Integer.parseInt(x); 
			System.out.println(y);	
		}
		catch(Exception e)
		{
			e.printStackTrace(); //For complete Exception details
			System.out.println("---------------------------");
			System.out.println("............................");
			System.out.println(e.getMessage()); //only for Exception message	
			System.out.println("..............");
			System.out.println(e.toString());
		}
		System.out.println("Main method ended...");		

	}

}
-----------------------------------------------------------------
Working with Specific Exception :
---------------------------------
While working with exception, in the corresponding catch block we can take Exception (super class) which can handle any type of Exception.

On the other hand we can also take specific type of exception (ArithmetiException, NullPointerException and so on) which will handle only one type i.e specific type of exception.
-------------------------------------------------------------------
package com.ravi.basic;

import java.util.InputMismatchException;
import java.util.Scanner;

public class SpecificException 
{
	public static void main(String[] args) 
	{
		System.out.println("Main started");
		
		Scanner sc = new Scanner(System.in);
		
		try
		{			
			System.out.print("Enter your Roll :");
			int roll = sc.nextInt();
			System.out.println("Your Roll is :"+roll);
		}
		catch(InputMismatchException e)
		{
			System.err.println("Input is not in proper format");
		}
		sc.close();
		System.out.println("Main ended");
	}
}
-------------------------------------------------------------------
package com.ravi.basic;

public class SpecificException1 
{
	public static void main(String[] args)
	{
		try
		{
			throw new OutOfMemoryError();
		}
		catch(Exception e)  //Throwable is reqd
		{
			System.out.println("Inside catch block");
			System.out.println(e);
			
		}
	}

}

Note : Here catch block will not be executed because Exception class can handle only Exception but not Error.


package com.ravi.basic;

public class SpecificException1 
{
	public static void main(String[] args)
	{
		try
		{
			throw new OutOfMemoryError();
		}
		catch(Throwable e)  
		{
			System.out.println("Inside catch block");
			System.out.println(e);
			
		}
	}

}
-----------------------------------------------------------------
Working with Infinity and Not a number(NaN) :
---------------------------------------------
10/0    -> Infinity (Java.lang.ArithmeticException)
10/0.0  -> Infinity  (POITIVE_INFINITY)

0/0     -> Undefined (Java.lang.ArithmeticException)
0/0.0   -> Undefined  (NaN)


While working with Integral literal in both the cases i.e Infinity (10/0) and Undefined (0/0) we will get java.lang.ArithmeticException because java software people has not provided any final, static variable support to deal with Infinity and Undefined.

On the other hand while working with floating point literal in the both cases i.e Infinity (10/0.0) and Undefined (0/0.0) we have final, static variable support so the program will not be terminated in the middle which are as follows

10/0.0 = POSITIVE_INFINITY
-10/0.0 = NEGATIVE_INFINITY
0/0.0 = NaN

package com.ravi.basic;

public class InfinityFloatingPoint 
{
	public static void main(String[] args) 
	{
	   System.out.println("Main Started");
	   System.out.println(10/0.0); 
	   System.out.println(-10/0.0); 
	   System.out.println(0/0.0);   
	   System.out.println(10/0); 
	   System.out.println("Main Ended");
	}

}
-----------------------------------------------------------------
08-03-2024
----------
Working with multiple try catch :
---------------------------------
According to our application requirement we can provide multiple try-catch in my application to work with multiple execptions.

package com.ravi.basic;
public class MultipleTryCatch 
{
	public static void main(String[] args) 
	{
	  System.out.println("Main method started!!!!");
	  
	  try
	  {
		  int arr[] = {10,20,30};
		  System.out.println(arr[3]);
	  }
	  catch(ArrayIndexOutOfBoundsException e)
	  {
		  System.err.println("Array is out of limit!!!");
	  }
	  
	  try
	  {
		 String str = null;
		 System.out.println(str.length());
	  }
	  catch(NullPointerException e)
	  {
		  System.err.println("ref variable is pointing to null");
	  } 
	  
	  System.out.println("Main method ended!!!!");	
	}
}
----------------------------------------------------------------
* Single try with multiple catch block :
-----------------------------------------
According to industry standard we should write try with multiple catch block so we can provide proper information for each and every exception.

While working with multiple catch block always the super class catch block must be last catch block.

From java 1.7v this multiple exceptions we can write in a single catch block by using | symbol.

If try block is having more than one exception then always try block will handle only first exception because control will transfer to the nearest catch block.
-----------------------------------------------------------------
package com.ravi.basic;
public class MultyCatch 
{
	public static void main(String[] args) 
	{
		System.out.println("Main Started...");		
		try
		{
			int c = 10/0;			
			System.out.println("c value is :"+c);	
			
			int []x = {12,78,56};
			System.out.println(x[5]);						
		}
			
		catch(ArrayIndexOutOfBoundsException e1)
		{
			System.err.println("Array is out of limit...");
		}
		catch(ArithmeticException e1)
		{
			System.err.println("Divide By zero problem...");
		}
		catch(Exception e1)
		{
			System.out.println("General");
		}					
		System.out.println("Main Ended...");
	}
}
----------------------------------------------------------------
package com.ravi.basic;

public class MultyCatch1 
{
	public static void main(String[] args) 
	{
		System.out.println("Main method started!!!");
		try
		{
		   String str1 = "India";
		   System.out.println(str1.toUpperCase());
		   
		   String str2 = "Ravi";
		   int x = Integer.parseInt(str2);
		   System.out.println("Number is :"+x);
		}
		catch(NumberFormatException | NullPointerException  e)
		{
			e.printStackTrace();
		}

		System.out.println("Main method ended!!");
	}

}
----------------------------------------------------------------
finally block :
---------------
finally is a block which is meant for Resource handling purposes.

According to Software Engineering, the resources are memory creation, buffer creation, opening of a database, working with files, working with network resourses and so on.

Whenever the control will enter inside the try block always the finally block would be executed.

We should write all the closing statements inside the finally block because irrespective of exception finally block will be executed every time.

If we use the combination of try and finally then only the resources will be handled but not the execption, on the other hand if we use try-catch and finally then execption and resourses both will be handled.
----------------------------------------------------------------
package com.ravi.basic;

public class FinallyBlock 
{
	public static void main(String[] args) 
	{
		System.out.println("Main method started");
		
		try
		{
			System.out.println(10/0);
		}
		finally
		{
			System.out.println("Finally Block");
		}
		
		System.out.println("Main method ended");
	}

}

Note :- In the above program finally block will be executed, even we have an exception in the try block but here only the resourses will be handled but not the exception.
----------------------------------------------------------------
package com.ravi.basic;

public class FinallyWithCatch 
{
	public static void main(String[] args) 
	{		
		try
		{
		    int []x = new int[-2];	//We can't pass negative size of an array in negative
		    x[0] = 12;
		    x[1] = 15;
		    System.out.println(x[0]+" : "+x[1]);
		}
		catch(NegativeArraySizeException e)
		{		
			System.err.println("Array Size is in negative value...");
		}
		finally
		{
		   System.out.println("Resources will be handled here!!");		   
		}
		System.out.println("Main method ended!!!");
	}
}

Note :- In the try block if we write System.exit(0) and if this line is executed then finally block will not be executed.
---------------------------------------------------------------
09-03-2024
-----------
Limitation of finally block :
-----------------------------
The following are the limitations of finally block :

1) User is responsible to close the resources manually.
2) Due to finally block the length of the code will be increased.
3) While using finally block we should declare all our resources 
   outside of the try block otherwise the resourses will become 
   block level variable.

package com.ravi.finally_demo;

import java.util.InputMismatchException;
import java.util.Scanner;

public class FinallyLimitation 
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		try
		{			
			System.out.print("Enter Roll Number :");
			int roll = sc.nextInt();
			System.out.println("Your Roll Number is :"+roll);
			
		}
		catch(InputMismatchException e)
		{
			System.err.println("Input is Invalid");
		}
        finally
        {
        	System.out.println("Finally Block executed");
        	sc.close();
        }
	}

}


try with resources :
--------------------
To avoid all the limitation of finally block, Java software people introduced a separate concept i.e try with resources from java 1.7 onwards.

Case 1:
-------
try(resource1 ; resource2)  //Only the resources will be handled
{
}

Case 2 :
----------
//Resources and Exception both will be  handled
try(resource1 ; resource2) 
{                          
}
catch(Exception e)
{
}

Case 3 :
----------
try with resourses enhancement from java 9v

Resourse r1 = new Resourse();

try(r1)
{
}
catch(Exception e)
{
}


There is a predefined interface available in java.lang package called AutoCloseable which contains predefined abstract method i.e close() which throws Exception.

There is another predefined interface available in java.io package called Closeable, this Closeable interface is the sub interface for AutoCloseable interface.

public interface java.lang.AutoCloseable
{
   public abstract void close() throws Exception;
}
public interface java.io.Closeable extends java.lang.AutoCloseable
{
   void close() throws IOException;
}

Whenever we pass any resourse class as part of try with resources then that class must implements either Closeable or AutoCloseable interface so, try with resourses will automatically call the respective class
close() method even an exception is encountered in the try block.

try(ResourceClass rc = new ResourceClass())  
{                                              
}                                               
catch(Exception e)                             
{                                          

}

//This ResourceClass must implements either Closeable or AutoCloseable interface so, try block will automatically call the close() method.

The following program explains how try block is invoking the close() method available in DatabaseResource class and FileResource class. 

3 Files :
----------
DatabaseResource.java
---------------------
package com.ravi.try_resources;

public class DatabaseResource implements AutoCloseable
{
	@Override
	public void close() throws Exception 
	{
		System.out.println("Database Resource closed successfully");		
	}

}

FileResource.java
-----------------
package com.ravi.try_resources;

import java.io.Closeable;
import java.io.IOException;

public class FileResource implements Closeable
{
	@Override
	public void close() throws IOException 
	{
		System.out.println("File Resource closed successfully");		
	}

}

Main.java
----------
package com.ravi.try_resources;

public class Main 
{
	public static void main(String[] args) throws Exception 
	{
		DatabaseResource dr = new DatabaseResource();
		FileResource fr = new FileResource();
		
		try(dr ; fr)
		{
		System.out.println(10/0);	
		}
		catch(ArithmeticException e)
		{
			System.err.println("Divide by zero");
		}
	}

}

Note :- In the parameter of try, we have passed two resource classes references i.e DatabaseResource and FileResource.

Now try block is resposible to call the close() automatically even we have an exception in the try block.
---------------------------------------------------------------
WAP to automatically close the resource by using Scanner class.

package com.ravi.exception;

import java.util.InputMismatchException;
import java.util.Scanner;

public class TryWithResource {

	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		
		try(sc)
		{
			System.out.println("Enter your Employee Id :");
			int id = sc.nextInt();
			System.out.println("Your Id is :"+id);
		}
		catch(InputMismatchException e)
		{
			System.err.println("Input is Invalid");
		}
	}

}

Note :- Scanner class internally implementing Closeable interface so it is providing auto closing facility, as a user we need to pass the reference of Scanner class inside try with resources try()
----------------------------------------------------------------
Nested try block :
------------------
If we write a try block inside another try block then it is called Nested try block.

try  //Outer try             
{
  statement1;
     try  //Inner try
     {
        statement2;
     }
     catch(Exception e) //Inner catch
     {
     }

}
catch(Exception e) //Outer Catch
{
}

The execution of inner try block depends upon outer try block that means if we have an exception in the Outer try block then inner try block will not be executed.
----------------------------------------------------------------
package com.ravi.basic;

public class NestedTryBlock 
{
	public static void main(String[] args) 
	{		
	      try  //outer try
	      {
	    	    String x = "India";
	    	    System.out.println("It's length is :"+x.length());
	    	        
		    	  try  //inner try
		    	  {
		    		 String y = "NIT"; 
		    		 int z = Integer.parseInt(y);
		    		 System.out.println("z value is :"+z);	    				    		  
		    	  }
		    	  catch(NumberFormatException e)
		    	  {
		    		System.err.println("Number is not in a proper format");  
		    	  }
	      }
	      catch(NullPointerException e)
	      {
	    	  System.err.println("Null pointer Problem"); 	    	 
	      }	      
	}
}
----------------------------------------------------------------
Writing try-catch inside catch block :
---------------------------------------
We can write try-catch inside catch block but this try-catch block will be exceuted if the catch block will executed that means if we have an exception in the try block.

package com.ravi.basic;

import java.util.InputMismatchException;
import java.util.Scanner;

public class TryWithCatchInsideCatch 
{
	
	public static void main(String[] args)
	{
		Scanner sc = new Scanner(System.in);
		
		try(sc )
		{			
			System.out.print("Enter your Roll number :");
			int roll = sc.nextInt();
			System.out.println("Your Roll is :"+roll);			
			
		}	
		catch(InputMismatchException e)
		{
			System.err.println("Provide Valid input!!");
			
			try
			{
				System.out.println(10/0);
			}
			catch(ArithmeticException e1)
			{
			  System.err.println("Divide by zero problem");	
			}
			
		}
	}

}
---------------------------------------------------------------
11-03-2024
-----------
try-catch with return statement
-------------------------------
If we write try-catch block inside a method and that method is returning some value then we should write return statement in both the places i.e inside the try block as well as inside the catch block.

We can also write return statement inside the finally block only, if the finally block is present. After this return statement we cannot write any kind of statement. (Unrechable)

Always finally block return statement having more priority then try-catch return statement.
----------------------------------------------------------------
package com.ravi.advanced;
public class ReturnExample
{
    public static void main(String[] args) 
    {     	
       System.out.println(methodReturningValue());        
    }	
	
	
	public static int methodReturningValue()
    {
        try
        {
            System.out.println("Try block");
            //System.out.println(10/0);
            return 10;    
        }
        catch (Exception e)
        {
            System.out.println("catch block");         
            return 20;  //return statement is compulsory  
        }
               
    }
}
-----------------------------------------------------------------
package com.ravi.advanced;

public class ReturnExample1 {

	public static void main(String[] args)
	{
		System.out.println(m1());
	}

	@SuppressWarnings("finally")
	public static int m1()
	{	
		try
		{
			System.out.println("Inside try");
			return 100;
		}
		catch(Exception e)
		{
			System.out.println("Inside Catch");
			return 200;
		}
		finally
		{
			System.out.println("Inside finally");
			return 300;
		}
		
		// System.out.println("....");   Unreachable line
	}
}

We have return keyword in the program then after this return keywoyd, outside of the finally block we cannot write any kind of statement.
-----------------------------------------------------------------
Initialization of a variable in try and catch :
-----------------------------------------------
A local variable must be initialized inside try block as well as catch block OR at the time of declaration.

If we initialize inside the try block only then from catch block we cannot access local variable value, Here initialization is compulsory inside catch block.

package com.ravi.basic;

public class VariableInitialization 
{
	public static void main(String[] args) 
	{      
	   int x;
       try
       {   
    	   
    	   x = 12;
    	   System.out.println(x);
       }
       catch(Exception e)
       {    
    	   x = 15;
    	   System.out.println(x);
       }
      
       System.out.println("Main completed!!!");
	}

}
-----------------------------------------------------------------
**Difference between Checked Exception and Unchecked Exception :
----------------------------------------------------------------
Checked Exception :
----------------------
In java some exceptions are very common exceptions are called Checked excption here compiler takes very much care and wanted the clarity regarding the exception by saying that, by using this code you may face some problem at runtime and you did not report me how would you handle this situation at runtime are called Checked exception, so provide either try-catch or declare the method as throws.

All the checked exceptions are directly sub class of java.lang.Exception

Eg:
---
FileNotFoundException, IOException, InterruptedException,ClassNotFoundException, SQLException, CloneNotSupportedException, EOFException and so on

Unchecked Exception :-
--------------------------
The exceptions which are rarely occurred in java and for these kinds of exception compiler does not take any care are called unchecked exception.

Unchecked exceptions are directly entertain by JVM because they are rarely occurred in java.

All the un-checked exceptions are sub class of RuntimeException

RuntimeException is also Unchecked Exception.

Eg:
---
ArithmeticException, ArrayIndexOutOfBoundsException, NullPointerException, NumberFormatException, ClassCastException, ArrayStoreException and so on.
-----------------------------------------------------------------
Some Bullet points regarding Checked and Unchecked :
-----------------------------------------------------
Checked Exception :
------------------
  1) Common Exception
  2) Compiler takes care (Will not compile the code)
  3) Handling is compulsory (try-catch OR throws)
  4) Directly the sub class of java.lang.Exception

Unchecked Exception :
----------------------
  1) Rare Exception
  2) Comiler will not take any care
  3) Handling is not Compulsory
  4) Sub class of RuntimeException
--------------------------------------------------------------------------
When to provide try-catch or declare the method as throws :-
-------------------------------------------------------------------
We should provide try-catch if we want to handle the exception by own as well as if we want to provide user-defined messages to the client but on the other hand we should declare the method as throws when we are not interested to handle the exception and try to send it to the JVM for handling purpose. 

Note :- It is always better to use try catch so we can provide appropriate user defined messages to our client.
-----------------------------------------------------------------
*Why compiler takes very much care regarding the checked Exception ?
------------------------------------------------------------------
As we know Checked Exceptions are very common exception so in case of checked exception "handling is compulsory" because checked Exception depends upon other resources as shown below.

IOException  (we are depending upon System Keyboard OR Files )
FileNotFoundException(We are depending upon the file)
InterruptedException (Thread related problem)
ClassNotFoundException (class related problem)
SQLException (SQL related or database related problem)
CloneNotSupportedException (Object is the resourse)
EOFException(We are depending upon the file)
-----------------------------------------------------------------
* What is the difference between throw and throws :
----------------------------------------------------
throw :
--------
try block is responsible to create the exception object and throw the exception object to the nearest catch block but it works with predefined exception implicitly.

If a user wants to throw an exception based on his own requirement and specification by using userdefined exception then we should write throw keyword to throw the exception object explicitly. (throw new InvalidMarksException())

THROWING THE EXCEPTION OBJCET EXPLICITLY.

throws :- 
---------
In case of checked Exception if a user is not interested to handle the exception and wants  to throw the exception to JVM, wants to skip from the current situation then we should declare the method as throws.
It is mainly used to work with Checked Exception.
-----------------------------------------------------------------
12-03-2024
-----------
Types of exception in java :
-------------------------------
Exception can be divided into two types :

1) Predefined Exception OR Built-in Exception

2) Userdefined Exception OR Custom Exception

Predefined Exception :-
-------------------------
The Exceptions which are already defined by Java software people for some specific purposes are called predefined Exception or Built-in exception.
Ex :
----
IOException, ArithmeticException and so on

Userdefined Exception :-
---------------------------
The exceptions which are defined by user according to their own use and requirement are called User-defined Exception.

Ex:-
----
InvalidAgeException, GreaterMarksException
-----------------------------------------------------------------------
Steps to create userdefined exception :
------------------------------------------
In order to create user defined exception we should follow the following steps.

1) A userdefined exception class must extends either Exception(Checked Exception) Or RuntimeException(Unchecked Exception) as a super class.

    a) If our userdefined class extends RuntimeException that menas we are creating UncheckedException.

    b) If our userdefined class extends Exception that menas we are creating checkedException and exception handling is compulsory here.

2) The userdefined class must contain No argument constructor as well as parameterized construtor(in case we want to pass some userdefined error message).

   We should take No argument constructor if we don't want to send any error message where as we should take parameterized constructor with super keyword if we want to send the message to the super class.

3) We should use throw keyword to throw the Exception object explicitly.
--------------------------------------------------------------------
Program to create user-defined Checked Exception :
--------------------------------------------------
package com.ravi.exception;

import java.util.Scanner;

@SuppressWarnings("serial")
class InvalidAgeException extends Exception
{
	public InvalidAgeException()
	{		
	}
	
	public InvalidAgeException(String errorMessage)
	{
		super(errorMessage);
	}
}

public class UserdefinedCheckedException 
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		try(sc)
		{
			System.out.print("Enter your Age :");
			int age = sc.nextInt();
			
			if(age < 18)
			{
			   throw new InvalidAgeException("Invalid Age");
			}
			else
			{
				System.out.println("You are eligible for Vote");
			}
		} 
		catch (InvalidAgeException e) 
		{
			e.printStackTrace();
		}
	}
}
--------------------------------------------------------------------
Program to develop un-checked Exception :
------------------------------------------
package com.ravi.exception;

import java.util.Scanner;

@SuppressWarnings("serial")
class GreaterMarksException extends RuntimeException
{
	public GreaterMarksException()
	{
		
	}
	
	public GreaterMarksException(String errorMessage)
	{
	  super(errorMessage);	
	}
}

public class UserdefinedUnchecked 
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		try(sc)
		{
			System.out.print("Enter the marks :");
			
			int marks = sc.nextInt();
			
			if(marks > 100)
			{
				throw new GreaterMarksException("Invalid Marks");
			}
			else
			{
				System.out.println("Your Marks is :"+ marks);
			}
		}
		catch(GreaterMarksException e)
		{
			System.err.println(e);
		}
        System.out.println("Main completed");
	}

}
-------------------------------------------------------------------
Some important points to remember :
------------------------------------
a) If the try block does not throw any checked exception then in the corresponding catch block we can't handle checked exception.It will generate compilation error i.e "exception never thrown from the corresponding try statement"

Example :-

try
{
  //try block is not throwing any checked Exception
}
catch(IOException e) //Error
{

}
-------------------------------------------------------------------
package com.ravi.method_related_rule;

import java.io.IOException;

public class CatchingCheckedWithoutThrow 
{
	public static void main(String[] args) 
	{
		try
		{
			//throw new IOException();
		}
		catch(IOException e) //error
		{
			System.err.println("Input Output Exception");
		}

	}

}


Note :- The above rule is not applicable for Unchecked Exception

               try
		{
			
		}
		catch(ArithmeticException e)  //Valid
		{
			e.printStackTrace();
		}
-------------------------------------------------------------------
b) If the try block does not throw any exception then in the corresponding catch block we can write Exception, Throwable because both are the super classes for all types of Exception whether it is checked or unchecked.

package com.ravi.method_related_rule;

public class CatchingWithSuperClass 
{
	public static void main(String[] args) 
	{
		
		try
		{
			//throw new IOException();
		}
		catch(Exception e)
		{
          e.printStackTrace();			
		}

	}

}
-------------------------------------------------------------------
c) At the time of method overriding if the super class method does 
   not reporting or throwing checked exception then the overridden method of sub class not allowed to throw checked exception. otherwise it will generate compilation error but overridden method can throw Unchecked Exception.

package com.ravi.method_related_rule;

class Super
{
	public void show()  
	{
		System.out.println("Super class method not throwing checked Exception");
	}
}
class Sub extends Super
{
	@Override
	public void show() throws IOException  //error
	{
		System.out.println("Sub class method should not throw checked Exception");
	}
}

public class MethodOverridingWithChecked {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
------------------------------------------------------------------
d) If the super class method declare with throws keyword to throw a checked exception, then at the time of method overriding, sub class method may or may not use throws keyword.
               If the Overridden method is also using throws
 keyword to throw checked exception then it must be either same exception class or sub class, it should not be super class as well as we can't add more exceptions in the overridden method.

package com.ravi.method_related_rule;


import java.io.FileNotFoundException;
import java.io.IOException;

class Base
{
	public void show() throws FileNotFoundException
	{
		System.out.println("Super class method ");
	}
}
class Derived extends Base
{
	//throws is applicable but must be equal or sub class
	public void show() //throws IOException
	{
		System.out.println("Sub class method ");
	}
}

public class MethodOverridingWithThrows 
{
	public static void main(String[] args) 
	{
	  System.out.println("Overridden method may or may not throw checked exception but if it is throwing then must be same or sub class");	
	}

}
------------------------------------------------------------------
Initializer must be complete normally (In static block and non static block abnormal termination is not possible)

class Check
{
          static
	  {
	   throw new Exception();  //error
	  }
}
public class Test
{
  public static void main(String [] args)
  {
	 
     
  }
}
------------------------------------------------------------
package com.ravi.exception;

class Test
{
	static
	{
		try
		{
			throw new Exception("My Error Message");
		}
		catch(Exception e)
		{
			System.err.println("Inside Catch block");
			System.err.println(e);
		}
	}
}

public class Main {

	public static void main(String[] args) 
	{
		new Test();

	}

}

The above code is valid.
--------------------------------------------------------------
13-03-2024
-----------
Exception propagation :-  [Exception object will shift from callee to caller]
--------------------------
Whenever we call a method and if the the callee method contains any kind of exception and if callee method doesn't contain any kind of exception handling mechanism (try-catch) then JVM will propagate the exception to caller method for handling purpose. This is called Exception Propagation.

If the caller method also does not contain any exception handling mechanism then JVM will terminate the method from the stack frame hence the remaining part of the method(m1 method) will not be executed even if we handle the exception in another caller method like main.

If any of the the caller method does not contain any exception handling mechanism then exception will be handled by JVM, JVM has default exception handler which will provide the exception message and terminates the program abnormally.
--------------------------------------------------------------
package com.ravi.exception;

public class ExceptionPropagation {

	public static void main(String[] args) 
	{		
		System.out.println("Main method Started..");
		try
		{
			m1();
		}
		catch(ArithmeticException e)
		{
			System.err.println("Handled in main method");
		}
		System.out.println("Main method Ended..");
	}
		
    public static void m1()
	{
		System.out.println("m1 method Started..");
		m2();
		System.out.println("m1 method Ended.."); //This line will not be
		                                         //executed
	}
    
    public static void m2()
    {
    	System.out.println(10/0);
    }
	

}
--------------------------------------------------------------
Rules for Method call regarding Checked Exception :
---------------------------------------------------
* Whenever we call a method and if the method is     
  throwing/reporting Checked Exception then the caller method
  must have either try catch or throws otherwise code will 
  not compile.

  class Demo 
   {
	public static void main(String[] args) 
	{
		m1(); //error -> try-catch OR throws
		System.out.println("Main");
	}

	public static void m1() throws InterruptedException
	{
	}
   }
--------------------------------------------------------------
The same above rule is not applicable for Unchecked Exception

class Demo 
{
	public static void main(String[] args) 
	{
		m1();
		System.out.println("Main");
	}

	public static void m1() throws ArithmeticException
	{
	}
}
--------------------------------------------------------------
class Demo 
{
	public static void main(String[] args) 
	{
		m1(); //error try catch Or throws reqd
		System.out.println("Main");
	}

	public static void m1() throws Exception
	{
	}
}
-------------------------------------------------------------
----------------------------------------------------------------
16-03-2024
-----------
enum in java :
--------------
An enum is class in java that is used to represent group of universal constants. It is introduced from JDK 1.5 onwards. 

In order to craete an enum, we can use enum keyword and all the univarsal constants of the enum must be separeted by comma. Semicolon is optional at the end.

Example:-

enum Color 
{
    RED, BLUE, BLACK, PINK     //public + static + final

 }

The enum constants are by default public, static and final.

An enum we can define inside the class, outside of the class and even inside of the method.

If we define an enum inside the class then we can apply public, private, protected and static.

Every enum in java extends java.lang.Enum class so an enum can implement many interfaces but can't extends a class.

By deafult every enum is implicitly final so we can't inherit an enum.

In order to get the constant value of an enum we can use values() method which returns enum array, but this method is added by compiler to each and every enum at the time of compilation.

In order to get the order position of enum constants we can use ordinal() method which is given inside the enum class and the return type of this method is int. The order position of enum constant will start from 0.

As we know an enum is just like a class so we can define any method, constructor inside an enum. Constructor must be either private or default.

*All the enum constants are by default object of type enum.

Enum constants must be decalred at the first line of enum otherwise we will get compilation error.

From java 1.5 onwards we can pass an enum in a switch statement.

In order to compare two enum constants we have final equals(Object obj)
method in the java.lang.Enum class which will compare two objects based on the memory reference.
-----------------------------------------------------------------
public class Test1
{
	public static void main(String[] args) 
	{
		enum Month
		{
			JANUARY, FEBRUARY,MARCH     //public + static + final
		}

		System.out.println(Month.MARCH);
	}
}
---------------------------------------------------------------
enum Month 
{
	JANUARY,FEBRUARY,MARCH 
} 
public class Test2
{
	enum Color { RED,BLUE,BLACK } 

     public static void main(String[] args) 
	{
		enum Week {SUNDAY, MONDAY, TUESDAY }
		
		System.out.println(Month.FEBRUARY);
		System.out.println(Color.RED);
		System.out.println(Week.SUNDAY);
	}
}

Note :- From the above Program it is clear that we can define an enum inside a class, outside of a class and inside a method as well.
----------------------------------------------------------------
//Comapring the constant of an enum
public class Test3 
{
	enum Color { RED,BLUE } 

     public static void main(String args[])
     {
          Color c1 = Color.RED; 
          Color c2 = Color.RED;  
		  
          if(c1 == c2)
          {
                System.out.println("==");
          }
          if(c1.equals(c2))
          {
                 System.out.println("equals");
          }
     }	
}

Here == operator and equals(Object obj) method both will return true because equals(Object obj) method internally uses == operator only.
-----------------------------------------------------------------
public class Test4 
{
	private enum Season   //private, public, protected, static
	{
	SPRING, SUMMER, WINTER, RAINY;
	}

	public static void main(String[] args) 
	{
		System.out.println(Season.RAINY);
	}
}
----------------------------------------------------------------
//Interview Question
class Hello
{
	int x = 100;
}

enum Direction extends Hello
{
	EAST, WEST, NORTH, SOUTH
}

class Test5 
{
	public static void main(String[] args) 
	{
		System.out.println(Direction.SOUTH);
	}
}
----------------------------------------------------------------
//All enums are by default final so can't inherit

enum Color
{
	RED, BLUE, PINK;
}
class Test6 extends Color
{
	public static void main(String[] args) 
	{
		System.out.println(Color.RED);
	}
}
----------------------------------------------------------------
//values() to get all the values of enum

class Test7 
{
	enum Season   
	{
	SPRING, SUMMER, WINTER, FALL, RAINY
	}

	public static void main(String[] args) 
	{
		Season x []=  Season.values();
         
		 for(Season y : x)
		  System.out.println(y);
	}
}
----------------------------------------------------------------
//ordinal() to find out the order position
class Test8
{
	static enum Season   
	{
	SPRING, SUMMER, WINTER, FALL, RAINY
	}


	public static void main(String[] args) 
	{
		Season s1[] = Season.values();

		for(Season x : s1)
			System.out.println(x+" order is :"+x.ordinal());
	}
}
----------------------------------------------------------------
18-03-2024
-----------
//We can take main () inside an enum

enum Test9 
{
	TEST1, TEST2, TEST3;  //Semicolon is compulsory 

	public static void main(String[] args) 
	{
		System.out.println("Enum  main method");
	}	
}
----------------------------------------------------------------
//constant must be in first line of an enum

enum Test10
{ 

	public static void main(String[] args) 
	{
		System.out.println("Enum  main method");
	}

    HR, SALESMAN, MANAGER;
	
}
-----------------------------------------------------------------
//Writing constructor in enum
enum Season
{
	WINTER, SUMMER, SPRING, RAINY;   //All are object of type enum
  
	Season()
	{
		System.out.println("Constructor is executed....");
	}	
}
class Test11 
{
	public static void main(String[] args) 
	{
		System.out.println(Season.WINTER);
		System.out.println(Season.SUMMER);
		
	}
}
----------------------------------------------------------------
   //Writing constructor with message
   enum Season   
	{
	   SPRING("Pleasant"), SUMMER("UnPleasent"), RAINY("Rain"), WINTER;

        String msg;
	  
	    Season(String msg)
		{
		  this.msg = msg;
		}

		Season()
		{
			this.msg = "Cold";
		}

		public String getMessage()
		{
			return msg;
		}
	}
class Test12
{	
	public static void main(String[] args) 
	{
		Season s1[] = Season.values();

		for(Season x : s1)
			System.out.println(x+"  is :"+x.getMessage());
	}
}
----------------------------------------------------------------
enum MyType 
{
ONE 
{
	@Override
    public String toString() 
	{
        return "this is one";
    }
},
 
TWO 
{
	@Override
    public String toString() 
	{
        return "this is two";
    }
}
}
public class Test13
{
	public static void main(String[] args) 
	{
		System.out.println(MyType.ONE);
		System.out.println(MyType.TWO);
		
	}
}
----------------------------------------------------------------
public class Test14
{  
	enum Day
		{ 
		  SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY
		}  
  
public static void main(String args[])
{    
	Day day=Day.SUNDAY;  
	  
	switch(day)
	{  
	 case SUNDAY:   
	 System.out.println("Sunday");  
	 break;  
	 case MONDAY:   
	 System.out.println("Monday");  
	 break;  
	 default:  
	 System.out.println("other day");  
    }  
  
  }
}  
----------------------------------------------------------------
Input Output in java :
-----------------------
In order to work with input and output concept, java software people has provided a separate package called java.io package.

By using this java.io package we can read the data from the user, creating file, reading/writing the data from the file and so on.

How to take the input from the user using java.io package :
------------------------------------------------------------
Scanner class is available from java 1.5 onwards but before 1.5, In order to read the data we were using the following two classes which are available in java.io package.

1) DataInputStream (Deprecated)
2) BufferedReader

How to create the object :
--------------------------
DataInputStream :
-----------------
DataInputStream d = new DataInputStream(System.in);

BufferedRedaer :
----------------
It provides more faster technique because it internally stores the data in a buffer and it is always recomended to read the data from the buffer.

InputStreamReader isr = new InputStreamReader(System.in);
BufferedReader br = new BufferedReader(isr);
                       OR
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

Working with Methods :
----------------------
1) public int read() :- It is used to read a single character from the source and return the UNICODE value of the character. 
			If the data is not available from the source then it will return -1.


2) public String readLine() :- It is used to read multiple characters or complete line from the source. The
return type of this method is String.
-----------------------------------------------------------------
//Reading my name from the keyboard
import java.io.*;
public class ReadName
{ 
	public static void main(String[] args) throws IOException
	{
		DataInputStream d = new DataInputStream(System.in);	
		System.out.println("Enter your Name :");
		String name = d.readLine();
		System.out.println("Your Name is :"+name);
	}
}
----------------------------------------------------------------
//WAP to read your age from the keyboard
import java.io.*;
public class ReadInteger 
{
	public static void main(String[] args) 
	{
		try
		{
			BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

			System.out.print("Enter your Age :");
			String ag = br.readLine();

            //Converting String to integer
			int age = Integer.parseInt(ag);

            System.out.println("Your Age is :"+age);
            if(age > 18)
			{
				System.out.println("Go for a movie");
			}
			else
			{
				System.out.println("You are minor ..try after some year");
			}
			
		}
		catch (IOException e)
		{
			e.printStackTrace();
		}
			
	}
}
----------------------------------------------------------------
//WAP in java to read a float value(salary) from the keyboard
import java.io.*;
public class ReadSalary 
{
	public static void main(String[] args) throws IOException
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		System.out.print("Please enter your Salary :");
		String sal = br.readLine();

        //Converting String to float value
		float salary = Float.parseFloat(sal);

		System.out.println("Your salary is :"+salary);

	}
}
----------------------------------------------------------------
//WAP in java to read a character i.e gender from the keyboard
import java.io.*;
public class ReadCharacter 
{
	public static void main(String[] args) throws IOException
	{
		
		var br = new BufferedReader(new InputStreamReader(System.in));
		System.out.print("Enter your Gender [M/F]:");
		char gen = (char) br.read();
		System.out.println("Your Gender is :"+gen);
		
	}
}
----------------------------------------------------------------
import java.io.*;
public class ReadEmployeeData 
{
	public static void main(String[] args) throws IOException
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		System.out.print("Enter Employee Id :");
		int id = Integer.parseInt(br.readLine());

        System.out.print("Enter Employee Name :");
		String name = br.readLine();

		System.out.print("Enter Employee Gender :");
        char gender = br.readLine().charAt(0); 
		

		System.out.print("Enter Employee Salary :");
		double salary = Double.parseDouble(br.readLine());

		System.out.println("Employee Id is :"+id);
		System.out.println("Employee Name is :"+name);
		System.out.println("Employee Gender is :"+gender);
		System.out.println("Employee Salary is :"+salary);

	}
}
---------------------------------------------------------------
19-03-2024
----------
File Handling :
---------------
What is the need of File Handling ?
-----------------------------------
 As we know variables are used to store some meaningful value in our program but once the execution of the program is over, now we can't get those values so to hold those values permanently in our memory we use files.

Files are stored in the secondary storage devices so, we can use/read the data stored in the file anytime according to our requirement. 

In order to work with File system java software people has provided number of predefined classes like File, FileInputStream, FileOutputStream and so on. All these classes are available in java.io package. We can read and write the data in the form of Stream.
---------------------------------------------------------------

Streams in java :
--------------------
A Stream is nothing but flow of data or flow of characters to both the end.
Stream is divided into two categories

1) byte oriented Stream :- 
    ------------------------
It used to handle characters, images, audio and video file in binary format.  

2) character oriented Stream :-
--------------------------------
It is used to handle the data in the form of characters or text.

Now byte oriented or binary Stream can be categorized as "input stream" and "output stream". input streams are used to read or receive the data where as output streams are used to write or send the data.

Again Character oriented Stream is divided into Reader and Writer. Reader is used to read() the data from the file where as Writer is used to write the data to the file.

All Streams are represented by classes in java.io package. 

InputStream is the super class for all kind of input operation where as OutputStream is the super class for all kind of output Operation for byte oriented stream.

Where as Reader is the super class for all kind reading operation where as Writer is the super class for all kind of writing operation in character oriented Stream.
----------------------------------------------------------------
File :-
-----
It is a predefined class in java.io package through which we can create file and directory. By using this class we can verify whether the file is existing or not.

File f = new File("abc.txt");

The above statement will not create any file, It actually create the file object and perform one of the following two task.
   a) If abc.txt does not exist, It will not create it
   b) if abc.txt does exist, the new file object will be refer to the referenec variable f

Now if the file does not exist then to create the file and verify whether file is existing or not, we should use the following two methods :

1) public boolean exists() : Will verify whether file is existing or not?

2) public boolean createNewFile() : Will Create a new file , if 
   file is already available then return false.

File class has also a predefined method called getName(), to get the name of the file.
----------------------------------------------------------------
import java.io.*;  
public class File0 
	{
		public static void main(String[] args) 
		{
			try 
				{
					File f = new File("C:\\new\\India.txt");

                    if(f.exists())
					{
						System.out.println("File is existing");
					}
					else
					{
						System.out.println("File is not existing");
					}

					if (f.createNewFile())
					   {
						 System.out.println("File created: " + f.getName());
                       }
					   else  
						{
                             System.out.println("File is already existing....");
                         }								  
                  }
				  catch (IOException e)
                 {
					System.err.println(e);
				} 
		}
}

Assignment :
------------
create a directory by using File class.
----------------------------------------------------------------
FileOutputStream :
------------------
It is a predefined class available in java.io package.

It is used to create a new file every time and after creating the file we can write the data to the file but the data must be available in binary format.
-----------------------------------------------------------------
String class has provided a predefined method getBytes() through which we can convert the String data into byte array (Binary format) as shown below.

       String str = "Hello Hyderabad";

       byte [] arr = str.getBytes();

       Here arr will print the UNICODE value of the character.
-----------------------------------------------------------------
//Creating and writing the data to the file

import java.io.*;
public class File1
{
     public static void main(String args[]) throws IOException
     {
		var fout = new FileOutputStream("C:\\new\\Hyderabad.txt");
        try(fout)
         {
         String s = "Hyd is a popular IT City in India";
		 byte b[] = s.getBytes();

		 fout.write(b);

		 System.out.println("Success....");
		 }
		 catch(Exception e)
		 {
			 e.printStackTrace();
		 }
     }
}
----------------------------------------------------------------
20-03-2024
-----------
FileInputStream :-
-----------------
It is a predefined class available in java.io package. It is used to read the file data/content. If we want to print the file data in console then data must be available in char format.

Note :- Whenever we want to write the data in the file then data must be available in byte format where as If we want to print the data to the console then the data must be converted into char format.
----------------------------------------------------------------
//Reading tha data from the file
import java.io.*;
public class File2
{
     public static void main(String s[]) throws IOException
     {         
		var fin = new FileInputStream("C:\\new\\Hyderabad.txt");

		 try(fin)
		 {
			 int i = 0;
             while(true)
			 {
				 i = fin.read();
				 if(i==-1)
					 break;
				 System.out.print((char)i);
			 }

		 }
		 catch(Exception e)
		 {
			 System.out.println(e);
		 }
		 System.out.println();
     }
}
----------------------------------------------------------------
//wap in java to read the data from one file and to write the data to another file.
import java.io.*;
public class File3
{
     public static void main(String s[]) throws IOException
     {  
	    //Outside of try (Java 9 enhancement in try with resource)

	   var fin = new FileInputStream("File2.java");
	   
	   var fout = new FileOutputStream("C:\\new\\f2.java");

	   try(fin; fout)
		 {
         while(true)
		 {
		     int i = fin.read();
			 if(i==-1) break;
			 System.out.print((char)i);
			 fout.write((byte)i);
		 }      
		 }
		 catch(IOException e)
		 {
			 e.printStackTrace();
		 }
     }
}
----------------------------------------------------------------
//wap in java to read the data from one file and to write the data to another file.
import java.io.*;
public class File3
{
     public static void main(String s[]) throws IOException
     {  
	    //Outside of try (Java 9 enhancement in try with resource)

	   var fin = new FileInputStream("File2.java");
	   
	   var fout = new FileOutputStream("C:\\new\\f2.java");

	   try(fin; fout)
		 {
         while(true)
		 {
		     int i = fin.read();
			 if(i==-1) break;
			 System.out.print((char)i);
			 fout.write((byte)i);
		 }      
		 }
		 catch(IOException e)
		 {
			 e.printStackTrace();
		 }
     }
}
-----------------------------------------------------------------
Limitation of FileInputStream class :
-------------------------------------
As we know FileInputStream class is used to read the content from the file but it can read the data from a single file only that means if we want to read the data from two files at the same time then we should use a separate Stream called SequenceInputStream.

SequenceInputStream :
-------------------------
It is a predefined class available in java.io package. This class is used to read the data from two files at the same time.
----------------------------------------------------------------
//Proram to read the data from two files at the same time
import java.io.*;
public class File4
{
     public static void main(String args[]) throws IOException
     {
         var f1 = new FileInputStream("File1.java");
         var f2 = new FileInputStream("File2.java");

         var s = new SequenceInputStream(f1,f2);

		 try(f1; f2; s)
		 {
         int i;
         while(true)
		 {
			  i = s.read();
			   if(i==-1)
				  break;
			  System.out.print((char)i);		 
		 }     
		 }
		 catch(IOException e)
		 {
			 e.printStackTrace();
		 }
     } 
}
----------------------------------------------------------------
//Reading the data from two files and writing the data to a single file
import java.io.*;
public class File5
{
	public static void main(String x[]) throws IOException
	{
		   var f1 = new FileInputStream("File3.java");
           var f2 = new FileInputStream("File4.java");

           var fout = new FileOutputStream("C:\\new\\FileData.txt");

           var s = new SequenceInputStream(f1,f2);

           int i;
		   try(f1; f2; fout; s)
		   {
           while(true)
           {
			   i = s.read();
			   if(i==-1)
				    break;
               System.out.print((char)i);
               fout.write((byte)i);
           }
		   }
		   catch(IOException e)
		   {
			   e.printStackTrace();
		   }
		   System.out.println("File Created Successfully");
     }
}
----------------------------------------------------------------
Limitation of FileOutputStream :
--------------------------------
By using this FileOutputStream class, we can write the data to single file only.
If we want to write the data to multiple files at the same time then we should use a separate stream called ByteArrayOutputStream.

ByteArrayOutputStream :-
---------------------------
It is a predefined class available in java.io package. By using this class we can write the data to multiple files. ByteArrayOutputStream class provides a method called writeTo(), through which we can write the data to multiple files.

//Program to write the data on multiple files.
import java.io.*;
public class File6
{
     public static void main(String args[]) throws IOException
     {
			var fin = new FileInputStream("File1.java");

			var f1 = new FileOutputStream("C:\\new\\a1.txt");  
			var f2 = new FileOutputStream("C:\\new\\b1.txt");
			var f3 = new FileOutputStream("C:\\new\\c1.txt"); 
			
			var bout = new ByteArrayOutputStream(); 

			try(fin; f1; f2; f3; bout)
		    {
             int i;
			while((i = fin.read()) != -1)
            {
               bout.write((byte)i); //writing tha data to ByteArrayOutputStream
            }

           bout.writeTo(f1);
           bout.writeTo(f2);
		   bout.writeTo(f3);
		   
           bout.flush();  //clear the buffer for reusing of ByteArrayOutputStream
           System.out.println("Success");
			}
			catch(IOException e)
		    {
				e.printStackTrace();
		    }
     }
}
---------------------------------------------------------------
//Working with images
import java.io.*;
public class File7 
{
	public static void main(String[] args) throws IOException
	{
		 var fin = new FileInputStream("C:\\new\\Batch28\\Image.jpg");

         var f1 = new FileOutputStream("C:\\new\\Batch28\\a1.jpg");
         var f2 = new FileOutputStream("C:\\new\\Batch28\\a2.jpg");
		 var f3 = new FileOutputStream("C:\\new\\Batch28\\a3.jpg");

         var bout = new ByteArrayOutputStream();

         try(fin; f1; f2; f3; bout)
		 {
         int i;
         while((i = fin.read()) != -1)
         {
               bout.write((byte)i);
         }
         bout.writeTo(f1);
         bout.writeTo(f2);
		 bout.writeTo(f3);
         System.out.println("success...");
		 bout.flush();
         }
		 catch(IOException e)
		{
			 e.printStackTrace();
		}
	}
}
------------------------------------------------------------------
BufferedOutputStream :-
--------------------------
It is a predefined class available in java.io package.

Whenever we use the class FileOutputStream the data will be available on the Stream but not in the buffer so there may be chance of miss memory management, It is always preferable that the data should be available in the buffer.

By using this BufferedOutputStrean now the data is in the buffer so the execution will become more faster.

//Program to put the data in the buffer for fast execution
import java.io.*;
class File8
{
      public static void main(String args[]) throws IOException
      {
        var fout = new FileOutputStream("C:\\new\\Hyderabad.txt");

           var bout = new BufferedOutputStream(fout);
          
		   try(fout ; bout)
		   {
           String s = "Hyderabad is a nice city";
           byte b[] = s.getBytes();
           bout.write(b);
		   System.out.print("success..."); 
		  }
		  catch(IOException e)
		  {
			  e.printStackTrace();
		  }
      }
}
------------------------------------------------------------------
BufferedInputStream :-
-------------------------
It is a predefined class available in java.io package. Whenever we use FileInputStream to read the data/content from the file the data will be available on the Stream but not in the buffer so there may be a chance of miss memory management so we should take the data into the buffer by using BufferedInputStream class so overall the execution will become faster.

//BufferedInputStream
import java.io.*;
public class File9
{
      public static void main(String args[]) throws IOException
      {
           var fin = new FileInputStream("File1.java");
           var bin = new BufferedInputStream(fin);

		   try(fin ; bin)
		   {
           int i;
           while((i = bin.read()) != -1)
           {
                System.out.print((char)i); 
           }
           }
		   catch(IOException e)
		  {
			   e.printStackTrace();
		  }
		  System.out.println();
      }
}
------------------------------------------------------------------
21-03-2024
-----------
Writing and Reading the primitive data to the files :-  
----------------------------------------------------------
It is possible to write the primitive data(byte,short,int, long, float, double, char and boolean) to the file. 

In order to write primitive data to the file we should use a predefined class available in java.io package called DataOutputStream. 

var fos = new FileOutputStream("data.txt");
var dos = new DataOutputStream(fos);

now by using this dos we can write primitive data to the file.

It provides various methods like writeByte(), writeShort(), writeInt() and so on to write the data to the file.

If we want to read the primitive data from the file we can use a predefined class available in java.io package called DataInputStream, this class provides various methods like readByte(), readShort(), readInt() and so on.

var fin = new FileInputStream("data.txt");
var dis = new DataInputStream(fin);

Note :- For writing String into a file we have writeBytes() and to read the String data from the file we have readLine() method.

[DataInputStream class readLine() method is deprecated now, so compilation warning]
----------------------------------------------------------------
//DataOutputStream and DataInputStream
import java.io.*;
public class File10
{
      public static void main(String args[]) throws IOException
      {
		  var fout = new FileOutputStream("C:\\new\\Primitive.txt");
          var dout = new DataOutputStream(fout);

		  try(fout ; dout)
		  {
          dout.writeBoolean(true);
          dout.writeChar('A');
          dout.writeByte(Byte.MAX_VALUE);
          dout.writeShort(Short.MAX_VALUE);
          dout.writeInt(Integer.MAX_VALUE); 
          dout.writeLong(Long.MAX_VALUE);
          dout.writeFloat(Float.MAX_VALUE); 
          dout.writeDouble(Math.PI);//PI is a final static variable
		  dout.writeBytes("Hello India...");
          dout.flush();//For reuse purpose
          }
		  catch(IOException e)
		  {
			  e.printStackTrace();
		  }

		  System.out.println("Reading the Primitive data from the file!!!");
          
		  var fin = new FileInputStream("C:\\new\\Primitive.txt");
          var din = new DataInputStream(fin);
		  try(fin ; din)
		  {
          boolean f = din.readBoolean();
          char c = din.readChar();
          byte b = din.readByte();
          short s = din.readShort();
          int i = din.readInt();
          long l = din.readLong();
          float ft = din.readFloat();
          double d = din.readDouble();
		   String x=  din.readLine();//for reading String (deprecated)

          System.out.println(f +"\n"+c+"\n"+b+"\n"+s+"\n"+i+"\n"+l+"\n"+ft+"\n"+d+"\n"+x);
		  }
		  catch(IOException e)
		  {
			  e.printStackTrace();
		  }

      }
}
---------------------------------------------------------------
** Serialization and De-serialization :
---------------------------------------
It is a technique through which we can store the object data in a file. Storing the object data into a file is called Serialization on the other hand Reading the object data from a file is called De-serialization.

In order to perform serialization, a class must implements Serializable interfcae, predefined marker interface in java.io package.

Java.io package has also provided a predfined class called ObjectOutputStream to perform serialization i.e writing Object data to a file using writeObject() method.

where as ObjectInputStream is also a predefined class available in java.io package through which we can read the Object data from a file using readObject(). The return type of readObject() is Object.

While reading the object data from the file, if the object is not available in the file then it will throw an execption java.io.EOFException. (End of file Exception)

3 files :
---------
Employee.java(R)
-----------------
package com.ravi.serialization_demo;

import java.io.Serializable;
import java.util.Scanner;

public record Employee(int id, String name, double salary) implements Serializable
{
	
	public static Employee getEmployeeObject()
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter Employee Id :");
		int id = sc.nextInt();
		System.out.print("Enter Employee Name :");
		String name = sc.nextLine();
		name = sc.nextLine();
		System.out.print("Enter Employee Salary :");
		double salary = sc.nextDouble();
		
		return new Employee(id, name, salary);
	}

}

Serialization.java
------------------
package com.ravi.serialization_demo;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.util.InputMismatchException;
import java.util.Scanner;

public class Serialization 
{
  public static void main(String[] args) throws IOException
  {
	var fos = new FileOutputStream("C:\\new\\Emp.txt");
	var oos = new ObjectOutputStream(fos);
	
	Scanner sc = new Scanner(System.in);
	
	try(sc; oos; fos)
	{
		System.out.print("How many objects you want to write ?");
		int noOfObjects = sc.nextInt();
		
		for(int i=1; i<=noOfObjects; i++)
		{
			Employee obj = Employee.getEmployeeObject();
			oos.writeObject(obj);
		}
	}
	catch(InputMismatchException e)
	{
		e.printStackTrace();
	}
	catch(Exception e)
	{
		e.printStackTrace();
	}
	
	System.out.println("Object data stored in a file");
  }
}

De-Serialization
-----------------
package com.ravi.serialization_demo;

import java.io.EOFException;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;

public class DeSerialization 
{
	public static void main(String[] args) throws IOException, ClassNotFoundException 
	{
	    var fin = new 	FileInputStream("C:\\new\\Emp.txt");
	    var ois = new ObjectInputStream(fin);
	    
	    try(fin;ois)
	    {
	    	
	    Employee e1 = null;
	    
	    while((e1 = (Employee)ois.readObject())!=null)
	    {
	    	System.out.println(e1);
	    }
	    }
	    catch(EOFException e)
	    {
	    	System.err.println("File ended :"+e);
	    }

	}

}
---------------------------------------------------------------
22-03-2024
----------
transient keyword :
-------------------
If we want that some of our field (variable) will not serialized then we should declare that variables with transient keyword so, we will get the defualt value for the variables.

public class Player
{
   private transient int playerId;
   private transient String playerName;
}

Now if we perform serialization operation on Player object then for playerId we will get 0 and for playerName we will get null.
--------------------------------------------------------------
3 files :
---------
Product.java
------------
package com.ravi.serialization_ex;

import java.io.Serializable;
import java.time.LocalDate;
import java.util.Scanner;

//BLC
public class Product implements Serializable
{
	private transient int productId;
	private transient String productName;
	private double productPrice;
	private LocalDate manufactureDate;

	public Product(int productId, String productName, double productPrice, LocalDate manufactureDate) {
		super();
		this.productId = productId;
		this.productName = productName;
		this.productPrice = productPrice;
		this.manufactureDate = manufactureDate;
	}
	
	public static Product getProductObject()
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter Product Id :");
		int id = sc.nextInt();
		System.out.print("Enter Product Name :");
		String name = sc.nextLine();
		name = sc.nextLine();
		System.out.print("Enter Product Price :");
		double price = sc.nextDouble();
		LocalDate d = LocalDate.now();
		return new Product(id, name, price, d);
	}

	@Override
	public String toString() {
		return "Product [productId=" + productId + ", productName=" + productName + ", productPrice=" + productPrice
				+ ", manufactureDate=" + manufactureDate + "]";
	}
	
	

}

StoringProductObject.java
--------------------------

package com.ravi.serialization_ex;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.util.Scanner;

//ELC
public class StoringProductObject 
{
	public static void main(String[] args) throws IOException
	{
	  var fos = new FileOutputStream("C:\\new\\Product.txt");
	  var oos = new ObjectOutputStream(fos);
	  Scanner sc = new Scanner(System.in);
	  
	  try(fos; oos; sc)
	  {		 
		 System.out.println("How many objects :");
		 int objects = sc.nextInt();
		 
		 for(int i=1; i<=objects; i++)
		 {
			 Product product = Product.getProductObject();
			 oos.writeObject(product);
		 }
		 
		 
	  }
	  catch(Exception e)
	  {
		 e.printStackTrace(); 
	  }
       System.out.println("Product Data stored...");
	}

}

RetrievingProductObject.java
----------------------------
package com.ravi.serialization_ex;

import java.io.FileInputStream;
import java.io.ObjectInputStream;

//ELC
public class RetrievingProductObject 
{
	public static void main(String[] args) throws Exception 
	{
	   var fin = new FileInputStream("C:\\new\\Product.txt");	
	   var ois = new ObjectInputStream(fin);
	   
	   try(fin;ois)
	   {
		  Product p = null;
		  while((p = (Product)ois.readObject())!=null)
		  {
			 System.out.println(p); 
		  }		      
	   }
	   catch(Exception e)
	   {
		   System.err.println("End if file reached");
	   }
	}
}
---------------------------------------------------------------
Working With Character Oriented Stream :
----------------------------------------
In order to work with character oriented Stream, if we two super classes Reader and Writer.

Both are abstract classes and Reader is the super class for all types of reading operation, on the other hand Writer is the super class for all types of writing operation.

Here we can directly work with characters.

FileWriter class :
------------------
It is a predefined class available in java.io package,By using this class we can create a file and write character data to the file. 

By using this class we can directly write String (collection of characters) Or character array to the file.

Actually It is a character oriented Stream where as if we work with FileOutputStream class, It is byte oriented Stream.
----------------------------------------------------------------
//FileWriter
import java.io.*;
public class File11
{
    public static void main(String args[]) throws IOException
    {
         var fw = new FileWriter("C:\\Batch28\\HelloIndia.txt");
		 var bw = new  BufferedWriter(fw);

		 try(fw; bw)
		 {
         bw.write("India, It is in Asia");
         System.out.println("Success....");
		 }
		 catch(IOException e)
		  {
			  e.printStackTrace();
		  }
    }
}
---------------------------------------------------------------
//FileWriter
import java.io.*;
class File12
{
    public static void main(String args[]) throws IOException
    {
		var fw = new FileWriter("C:\\Batch28\\Data.txt");
		var bw = new  BufferedWriter(fw);

        try(fw;bw)
		{        
		 char c[ ] =  {'H','E','L','L','O', ' ',' ','W','O','R','L','D'};
		 
         bw.write(c);
         System.out.println("Success....");
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}
    }
}
----------------------------------------------------------------
FileReader class :
--------------------
It is a predefined class available in java.io package, It is a character oriented Stream. The main purpose of this class to read the data in the character format directly from the file.
--------------------------------------------------------------
//FileReader
import java.io.*;
public class File13
{
    public static void main(String args[]) throws IOException
    {
         var fr = new FileReader(args[0]); //Command Line Arg
		 var br = new BufferedReader(fr);

		 try(fr ; br)
		 {
         while(true)
         {
              int i = br.read();
              if(i == -1)
                   break;
              System.out.print((char)i);
         }
		 }
		 catch(IOException e)
		 {
			  e.printStackTrace();
		 }         
    }
}
---------------------------------------------------------------
import java.io.*;
public class File14
{
  public static void main(String[] args) throws IOException
	{
       var fr = new FileReader("C:\\Batch28\\Image.jpg");
	   var  fw = new FileWriter("C:\\Batch28\\xyz.jpg");
	   
		try(fr;fw)
		{
		     int i;
		    while((i=fr.read())!= -1)
			{
				fw.write(i);
			}
		}
		catch(Exception e)
		{
		}
		System.out.println("Success");
    }
}


Note :- In the above program the image file will not be created in a proper format because images are created by using binary data but FileReader and FileWriter can work with Character data.
----------------------------------------------------------------
//PrintWriter 
import java.io.*;
public class File15
{
  public static void main(String[] args) throws IOException
	{
	  PrintWriter writeData = new PrintWriter("C:\\Batch28\\Roll.txt");

     try(writeData)
	 {      
      int roll = 15;
      //Writing primitive data into text format
      writeData.printf("My roll number is : %d ", roll);    
    }
    catch(Exception e) 
	{
      e.printStackTrace();
    }
  }
}
--------------------------------------------------------------
import java.util.*;
public class Test 
{
	final static int x;

    static
	{  
        m1();
      x = 10;  
    } 
    
    public static void m1() 
    {
        System.out.println(x);
    }
    public static void main(String[] args) {
        Test h = new Test();
        
    }
}

---------------------------------------------------------------
23-03-2024
----------
Multithreading :
----------------
Uniprocessing :- 
----------------
In uniprocessing, only one process can occupy the memory So the
major drawbacks are 

1) Memory is westage
2) Resources are westage
3) Cpu is idle

To avoid the above said problem, multitasking is introduced.

In multitasking multiple task can concurrently work with CPU so, our task will be completed as soon as possible.

Multitasking is further divided into two categories.

a) Process based Multitasking
b) Thread based Multitasking


Process based Multitasking :
----------------------------
If a CPU is switching from one subtask(Thread) of one process to 
another subtask of another process then it is called Process based Multitasking.

Thread based Multitasking :
---------------------------
If a CPU is switching from one subtask(Thread) to another subtask within the same process then it is called Thread based Multitasking.
----------------------------------------------------------------
Thread :-
----------
A thread is light weight process and it is the basic unit of CPU which can run concurrently with another thread within the same context (process).

It is well known for independent execution. The main purpose of multithreading to boost the execution sequence.

A thread can run with another thread at the same time so our task will be completed as soon as possible.

In java whenever we define main method then JVM internally creates a thread called main thread.
---------------------------------------------------------------
26-03-2024
----------
Program that describes that main is a Thread :
-----------------------------------------------
Whenever we define main method then JVM will create main thread internally, the purpose of this main thread to execute the entire main method.

In java there is a predefined class called Thread available in java.lang package, this class contains a predefined static method currentThread() which will provide currently executing Thread.

Thread t = Thread.currentThread(); //Factory Method

Thread class has provided predefined method getName() to get the name of the Thread.

Program 
-------
public class Test 
{	
    public static void main(String[] args) 
	{
        Thread t = Thread.currentThread();
		System.out.println(t.getName()); 
                  //OR
		String name = Thread.currentThread().getName();
		System.out.println("Currently running Thread name is :"+name);

    }
}
---------------------------------------------------------------
How to create a userdefined Thread in java ?
---------------------------------------------
As we know whenever we define the main method then JVM internally creates a thread called main thread.

The purpose of main thread to execute the entire main method so at the time of execution of main method a user can create our own userdefined thread.

In order to create the userdefined Thread we can use one of the following two ways :-

1) By extending java.lang.Thread class
2) By implementing java.lang.Runnable interface

Note :- Thread is a predefined class available in java.lang package where as Runnable is a predefined interface available in java.lang Package.
----------------------------------------------------------------
Creating a user-defined Thread by extending Thread class :
----------------------------------------------------------
public synchronized void start() :
-----------------------------------
start() is a predefined method of Thread class and this method internally performs two tasks

1) It makes a request to opearting system to assign a new thread to perform concurrent execution.

2) It internally invokes the run() method as a part a separate Stack.

Note :- For every individual thread, JVM creates a separate runtime stack.

The following program explains how to create a userdefined Thread by extending Thread approach.
-----------------------------------------------------------------
package com.ravi.thread;

class MyThread extends Thread
{
	@Override
	public void run()
	{
		System.out.println("Child Thread is running!!!");
	}
}

public class UserThread
{
	public static void main(String[] args) 
	{
	  System.out.println("Main thread started!!!");	
	  MyThread mt = new MyThread();
	  mt.start();
	  System.out.println("Main Thread ended!!!");
	}
}

In the above program main thread and Thread-0 threads are created both threads are executing their own Stack Memory as shown in the diagram
(26-MAR-24)
---------------------------------------------------------------
public boolean isAlive() :-
-----------------------------
It is a predefined method of Thread class through which we can find out whether a thread has started or not ?

As we know a new thread is created after calling start() method so if we use isAlive() method before start() method, it will return false but if the same isAlive() method if we invoke after the start() method, it will return true.

We can't restart a thread in java if we try to restart then It will generate an exception i.e java.lang.IllegalThreadStateException
-----------------------------------------------------------------
package com.ravi.basic;

class Foo extends Thread
{
	@Override
	public void run()
	{
		System.out.println("Child thread is running...");
		System.out.println("It is running with separate stack");		
	}	
}
public class IsAlive 
{
	public static void main(String[] args)
	{
		System.out.println("Main Thread is started..");			
		Foo f = new Foo(); 		
        System.out.println("Thread has not started yet so :"+f.isAlive());	
		
		f.start(); //new Thread has created	
		
		System.out.println("Thread has started  so :"+f.isAlive());
	    f.start();   //java.lang.IllegalThreadStateException	
	 
    }
}
---------------------------------------------------------------
27-03-2024
----------
package com.ravi.basic;

class Stuff extends Thread
{
	@Override
	public void run() 
	{		
		System.out.println("Child Thread is Running!!!!");
	}	
}
public class ExceptionDemo 
{
	public static void main(String[] args) 
	{		
		System.out.println("Main Thread Started");		
		
		Stuff s1 = new Stuff(); 
		Stuff s2 = new Stuff(); 
		
		
		s1.start();
		s2.start();
		
		System.out.println(10/0);
		
		System.out.println("Main Thread Ended");
	}

}
Note :- Here main thread is interrupted due to AE but still child thread will be executed because child thread is executing with separate Stack
---------------------------------------------------------------
package com.ravi.basic;

class Sample extends Thread
{
	@Override
	public void run()
	{
		String name = Thread.currentThread().getName();
		for(int i=1; i<=10; i++)
		{
		   System.out.println(i+" by "+name+ " thread");
		}
	}
}
public class ThreadLoop 
{	
	public static void main(String[] args) 
	{
	   System.out.println("Main Thread Started!!!");
	   
	   Sample s1 = new Sample();  s1.start();
	   
	   
	   String name = Thread.currentThread().getName();
	   
	   for(int i=1; i<=10; i++)
	   {
		   System.out.println(i+" by "+name+ " thread");
	   }
	   
	   int x = 1;
	   do
	   {
		   System.out.println("India");
		   x++;
	   }
	   while(x<=10);
	   
	   
	}
}

Note :- From the above program, It is clear that CPU can frequently move from one thread to another thread. (Main thread to child thread-> Thread-0 thread)
---------------------------------------------------------------
How to set and get the name of the Thread : 
--------------------------------------------------
Whenever we create a userdefined Thread in java then by default JVM assigns the name of thread is Thread-0, Thread-1, Thread-2 and so on.

If a user wants to assign some user defined name of the Thread, then Thread class has provided a predefined method called setName(String name) to set the name of the Thread.

On the other hand we want to get the name of the Thread then Thread class has provided a predefined method called getName().

public void setName(String name)  //setter

public String getName()  //getter
---------------------------------------------------------------
package com.ravi.basic;
class Test extends Thread
{
	@Override
	public void run()
	{
		String name = Thread.currentThread().getName();
		System.out.println(name +" thread is running Here!!!!");
	}
}
public class ThreadName 
{
	public static void main(String[] args) 
	{
		Test t1 = new Test(); 
		Test t2 = new Test(); 
		
		t1.start();			
		t2.start();	
		
	System.out.println(Thread.currentThread().getName()+" thread is running.....");
	}
}

Note :- If we don't provide our user-defined name for the thread then by default the name would be Thread-0, Thread-1 and so on.
---------------------------------------------------------------
package com.ravi.basic;
class Demo extends Thread
{
	@Override
	public void run()
	{
		System.out.println(Thread.currentThread().getName()+" thread is running.....");	
	}
}
public class ThreadName1 
{
	public static void main(String[] args) 
	{
	  Thread t =  Thread.currentThread();
	  t.setName("Parent"); //Changing the name of the main thread
	  
	   Demo d1 = new Demo();
	   Demo d2 = new Demo();
	   
	   d1.setName("Child1");
	   d2.setName("Child2");
	   
	   d1.start();  d2.start();
	   
	   String name = Thread.currentThread().getName();
	   System.out.println(name + " Thread is running..");
	}
}
In the above program we are setting the name of the Thread.
---------------------------------------------------------------
Thread.sleep(long millisecond) :
-------------------------------
If we want to put a thread into temporarly waiting state then we should use sleep() method.

The waiting time of the Thread depends upon the time specified by the user in millisecond as parameter to sleep() method.

Thread.sleep(1000); //Thread will wait for 1 second

It is a static method of Thread class.

It is throwing a checked Exception i.e InterruptedException because there may be chance that this sleeping thread may be interrupted by some another thread.
--------------------------------------------------------------
package com.ravi.basic;

class Sleep extends Thread
{
   @Override
   public void run() 
   {
	   for(int i=1; i<=10; i++)
	   {
		   System.out.println("i value is :"+i);
		   try
		   {
			   Thread.sleep(1000);
		   }
		   catch(InterruptedException e)
		   {
			   System.err.println("Thread is Interrupted "+e);
		   }
	   }
   }
}
public class SleepDemo 
{
	public static void main(String[] args) 
	{
		Sleep s = new Sleep();
		s.start();
			
	}
}

Note :- Catch block will not be executed because no other thraed is interrupting the sleeping thread.
---------------------------------------------------------------
package com.ravi.basic;

class MyTest extends Thread 
{	
	
	@Override
	public void run() 
	{		
		for (int i = 1; i <= 5; i++) 
		{			      
			  try 
			  {				  
				  Thread.sleep(1000); //child1
			  }
			  catch(Exception e) 
			  {
			   System.err.println("thread has interrupted"); 
			  }
			 	
			System.out.println(i + " by " + Thread.currentThread().getName());
		}
	}
}
public class SleepDemo1 
{
	public static void main(String[] args) 
	{
		System.out.println(Thread.currentThread().getName() + " thread");

		MyTest t1 = new MyTest();
		MyTest t2 = new MyTest();

		t1.setName("Child1");
		t2.setName("Child2");
		
		t1.start();
		t2.start();	
		
	}
}

Assignment :
-------------
WAP to implement sleep(long millis, long nanos) methos which is accepting two parameters.
---------------------------------------------------------------
28-03-2024
-----------
Thread life cycle in java :
-----------------------------
As we know a thread is well known for Independent execution and it contains a life cycle which internally contains 5 states (Phases). 

During the life cycle of a thread, It can pass from thses 5 states. At a time a thread can reside to only one state of the given 5 states.

1) NEW State (Born state)

2) RUNNABLE state (Ready to Run state) [Thread Pool]

3) RUNNING state

4) WAITING / BLOCKED state

5) EXIT/Dead state


New State :-
-------------
Whenever we create a thread instance(Thread Object) a thread comes to new state OR born state. New state does not mean that the Thread has started yet only the object or instance of Thread has been created.

Runnable state :-
-------------------
Whenever we call start() method on thread object, A thread moves to Runnable state i.e Ready to run state. Here Thread schedular is responsible to select/pick a particular Thread from Runnable state and sending that particular thread to Running state for execution.

Running state :-
-----------------
If a thread is in Running state that means the thread is executing its own run() method. 

From Running state a thread can move to waiting state either by an order of thread schedular or user has written some method(wait(), join() or sleep()) to put the thread into temporarly waiting state.

From Running state the Thread may also move to Runnable state directly, if user has written Thread.yield() method explicitly.

Waiting state :-
------------------
A thread is in waiting state means it is waiting for it's time period to complete. Once the time period will be completed then it will re-enter inside the Runnable state to complete its remaining task.

Dead or Exit :
----------------
Once a thread has successfully completed its run method then the thread will move to dead state. Please remember once a thread is dead we can't restart a thread in java.

IQ :- If we write Thread.sleep(1000) then exactly after 1 sec the Thread will re-start?

Ans :- No, We can't say that the Thread will directly move from waiting state to Running state. 

The Thread will definetly wait for 1 sec in the waiting mode and then again it will re-enter into Runnable state which is control by Thread Schedular so we can't say that the Thread will re-start just after 1 sec.
---------------------------------------------------------------
join() method of Thread class :
------------------------------------
The main purpose of join() method to put the one thread into waiting mode until the other thread finish its execution.

Here the currently executing thread stops its execution and the thread goes into the waiting state. The current thread remains in the wait state until the thread on which the join() method is invoked has achieved its dead state.

It also throws checked exception i.e InterruptedException so better to use try catch or declare the method as throws.

It is an instance method so we can call this method with the help of Thread object reference.
---------------------------------------------------------------
package com.ravi.basic;

class Join extends Thread
{
	@Override
	public void run()
	{
		for(int i=1; i<=5; i++)
		{
			try
			{
				Thread.sleep(1000);
			}
			catch(Exception e)
			{
				e.printStackTrace();
			}
			System.out.println("i value is :"+i);
		}
	}
}


public class JoinDemo 
{
	public static void main(String[] args) throws InterruptedException 
	{
       System.out.println("Main thread started....");
       
       Join j1 = new Join();
       Join j2 = new Join();
       Join j3 = new Join();
       
       j1.start();      
             
       j1.join();
       
       j2.start();
             
       j3.start();    
      
      
       System.out.println("Main thread ended....");	
	}

}
--------------------------------------------------------------
package com.ravi.basic;

public class JoinDemo1 
{
	public static void main(String[] args) throws InterruptedException 
	{
		System.out.println("Main thread started");
		Thread thread = Thread.currentThread();
		String name = thread.getName();
		
		for(int i=1; i<=5; i++)
		{			
			System.out.println(i + " by "+name+ " thread ");
			Thread.sleep(1000);			
		}
		thread.join();  //Deadlock
	
		
		System.out.println("Main thread ended");

	}

}

Here, It is a deadlock state because main thread is waiting for main thread to complete.
---------------------------------------------------------------
package com.ravi.basic;

class Alpha extends Thread
{
	@Override
	public void run()
	{
		Thread t = Thread.currentThread();
		String name = t.getName();	//Alpha_Thread		
		
		Beta b1 = new Beta();
		b1.setName("Beta_Thread");
        b1.start();  
        try 
        {
			b1.join(); //Alpha thread is Blocked
			System.out.println("--------------------");
		} 
        catch (InterruptedException e) 
        {			
			e.printStackTrace();
		}
		
		for(int i=1; i<=10; i++)
		{
			System.out.println(i+" by "+name);
		}
		
	}
}

public class JoinDemo2 
{
	public static void main(String[] args) 
	{
		Alpha a1 = new Alpha();
		a1.setName("Alpha_Thread");
		a1.start();
	}
}

class Beta extends Thread
{
	@Override
	public void run()
	{
		Thread t = Thread.currentThread();
		String name = t.getName();	
		for(int i=1; i<=20; i++)
		{
			System.out.println(i+" by "+name);
		}
		System.out.println(".............");
	}
}

Assignment :
-------------
WAP to implement join(long millis) method.
---------------------------------------------------------------
Creating Thread by implements Runnable approach :
--------------------------------------------------
package com.ravi.basic;

class Run implements Runnable
{
	@Override
	public void run() 
	{
		System.out.println("Thread is running");		
	}	
}

public class RunnableDemo 
{
	public static void main(String[] args) 
	{
	   System.out.println("Main Thread started");
	   
	   Thread t1 = new Thread(new Run()); 
	   t1.start();	 
		
	}
}
------------------------------------------------------------------
29-03-2024
-----------
Program to assign different targets by using different threads :
----------------------------------------------------------------
package com.ravi.thread;

class UserThread implements Runnable
{
	@Override
	public void run() 
	{
		Thread t = Thread.currentThread();
		System.out.println(t.getName());
		System.out.println(t.getId());
	}	
}

public class RunnableDemo 
{
	public static void main(String[] args) 
	{
		Thread t = Thread.currentThread();
		System.out.println(t.getName());
		System.out.println(t.getId());
		
		Thread tn = new Thread(new UserThread(),"Child1");
		
		tn.start();
		
				
		Thread t1 = new Thread(new Ravi(),"Ravi");
		t1.start();

		Thread t2 = new Thread(new Rahul(),"Rahul");
		t2.start();
	}

}

class Ravi implements Runnable
{

	@Override
	public void run() 
	{
		Thread t = Thread.currentThread();
		System.out.println(t.getName());
		System.out.println(t.getId());
		
	}
	
}

class Rahul implements Runnable
{
	@Override
	public void run() 
	{
		Thread t = Thread.currentThread();
		System.out.println(t.getName());
		System.out.println(t.getId());
		
	}
	
}

public long getId() :- It will a unique positive integer id for each and every thread, it is used to identify the thread during the life cycle of the Thread.
------------------------------------------------------------------
Working with Anonymous Approach :
----------------------------------
Case 1: Creating Anonymous Thread class using reference :
----------------------------------------------------------
package com.ravi.thread;

public class AnonymousThreadWithRef 
{
	public static void main(String[] args) 
	{
		//Anonymous inner class
		Thread t1 = new Thread()
		{
			@Override
			public void run()
			{
				Thread t = Thread.currentThread();
				System.out.println(t.getName());
				System.out.println(t.getId());
			}
		};
        t1.start();
	}

}
----------------------------------------------------------------
Case 2: Creating Anonymous Thread class without reference :
----------------------------------------------------------
package com.ravi.thread;

public class AnonymousThreadWithoutRef {

	public static void main(String[] args) 
	{
	   new Thread()
	   {
		   @Override
			public void run()
			{
				Thread t = Thread.currentThread();
				System.out.println(t.getName());
				System.out.println(t.getId());
			}  
	   }.start();

	}

}
-----------------------------------------------------------------
Case 3 : Creating Thread with Anonymous approach using Runnable

package com.ravi.thread;

public class AnonymousRunnable {

	public static void main(String[] args) 
	{
		Runnable r1 = new Runnable()
		{
			@Override
			public void run()
			{
				Thread t = Thread.currentThread();
				System.out.println(t.getName());
				System.out.println(t.getId());
			}  
	   };
	    Thread t1 = new Thread(r1);
	    t1.start();
		

	}

}
-----------------------------------------------------------------
Case 4 :- Runnable by using Lambda

package com.ravi.thread;

public class RunnableUsingLambda {

	public static void main(String[] args)
	{
		Runnable r1 = () ->
		{
			Thread t = Thread.currentThread();
			System.out.println(t.getName());
			System.out.println(t.getId());
		};			
				
	    Thread t1 = new Thread(r1);
	    t1.start();

	}

}
-----------------------------------------------------------------
Case 5 : Writing Lambda in the Constructor of Thread.

package com.ravi.thread;

public class ThreadWithLambda {

	public static void main(String[] args) throws InterruptedException
	{
	new Thread(()-> 
	{
		for(int i=1; i<=100; i=i+2)
		{
		String name = Thread.currentThread().getName();
			System.out.println(i+" by "+name);
		}

	},"Thread1").start();
	
	Thread.sleep(1000);
	System.out.println("............");
	new Thread(()-> 
	{
		for(int i=2; i<=100; i=i+2)
		{
		String name = Thread.currentThread().getName();
			System.out.println(i+" by "+name);
		}	

	},"Thread2").start();
  }
}
-----------------------------------------------------------------
IQ :
----
In between extends Thread and implements Runnable which one is 
better and why ?

*In between extends Thread and implements Runnable, which one is better and why?

In between extends Thread and implements Runnable approach, implements Runnable is more better due to the following reasons

*1) When we use extends Thread, all the methods and properties of Thread class is available to sub class so it is heavy weight but this is not the case while implementing Runnable interface.

2) As we know Java does not support multiple inheritance using classes so in the extends Thread approach we can't extend another class but if we use implments Runnable interface still we have chance to extend another class(Only one class) and we can also implement one or more interfaces.

3) implements Runnable is a better approach to create multiple threads on a single sub class object.

*4) We can implement Lambda for Runnable interface (Functional interface) only but not for Thread class.
-----------------------------------------------------------------
30-03-2024
-----------
Thread class Constructor :
--------------------------
In Thread class we have total 9 constructors are available but 
commonly we are using the following 7 constructors 

1) Thread t1 = new Thread();

2) Thread t2 = new Thread(String name);

3) Thread t3 = new Thread(Runnable target);

4) Thread t4 = new Thread(Runnable target, String name);

5) Thread t5 = new Thread(ThreadGroup tg, String name);

6) Thread t6 = new Thread(ThreadGroup tg, Runnable target);

7) Thread t7 = new Thread(ThreadGroup tg, Runnable target, String name);
----------------------------------------------------------------
Problem with multithreading :-
----------------------------------
Multithreading is very good to complete our task as soon as possible but in some situation, It provides some wrong data or wrong result.

In Data Race or Race condition, all the threads try to access the resource at the same time so the result will be corrupted.

In multithreading if we want to perform read operation and data is not updatable then multithreading is good but if the data is updatable data (modifiable data) then multithreading may produce some wrong result or wrong data as shown in the diagram.(30-MAR-24)
----------------------------------------------------------------
package com.ravi.data_race;

class Customer
{
	 double balance = 20000;
	 double withdraw;
	
	public Customer(double withdraw) 
	{
		super();
		this.withdraw = withdraw;
	}

	
}

public class BankingApplication 
{
	public static void main(String[] args) 
	{
		Customer cust = new Customer(20000);
		
		Runnable r1 = () ->
		{
			String name = null;
			
			if(cust.withdraw <= cust.balance)
			{
				name = Thread.currentThread().getName();
				System.out.println(cust.withdraw+" amount withdraw successfully by :"+name);
				cust.balance = cust.balance - cust.withdraw;
				
			}
			else
			{
				name = Thread.currentThread().getName();
				System.err.println("Sorry !"+name+ " you have insufficient balance");
			}
			
		};
		
		Thread t1 = new Thread(r1, "Virat");
		Thread t2 = new Thread(r1, "Dhoni");
		
		t1.start();  t2.start();
		
		
		
	}

}

Note :- In the above program both the threads Virat and Dhoni are accessing the balace to withdraw 20000 amount so it may produce some wrong result or wrong data.
-----------------------------------------------------------------
01-04-2024
-----------
Program that describes two threads will book the ticket so, multirthreading is not good in all the situations.

package com.ravi.thread_demo;

class Customer implements Runnable
{
    private int availableSeat = 1;
    private int wantedSeat;
    
    public Customer(int wantedSeat)
    {
    	this.wantedSeat = wantedSeat;
    }
    
	@Override
	public void run() 
	{
		String name = null;
	    
		//t1   t2
		
		if(availableSeat >= wantedSeat)
		{
			name = Thread.currentThread().getName();
			System.out.println(wantedSeat + " seat booked for :"+name);
			availableSeat = availableSeat - wantedSeat;
		}
		else
		{
			name = Thread.currentThread().getName();
			System.err.println("Sorry "+name+" seat is not available");
		}			
	}	
}

public class RailwayReservation {

	
	public static void main(String[] args) 
	{
		Customer c1 = new Customer(1);
		
		Thread t1 = new Thread(c1, "Person1");
		Thread t2 = new Thread(c1, "Person2");
		
		t1.start();  t2.start();
		
		

	}

}
----------------------------------------------------------------
package com.ravi.advanced;

class MyThread implements Runnable
{
	private String str;
	
	public MyThread(String str)
	{
		this.str=str;
	}	
	
	@Override
	public void run()
	{
		for(int i=1; i<=10; i++)
		{
			System.out.println(str+ " : "+i);
			try
			{
				Thread.sleep(100);
			}
			catch (Exception e)
			{
			System.err.println(e);
			}
		}
	}
}
public class Theatre
{
	public static void main(String [] args)
	{
		MyThread obj1 = new MyThread("sell the Ticket");  
		MyThread obj2 = new MyThread("Allocate the Seat"); 

		Thread t1 = new Thread(obj1);
		Thread t2 = new Thread(obj2);

		t1.start();
		t2.start();
	}
}
----------------------------------------------------------------
* Synchronization :
------------------
In order to solve the problem of multithreading java software people has introduced synchronization concept.

In order to acheive synchronization in java we have a keyword called "synchronized".

It is a technique through which we can control multiple threads but accepting only one thread at all the time.

Synchronization allows only one thread to enter inside the synchronized area for a single object.

Synchronization can be divided into two categories :-

1) Method level synchronization

2) Block level synchronization

1) Method level synchronization :-
-----------------------------------
In method level synchronization, the entire method gets synchronized so all the thread will wait at method level and only one thread will enter inside the synchronized area as shown in the diagram.(01-APR-24)
----------------------------------------------------------------
2) Block level synchronization
-------------------------------
In block level synchronization the entire method does not get synchronized, only the part of the method gets synchronized so all the thread will enter inside the method but only one thread will enter inside the synchronized block as shown in the diagram (01-APR-24) 

Note :- In between method level synchronization and block level synchronization, block level synchronization is more preferable because all the threads can enter inside the method so only the PART OF THE METHOD GETS synchronized so only one thread will enter inside the synchronized block.
-----------------------------------------------------------------
How synchronization logic controls multiple threads ?
------------------------------------------------------
Every Object has a lock(monitor) in java environment and this lock can be given to only one Thread at a time.

The thread who acquires the lock from the object will enter inside the synchronized area, it will complete its task without any disturbance because at a time there will be only one thread inside the synchronized area(for single Object). *This is known as Thread-safety in java.

The thread which is inside the synchronized area, after completion of its task while going back will release the lock so the other threads (which are waiting outside for the lock) will get a chance to enter inside the synchronized area by again taking the lock from the object and submitting it to the synchronization mechanism.
This is how synchronization mechanism controls multiple Threads.

Note :- Synchronization logic can be done by senior programmers in the real time industry because due to poor synchronization there may be chance of getting deadlock.
----------------------------------------------------------------
Program on Method Level Synchronization :
-----------------------------------------
package com.ravi.thread_demo;

class Table
{
	public synchronized void printTable(int num) 
	{
		for(int i=1; i<=10; i++)
		{
			System.out.println(num+" X "+i+" = "+(num*i));
			try 
			{
				Thread.sleep(1000);
			} 
			catch (InterruptedException e) 
			{
				e.printStackTrace();
			}
		}
		System.out.println("..............");
	}
}


public class MethodLevelSynchronization {

	public static void main(String[] args) 
	{
		
		Table obj = new Table();  //lock is created here
		
		
		new Thread()
		{
		  @Override
		  public void run()
		  {
			obj.printTable(5);	
		  }		
			
		}.start();
		
		
		new Thread()
		{
		  @Override
		  public void run()
		  {
			obj.printTable(10);	
		  }		
			
		}.start();

	}

}
----------------------------------------------------------------
02-04-2024
----------
Program on Block Level Synchronization :
----------------------------------------
package com.ravi.advanced;

//Block level synchronization

class ThreadName
{
	public void printThreadName()
	{		  		
	  String name = Thread.currentThread().getName();
	  System.out.println("Thread inside the method is :"+name);
			
		   synchronized(this)  //synchronized Block
		   {  			   
			for(int i=1; i<=9; i++)
			{
				System.out.println("i value is :"+i+" by :"+name);
			}
			System.out.println(".............................");
		   }		
	}
}
public class BlockSynchronization 
{
	public static void main(String[] args)
	{
		ThreadName obj1 = new ThreadName(); //lock is created	
		
		Runnable r1 = () -> obj1.printThreadName();
		
		Thread t1 = new Thread(r1,"Child1"); 
		Thread t2 = new Thread(r1,"Child2"); 
		t1.start(); t2.start();				
	}
}
--------------------------------------------------------------------
Problem with Object level synchronization :
-------------------------------------------
From the given diagram it is clear that there is no interference between t1 and t2 thread because they are passing throgh Object1 where as on the other hand there is no interferenec even in between t3 and t4 threads because they are also passing through Object2 (another object).

But there may be chance that with t1 Thread, t3 or t4 thread can enter inside the synchronized area at the same time, simillarly it is also possible that with t2 thread, t3 or t4 thread can enter inside the synchronized area so the conclusion is, synchronization mechanism does not work with multiple Objects.(Diagram 02-APR-24)
----------------------------------------------------------------
package com.ravi.advanced;
class PrintTable
{
	    public synchronized void printTable(int n)
	    {
	       for(int i=1; i<=10; i++)
	       {
	    	   System.out.println(n+" X "+i+" = "+(n*i));
	    	   try
	    	   {
	    		   Thread.sleep(500);
	    	   }
	    	   catch(Exception e)
	    	   {	    		   
	    	   }
	       }
	       System.out.println(".......................");
	    }	
}

public class ProblemWithObjectLevelSynchronization
{
	public static void main(String[] args) 
	{
		PrintTable pt1 = new PrintTable(); //lock1		
		PrintTable pt2 = new PrintTable(); //lock2
		
		Thread t1 = new Thread()  //Anonymous inner class concept
				{
			       @Override
			       public void run()
			       {
			    	   pt1.printTable(2);	//lock1
			       }			   
				};
		       	        
		        Thread t2 = new Thread()
				{
			       @Override
			       public void run()
			       {
			    	   pt1.printTable(3);	//lock1
			       }			   
				};
		                
		        Thread t3 = new Thread()
				{
			       @Override
			       public void run()
			       {
			    	   pt2.printTable(6);	//lock2
			       }			   
				};
		               
		        Thread t4 = new Thread()
				{
			       @Override
			       public void run()
			       {
			    	   pt2.printTable(9); //lock2
			       }			   
				};
				 t1.start();	t2.start();	 t3.start();  t4.start(); 
	}
}

So, from the above program it is clear that synchronization will not work with multiple objects.

Now, to avoid this Static Synchronization is came into the picture.
---------------------------------------------------------------
Static Synchronization :
------------------------
If We declare a synchronized method as a static method then it is called static synchronization.

Now with static synchronization lock will be available at class level but not Object level.

To call the static synchronized method, object is not required so we can call the static method with the help of class name.

Unlike objects we can't create multiple classes for the same application.
-----------------------------------------------------------------
package com.ravi.advanced;
class MyTable     
{
	 public static synchronized void printTable(int n)  //static synchronization
	    {
	       for(int i=1; i<=10; i++)
	       {
	    	   try
	    	   {
	    		   Thread.sleep(100);
	    	   }
	    	   catch(InterruptedException e)
	    	   {
	    		  System.err.println("Thread is Interrupted...");
	    	   }
	    	   System.out.println(n+" X "+i+" = "+(n*i));
	       }
	       System.out.println("------------------------");
	    }
}
public class StaticSynchronization 
{
	public static void main(String[] args)
	{
			        Thread t1 = new Thread()
					{
				      @Override
				      public void run()
				      {
				    	 MyTable.printTable(5); 
				      }
					};		
					
					Thread t2 = new Thread()
					{
				      @Override
				      public void run()
				      {
				    	  MyTable.printTable(10);
				      }
					};										

					Runnable r3 = new Runnable() 
					{						
						@Override
						public void run() 
						{
							MyTable.printTable(15);							
						}
					};
					Thread t3 = new Thread(r3);
					
					t1.start();
					t2.start();	t3.start();
					
		}
}

Here the thread will take the lock from Table class.
----------------------------------------------------------------
** Inter Thread Communication(ITC) :
------------------------------------
It is a mechanism to communicate two synchronized threads within the context to achieve a particular task.

In ITC we put a thread into wait mode by using wait() method and other thread will complete its corresponding task, after completion of the task it will call notify() method so the waiting thread will get a notification to complete its remaining task.

ITC can be implemented by the following method of Object class.

1) public final void wait() throws InterruptedException

2) public native final void notify()

3) public native final void notifyAll()


public  final void wait() throws InterruptedException :-
-------------------------------------------------------------
It will put a thread into temporarly waiting state and it will release the lock.
It will wait till the another thread invokes notify() or notifyAll() for this object.

public native final void notify() :-
-------------------------------------
It will wake up the single thread that is waiting on the same object.

public native final void notifyAll() :-
----------------------------------------
It will wake up all the threads which are waiting on the same object.

*Note :- wait(), notify() and notifyAll() methods are defined in Object class but not in Thread class because these methods are related to lock(because we can use these methods from the synchronized area ONLY) and Object has a lock so, all these methods are defined inside Object class.

*What is the difference between sleep() and wait() 
----------------------------------------------------------
(Given in the diagram 02-APR-24) 
----------------------------------------------------------------
//Program that describes if we don't use ITC then the problem is ...

class Test implements Runnable
{
	int var = 0;	
	@Override
	public void run()
	{
		for(int i=1; i<=10; i++)   
		{
			var = var + i;  //var = 1 3 6 10 15 21 28
			try
			{
				Thread.sleep(200);
			}
			catch (Exception e)
			{
			}		          
		}
		
	}
}
public class ITCProblem 
{
	public static void main(String[] args) 
	{		
		Test t = new Test();
		Thread t1 = new Thread(t);		
		t1.start();
		try
		{
			Thread.sleep(200);
		}
		catch (Exception e)
		{
		}		
	    
		System.out.println(t.var);
	}
}


In the above program, there is no communication between main thread and child thread because value of var will modify with loop iteration.

wait(), notify() and notifyAll(), we should use all these methods 
from the synchronized area only otherwise we will get an exception i.e java.lang.IllegalMonitoStateException
----------------------------------------------------------------
//Communication between main thread and child thread using ITC

class SecondThread extends Thread 
{
	    int x = 0;

	    @Override
		public void run() 
		{
			//child thread is waiting for lock
			synchronized(this) 
			{
				for(int i=1; i<=10; i++)
				{
					x =  x + i;
				}
				System.out.println("Sending notification");
				notify();  
			}
	 }
} 
public class InterThreadComm
{
public static void main(String [] args) 
{
		SecondThread b = new SecondThread();  
		b.start();

		synchronized(b)  //lock is taken by main thread
			{
				//main thread is suspended by Thread Schedular
				try 
				{
					System.out.println("Waiting for b to complete...");
					b.wait(); //main thread will wait and release the lock

					System.out.println("Main thread wake up");
				} 
				catch (InterruptedException e)
				{
				}
				System.out.println("Value is: " + b.x);
			}		
	}
}


Note :- Here main thread is waiting for Child Thread to send the notification so, we will get proper output for x
-----------------------------------------------------------------
class Customer
{  
     int balance = 10000;    

	public synchronized void withdraw(int amount) //amount = 15000  
	{  
		System.out.println("going to withdraw...");    
		if(balance < amount)
			{  
				System.out.println("Less balance; waiting for deposit...");  
					try
					{
						wait();  //waiting and releasing the lock
					}
					catch(Exception e){}  
			}  
		balance  = balance - amount;
		System.out.println("withdraw completed..."+balance+" is remaining balance"); 
	}    

	public synchronized void deposit(int amount)   //amount = 9000
		{  
			System.out.println("going to deposit...");  
			balance = balance + amount;  
			System.out.println("Balance after deposit is :"+balance);
			System.out.println("deposit completed... ");  
			notify();  
		}  
}   
public class InterThreadBalance
{  
public static void main(String args[])
	{  
      Customer c = new Customer();    //lock is created here

		Thread son = new Thread()  //anonymous class concept
		{  
			@Override
			public void run()
			{
				c.withdraw(15000);
			}  
		};
		son.start(); 		

		Thread father = new Thread()
		{  
			public void run()
			{
				c.deposit(9000);
			}  
		};
		
		father.start();  
    }
} 
----------------------------------------------------------------
Program on notifyAll() method :
--------------------------------
class Resource 
{
    private boolean flag = false;

    public synchronized void waitMethod() 
	{
		System.out.println("Wait");
       	while (!flag) 
		{
          try 
		  {
             System.out.println(Thread.currentThread().getName() + " is waiting...");
             wait(); 
          } 
		  catch (InterruptedException e) 
		  {
                e.printStackTrace();
          }
        }
        System.out.println(Thread.currentThread().getName() + " thread completed!!");
    }

    public synchronized void setMethod() 
	{
		System.out.println("notifyAll");
		this.flag = true;
        System.out.println(Thread.currentThread().getName() + " has make flag value as a true");
        notifyAll(); // Notify all waiting threads that the signal is set
    }
}

public class InterThreadNotifyAll
{
    public static void main(String[] args) 
		{
        Resource r1 = new Resource();

        Thread t1 = new Thread(() -> r1.waitMethod(), "Child1");
        Thread t2 = new Thread(() -> r1.waitMethod(), "Child2");
		Thread t3 = new Thread(() -> r1.waitMethod(), "Child3");
		
		Thread setter = new Thread(() -> r1.setMethod(), "Setter_Thread");

        t1.start();
        t2.start();
        t3.start();
       
	     
        try 
		{
            Thread.sleep(2000);
        } 
		catch (InterruptedException e) 
		{
            e.printStackTrace();
        }


        setter.start();
    }
}
----------------------------------------------------------------
Thread Priority :
------------------
It is possible in java to assign priority to a Thread. Thread class has provided two predefined methods setPriority(int newPriority) and getPriority() to set and get the priority of the thread respectively.

In java we can set the priority of the Thread in numbers from 1- 10 only where 1 is the minimum priority and 10 is the maximum priority.

Whenever we create a thread in java by default its priority would be 5 that is normal priority.

The user-defined thread created as a part of main thread will acquire the same priority of main Thread.

Thread class has also provided 3 final static variables which are as follows :-

Thread.MIN_PRIORITY  :- 01

Thread.NORM_PRIORITY : 05

Thread.MAX_PRIORITY  :- 10

Note :- We can't set the priority of the Thread beyond the limit(1-10) so if we set the priority beyond the limit (1 to 10) then it will generate an exception java.lang.IllegalArgumentException.
----------------------------------------------------------------
package com.ravi.advanced;

public class MainPriority 
{
	public static void main(String[] args) 
	{
		Thread t = Thread.currentThread();
				
		System.out.println(t.getPriority());
		
		Thread t1 = new Thread();
		System.out.println(t1.getPriority());
	}

}
----------------------------------------------------------------
package com.ravi.advanced;

class ThreadP extends Thread
{
	@Override
	public void run()
	{
	  int priority = Thread.currentThread().getPriority(); 
	  
	  System.out.println("Child Thread priority is :"+priority);  	  
	}
}
public class MainPriority1 
{
	public static void main(String[] args) 
	{
		Thread t = Thread.currentThread();
		t.setPriority(8);
		
		//t.setPriority(11); Invalid java.lang.IllegalArgumentException 
		
		System.out.println("Main thread priority is :"+t.getPriority()); 		
		
		ThreadP t1 = new ThreadP();
		t1.start();		
	}
}
----------------------------------------------------------------
package com.ravi.advanced;

class ThreadPrior1 extends Thread
{
	@Override
	public void run()   
	{	
		int count = 0; 
		
		for(int i=1; i<=1000000; i++)
		{
		  count++;	
		}
		
	System.out.println("Thread name is:"+Thread.currentThread().getName());
	System.out.println("Thread priority is:"+Thread.currentThread().getPriority());
	}	
	
	public static void main(String args[])
	{
		ThreadPrior1 m1 = new ThreadPrior1();
		ThreadPrior1 m2 = new ThreadPrior1();
		
		m1.setPriority(Thread.MIN_PRIORITY);//1
		m2.setPriority(Thread.MAX_PRIORITY);//10	
		
		m1.setName("Last");
		m2.setName("First");	
		
		m1.start();
		m2.start();
	}
} 

Most of time the thread having highest priority will complete its task but we can't say that it will always complete its task first.
----------------------------------------------------------------
04-04-2024
----------

Thread.yield() :
----------------
It is a static method of Thread class.

It will send a notification to thread schedular to stop the currently executing Thread (In Running state) and provide a chance to Threads which are in Runnable state to enter inside the running state having same priority or higher priority. Here The running Thread will directly move from Running state to Runnable state.

The Thread schedular can ignore this notification message given by currently executing Thread.

Here there is no guarantee that  after using yield() method the running Thread will move to Runnable state and from Runnable state the thread can move to Running state.[That is the reason yield() method is throwing InterruptedExecption]

If the thread which is in runnable state is having low priority then the current executing thread in Running state, will continue its execution.

It is mainly used to avoid the over-utilisation a CPU by the current Thread.
----------------------------------------------------------------
class Test implements Runnable
{
	@Override
	public void run()
	{		
		for(int i=1; i<=10; i++)
		{
			String name = Thread.currentThread().getName();

			System.out.println("i value is :"+i+" by thread :"+name);    
			
			 if(name.equals("Child1"))
			{
				Thread.yield();  //Give a chance to Child2 Thread
			}

		}
   }
}
public class ThreadYieldMethod 
{
	public static void main(String[] args) 
	{
		Test obj = new Test();

		Thread t1 = new Thread(obj, "Child1");
		Thread t2 = new Thread(obj, "Child2");
        
		t1.start();  t2.start();
	}
}

Note :- In real time if a thread is acquiring more time of CPU then to release that Thread we call yield() method the currently executing Thread.
-----------------------------------------------------------------
interrupt Method of Thread class :
----------------------------------
It is a predefined method of Thread class. The main purpose of this method to disturb the execution of the Thread, if the thread is in waiting or sleeping state.

Whenever a thread is interupted then it throws InterruptedException so the thread (if it is in sleeping or waiting mode) will get a chance to come out from a particular logic.

Points :-
---------
If we call interrupt method and if the thread is not in sleeping or waiting state then it will behave normally.

If we call interrupt method and if the thread is in sleeping or waiting state then we can stop the thread  gracefully.

*Overall interrupt method is mainly used to interrupt the
thread safely so we can manage the resources easily.

Methods :
---------
1) public void interrupt () :- Used to interrupt the Thread but the thread must be in sleeping or waiting mode.

2) public boolean isInterrupted() :- Used to verify whether thread is interrupted or not.
-------------------------------------------------------------
class Interrupt extends Thread
{
   @Override
   public void run()
	{
	   Thread t = Thread.currentThread();
	   System.out.println(t.isInterrupted()); 
       
	   for(int i=1; i<=10; i++)
		{
		   System.out.println(i);  
		   try
		   {
			Thread.sleep(1000);
		   }
		   catch (InterruptedException e)
		   {
			   System.err.println("Thread is Interrupted ");
			   e.printStackTrace();
		   }
		}
	}
}
public class  InterruptThread
{
	public static void main(String[] args) 
	{
		Interrupt it = new Interrupt();
		System.out.println(it.getState());  
		it.start();
		it.interrupt();  //main thread is interrupting the child thread
	}
}

Here main thread is interrupting the Child Thread. 
-------------------------------------------------------------
class Interrupt extends Thread
{
   public void run()
	{
	   try
	   {
	    Thread.currentThread().interrupt();

	   for(int i=1; i<=10; i++)
		{
		   System.out.println("i value is :"+i);
		   Thread.sleep(1000);
		}

	   }
		catch (InterruptedException e)
		{
			System.err.println("Thread is Interrupted :"+e);
		}
		System.out.println("Child thread completed...");
	}
}
public class  InterruptThread1
{
	public static void main(String[] args) 
	{
		System.out.println("Main thread is started");
		Interrupt it = new Interrupt();
		it.start();
		System.out.println("Main thread is ended");
	}
}

Here Child Thread is interrupting to itself.
-------------------------------------------------------------
public class InterruptThread2
{
    public static void main(String[] args) 
	{
        Thread thread = new Thread(new MyRunnable());
        thread.start();
     
        try 
		{
           Thread.sleep(3000);//main thread is waiting for 3 sec
        } 
		catch (InterruptedException e) 
		{
            e.printStackTrace();
        }
        
       thread.interrupt();  //child thread interrupted
    }
}

class MyRunnable implements Runnable 
{
    @Override
    public void run() 
	{
        try 
		{
            while (!Thread.currentThread().isInterrupted())
			{
                System.out.println("Thread is running...");
                Thread.sleep(500);
            }
        } 
		catch (InterruptedException e) 
		{
            System.out.println("Thread interrupted gracefully.");
        } 
		finally 
		{
            System.out.println("Thread resource can be release here.");
        }
    }
}
Note :- Here main thread is in sleeping mode for 3 sec, after wake up main thread is interrupting child thread so child thread will come out from infinite loop and if any resource is attached with child thread that will be released because child thread execution completed.
finally block is there to close the resource.
-------------------------------------------------------------
ThreadGroup :-
--------------
There is a predefined class called ThreadGroup available in java.lang package.

In Java it is possible to group multiple threads in a single object so, we can perform a particular operation on a group of threads by a single method call.

The target of thread may be same or may be different.

The Thread class has the following constructor for ThreadGroup 

new Thread(ThreadGroup groupName, Runnable target, String name);

-------------------------------------------------------------
public class ThreadGroupDemo1
{
   public static void main(String[] args) 
	{       
        ThreadGroup myThreadGroup = new ThreadGroup("NIT_Thread");

        // Create and start threads within the ThreadGroup

        Thread thread1 = new Thread(myThreadGroup, new MyRunnable(), "Thread 1");

        Thread thread2 = new Thread(myThreadGroup, new MyRunnable(), "Thread 2");

        Thread thread3 = new Thread(myThreadGroup, new MyRunnable(), "Thread 3");

		
      
        
        
        thread1.start();
        thread2.start();
        thread3.start();
		

        // Display information about the ThreadGroup and its threads
        System.out.println("ThreadGroup Name: " + myThreadGroup.getName());

        System.out.println("Active Count: " + myThreadGroup.activeCount());       
    }
}

class MyRunnable implements Runnable //static nested inner 
{
        @Override
        public void run() 
		{
            for (int i = 1; i <= 3; i++) 
			{
                System.out.println(Thread.currentThread().getName() + ": " + i);
                try 
				{
                    Thread.sleep(1000);
                } 
				catch (InterruptedException e) 
				{
                    e.printStackTrace();
                }
            }
        }
    }
-------------------------------------------------------------
Deadlock :
------------
It is a situation where two or more than two threads are in blocked state forever, here threads are waiting to acquire another thread resource without releasing it's own resource.

This situation happens when multiple threads demands same resource without releasing its own attached resource so as a result we get Deadlock situation and our execution of the program will go to an infinite state as shown in the diagram. (05-APR-24)

public class DeadlockExample
	{
  public static void main(String[] args) 
	 {
     String resource1 = "Ameerpet";  
     String resource2 = "S R Nagar";  

    // t1 tries to lock resource1 then resource2

    Thread t1 = new Thread() 
		{
	  @Override
      public void run() 
		  {
			  synchronized (resource1) 
				  {
			   System.out.println("Thread 1: locked resource 1");
			      try 
				   { 
				   Thread.sleep(1000);
				   } 
				   catch (Exception e) 
				   {}
				  
			   synchronized (resource2) //Nested synchronized block
			   {
				System.out.println("Thread 1: locked resource 2");
			   }
             }
      }
    };


    // t2 tries to lock resource2 then resource1
    Thread t2 = new Thread() 
	{
      @Override
      public void run() 
	  {
        synchronized (resource2) 
			{
          System.out.println("Thread 2: locked resource 2");
              try 
			  { 
			  Thread.sleep(1000);
			  } 
			  catch (Exception e) 
			{}

          synchronized (resource1) //Nested synchronized block
		  {
            System.out.println("Thread 2: locked resource 1");
          }
        }
      }
    };    
    t1.start();
    t2.start();
  }
}
---------------------------------------------------------------
Daemon Thread [Service Level Thread]:
--------------------------------------
Daemon thread is a low- priority thread which is used to provide background maintenance.  

The main purpose of of Daemon thread to provide services to the user thread.              

JVM can't terminate the program till any of the non-daemon (user) thread is active, once all the user thread will be completed then JVM will terminate all Daemon threads, which are running in the background to support user threads.

The example of Daemon thread is Garbage Collection thread, which is running in the background for memory management.

In order to make a thread as a  Daemon thread , we should use setDaemon(true)
---------------------------------------------------------------
public class DaemonThreadDemo1 
{
  public static void main(String[] args) 
	{
	    System.out.println("Main Thread Started...");

        Thread daemonThread = new Thread(() -> 
		{
            while (true) 
			{
                System.out.println("Daemon Thread is running...");
                try 
				{
                    Thread.sleep(1000);
                } 
				catch (InterruptedException e) 
				{
                    e.printStackTrace();
                }
            }
        });

        daemonThread.setDaemon(true); 
        daemonThread.start();

        
        Thread userThread = new Thread(() -> 
		{
            for (int i = 1; i <= 9; i++) 
			{
                System.out.println("User Thread: " + i);
                try 
				{
                    Thread.sleep(2000);
                } 
				catch (InterruptedException e) 
				{
                    e.printStackTrace();
                }
            }
        });

        userThread.start();

        System.out.println("Main Thread Ended...");
    }
}
---------------------------------------------------------------
Remaining method of Object class :
----------------------------------
Object cloning in java :
----------------------------
Object cloning is the process of creating an exact copy of an existing object in the memory.

Object cloning can be done by the following process :

1) Creating Shallow copy 

2) Creating Deep copy

3) Using clone() method of java.lang.Object class

4) Passing Object reference to the Constructor.

Shallow Copy :
-----------------
In shallow copy, we create a new reference variable which will point to same old existing object so if we make any changes through any of the reference variable then original object content will be modified.

Here we have one object and multiple reference variables.

Hashcode of the object will be same because all the reference variables are pointing to t
---------------------------------------------------------------
package com.ravi.clone_method;

class Student
{
	int id;
	String name;
	
	@Override
	public String toString() 
	{
		return "Id is :" + id + "\nName is :" + name ;
	}
	
}
public class ShallowCopy 
{
	public static void main(String[] args) 
	{
		Student s1 = new Student();
		s1.id = 111;
		s1.name = "Ravi";
        
		System.out.println(s1);
		
		System.out.println("After Shallow Copy");
		
		Student s2 = s1; //shallow copy
		s2.id = 222;
		s2.name = "Shankar";
		
		System.out.println(s1);
		System.out.println(s2);
		
		System.out.println(s1.hashCode());
		System.out.println(s2.hashCode());
	}

}
---------------------------------------------------------------
Deep Copy :
--------------
In deep copy, We create a copy of object in a different memory location. This is called a Deep copy. 

Here objects are created in two different memory locations so if we modify the content of one object it will not reflect another object.

package com.ravi.clone_method;

class Employee
{
	int id;
	String name;
	
	@Override
	public String toString() 
	{
		return "Employee [id=" + id + ", name=" + name + "]";
	}	
}

public class DeepCopy 
{
	public static void main(String[] args)
	{
		Employee e1 = new Employee();
		e1.id = 111;
		e1.name = "Ravi";
		
		Employee e2 = new Employee();
		e2.id = e1.id;
		e2.name = e1.name;
		
		System.out.println(e1 +" : "+e2);
		
		e2.id = 222;
		e2.name = "shankar";
		System.out.println(e1 +" : "+e2);
		
		System.out.println(e1.hashCode() +" : "+e2.hashCode());
	}

}
---------------------------------------------------------------

protected native Object clone() throws CloneNotSupportedException
---------------------------------------------------------------
Object cloning in Java is the process of creating an exact copy of the original object. In other words, it is a way of creating a new object by copying all the data and attributes from the original object. 

The clone method of Object class creates an exact copy of an object.

In order to use clone() method , a class must implements Clonable interface because we can perform cloning operation on Cloneable objects only [JVM must have additional information].

We can say an object is a Cloneable object if the corresponding class implements Cloneable interface.

It throws a checked Exception i.e CloneNotSupportedException

Note :- clone() method is not the part of Clonable interface[marker interface], actually it is the method of Object class.

clone() method of Object class follow deep copy concept so hashcode will be different.
---------------------------------------------------------------
package com.ravi.clone_method;

class Customer implements Cloneable
{
	int id;
	String name;
	
		
	@Override
	protected Object clone() throws CloneNotSupportedException 
	{
		return super.clone();
	}
	
	

	@Override
	public String toString()
	{
		return "Customer [id=" + id + ", name=" + name + "]";
	}	
}

public class CloneMethod 
{
	public static void main(String[] args) throws CloneNotSupportedException 
    {
		Customer c1 = new Customer();	
		c1.id = 222;
		c1.name = "Rahul";
		
		Customer c2 = (Customer) c1.clone(); //deep copy
		c2.id = 333;
		c2.name = "Rohit";
		
		System.out.println(c1);
		System.out.println(c2);
		
		System.out.println(c1.hashCode());
		System.out.println(c2.hashCode());
		
		
	}

}
--------------------------------------------------------------
protected void finalize() throws Throwable  :
---------------------------------------------------
It is a predefined method of Object class.

Garbage Collector automatically call this method just before an object is eligible for garbage collection to perform clean-up activity.

Here clean-up activity means closing the resources associated with that object like file connection, database connection, network connection and so on we can say resource de-allocation.

Note :- JVM calls finalize method only one per object.

Diagram (06-APR-24)
---------------------------------------------------------------
package com.ravi.finalize_method;

public class Student 
{
    int id;
    String name;
    
    public Student(int id, String name)
    {
    	this.id= id;
    	this.name = name;
    }    
    
	@Override
	public String toString() 
	{
		return "Id is :"+id+"\nName is :"+name;
	}

	@Override
	protected void finalize() 
	{
      System.out.println("JVM call this finalize method...");		
	}


	public static void main(String[] args) throws InterruptedException 
	{
      Student s1 = new Student(111,"Ravi");
      System.out.println(s1.hashCode());
      System.out.println(s1);
      
      s1 = null;
      System.gc(); //Explicitly calling Garbage Collector
      Thread.sleep(3000);
      System.out.println(s1);
	}

}
----------------------------------------------------------------
*What is the difference between final, finally and finalize

final :- It is a keyword which is used to provide some kind of          restriction like class is final, Method is
         final,variable is final.

finally :- if we open any resource as a part of try block then 
           that particular resource must be closed inside 
	   finally block otherwise program will be terminated ab-normally and the corresponding resource will not be closed (because the remaining lines of try block will not be executed)

finalize() :- It is a method which JVM is calling automatically               just before object  destruction so if any resource
              (database, file and network) is associated with
	      that particular object then it will be closed
	      or de-allocated by JVM by calling finalize().

---------------------------------------------------------------
Problem Statement:

You are tasked with creating an education institute course enrollment system using Java. The system should provide courses and offers to students, allowing them to view available courses, ongoing offers, and enroll in their preferred courses.



Classes:
Take one BLC class Course

Attributes:

-> courseId (int): Unique identifier for the course.

-> courseName (String): Name of the course.

-> corseFee (double): Fee for the course.



Methods:

-> Parameterized Constructor to initialize the instance variable.

-> Generate getters for all field

-> Override toString() method


class Offer:

Attributes:

-> offerText (String): Description of the special offer provided by the education institute.



Methods:

-> Offer(String offerText): Constructor to initialize the offer description.

-> getOfferText(): Returns the offer description.



class EducationInstitute:

Attributes:

-> courses (Course[]): An array to store the available courses.

-> offers (Offer[]): An array to store ongoing offers.



Methods:

-> EducationInstitute(): Constructor to initialize courses and offers.

-> getCourses(): Returns the array of available courses.

-> getOffers(): Returns the array of ongoing offers.

-> enrollStudentInCourse(int courseId, String studentName): Simulates the enrollment process and prints a message when a student -> enrolls in a course.



class Student:

Attributes:

-> name (String): Name of the student.

-> institute (EducationInstitute): Reference to the education institute where the student interacts.



Methods:

-> Student(String name, EducationInstitute institute): Constructor to initialize the student with their name and the education institute reference.

-> viewCoursesAndFees(): Displays the available courses and their fees.

-> viewOffers(): Displays the ongoing offers.

-> enrollInCourse(int courseId): Enrolls the student in the specified course using the education institutes enrollment process.



class Main :



The EducationInstituteApp class is the main program that simulates concurrent student interactions using threads. 

It creates an education institute, initializes students, and allows them to view course details, ongoing offers, and enroll in courses concurrently without disturbing the execution flow of each thread.



Instructions for Students:

-> Implement the above classes and their methods following the given specifications.

-> Create an instance of EducationInstitute, and initialize courses and offers with hardcoded data for simplicity.

-> Create two students: Virat and Dhoni. Allow them to view available courses, check ongoing offers, and enroll in their preferred courses concurrently using threads.

-> Use the Thread class to simulate concurrent student interactions. Ensure that the system provides a responsive user experience for multiple students.

-> Test your program with multiple executions and verify that students can view course details, offers, and enroll without conflicts.

-> Feel free to enhance the program with additional features or error handling to further improve its functionality.



[Note : Include appropriate comments and use meaningful variable names to make your code more readable and understandable.]



Sample Output :



Available Courses:

1. Mathematics - Fee: Rs.1000.0

2. Science - Fee: Rs.1200.0

3. English - Fee: Rs.900.0

Ongoing Offers:

Special discount: Get 20% off on all courses!

Limited time offer: Enroll in any two courses and get one course free!

Virat has enrolled in the course: Mathematics



Available Courses:

1. Mathematics - Fee: Rs.1000.0

2. Science - Fee: Rs.1200.0

3. English - Fee: Rs.900.0

Ongoing Offers:

Special discount: Get 20% off on all courses!

Limited time offer: Enroll in any two courses and get one course free!

Dhoni has enrolled in the course: Science
---------------------------------------------------------------
5 files :
---------
Course.java
------------
package com.ravi.lab;

public class Course {
	private int courseId;
	private String courseName;
	private double courseFee;

	public Course(int courseId, String courseName, double courseFee) {
		super();
		this.courseId = courseId;
		this.courseName = courseName;
		this.courseFee = courseFee;
	}

	public int getCourseId() {
		return courseId;
	}

	public String getCourseName() {
		return courseName;
	}

	public double getCourseFee() {
		return courseFee;
	}

	@Override
	public String toString() {
		return "Course [courseId=" + courseId + ", courseName=" + courseName + ", courseFee=" + courseFee + "]";
	}
	
	

}

Offer.java
----------

package com.ravi.lab;

public class Offer {
	private String offerText;

	public Offer(String offerText) {
		super();
		this.offerText = offerText;
	}

	public String getOfferText() {
		return offerText;
	}

}

EducationInstitute.java
-------------------------

package com.ravi.lab;

public class EducationInstitute {
	private Course[] courses;
	private Offer[] offers;

	public EducationInstitute(Course[] courses, Offer[] offers) {
		super();
		this.courses = courses;
		this.offers = offers;
	}

	public Course[] getCourses() {
		return courses;
	}

	public Offer[] getOffers() {
		return offers;
	}
	
	public void enrollStudentInCourse(int courseId, String studentName)
	{
		for(int i=0; i<courses.length; i++)
		{
			if(courseId == courses[i].getCourseId())
			{
				System.out.println(studentName+" enrolled in :"+courses[i].getCourseName());
			}
		}
		
	}

}

Student.java
------------
package com.ravi.lab;

public class Student {
	private String studentName;
	private EducationInstitute educationInstitute;

	public Student(String studentName, EducationInstitute educationInstitute) {
		super();
		this.studentName = studentName;
		this.educationInstitute = educationInstitute;
	}

	public void viewCoursesAndFees()
	{
		Course[] courses = educationInstitute.getCourses();
		for(Course course : courses)
		{
			System.out.println(course.getCourseId()+" : "+course.getCourseName()+" : "+course.getCourseFee());
		}
	}
	
	public void viewOffers()
	{
		Offer[] offers = educationInstitute.getOffers();
		
		for(Offer offer : offers)
		{
			System.out.println(offer.getOfferText());
		}
		
		
	}
	
	public void enrollInCourse(int courseId)
	{
		educationInstitute.enrollStudentInCourse(courseId, studentName);
	}	
}

Main.java
---------

package com.ravi.lab;

public class Main {

	public static void main(String[] args) throws InterruptedException 
	{
		Course [] courses = new Course[3];
		courses[0] = new Course(1, "Java", 1000);
		courses[1] = new Course(2, ".NET", 1200);
		courses[2] = new Course(3, "Python", 900);
		
		Offer [] offers = new Offer[2];
		offers[0]= new Offer("Special discount: Get 20% off on all courses!");
		offers[1] = new Offer("Limited time offer: Enroll in any two courses and get one course free!");
		
		EducationInstitute ei = new EducationInstitute(courses, offers);
		
		Student virat = new Student("Virat", ei);
		Student dhoni = new Student("Dhoni", ei);
		Student sachin = new Student("Sachin", ei);
		
		Thread t1 = new Thread()
		{
		 @Override
		 public void run()
		 {
			 System.out.println("Available courses and Fess :");
			 virat.viewCoursesAndFees();
			 virat.viewOffers();
			 virat.enrollInCourse(1);
		 }		
			
		};
		
		
		Thread t2 = new Thread()
		{
		 @Override
		 public void run()
		 {
			 System.out.println("Available courses and Fess :");
			 dhoni.viewCoursesAndFees();
			 dhoni.viewOffers();
			 dhoni.enrollInCourse(2);
		 }		
			
		};
		
		Thread t3 = new Thread()
		{
		 @Override
		 public void run()
		 {
			 System.out.println("Available courses and Fess :");
			 sachin.viewCoursesAndFees();
			 sachin.viewOffers();
			 sachin.enrollInCourse(3);
		 }		
			
		};
		
        t1.start();		
		t1.join();
		System.out.println("------------------------------");
		t2.start();
		t2.join();
		System.out.println("------------------------------");
		t3.start();
		
	}

}
----------------------------------------------------------------
String Handling in java :
-------------------------
A string literal in Java is basically a sequence of characters. These characters can be anything like alphabets, numbers or symbols which are enclosed with double quotes. So we can say String is a collection of alpha-numeric character.

How we can create String in Java :-
-----------------------------------
In java String can be created by using 3 ways :-

1) By using String Literal 

   String x = "Ravi";      

2) By using new keyword 

   String y = new String("Hyderabad");

3) By using character array

   char z[] = {'H','E','L','L','O'};
--------------------------------------------------------------
Immutability in String (Diagram 13-MAR-24)
-------------------------------------------
In java Strings Objects are immutable means unchanged so, whenever we create a String object in java it can't be modifiable.

Strings literals are created in a very special memory of HEAP called String Constant Pool(SCP) and it is not eligible for garbage collection.

String once created can't be modifiable.

Note :- Whenever we create the String Object using literal then internally intern() method is invoked to place the String
object into String Constant Pool Area.
--------------------------------------------------------------
Facts about String and memory :-
--------------------------------------
In java Whenever we create a new String object by using String literal, first of all JVM will verify whether the String we want to create is pre-existing (already available ) in the String constant pool or not.

If the String is pre-existing (already available) in the String Constant pool then JVM will not create any new String object, the same old existing String object would be refer by new reference variable as shown in the diagram(13-MAR)

Note :- In SCP area we can't have duplicate String Object.
----------------------------------------------------------------
15-03-2024
----------
* Why String objects are immutable :
-------------------------------------
As we know a String object in the String constant pool can be refer by multiple reference variables, if any of the reference variable will modify the String Object value then it would be very difficult for the another reference variables pointing to same String object to get the original value, what they have defined earlier as shown in the diagram.(15-MAR)
That is the reason Strings are immutable in java.

Note :- While working with Map interface we can hold String object as a Map key so that time also it must be immutable.
-----------------------------------------------------------------
WAP in java to show String objects are not eligible for GC.
------------------------------------------------------------

public class StringGCEligibility 
{
	public static void main(String[] args) throws InterruptedException 
	{
		String str1 = "India";
		System.out.println(str1.hashCode());
		
		str1 = null;
		
		System.gc();
		
		Thread.sleep(2000);
		
		String str2 = "India";
		System.out.println(str2.hashCode());
		
		System.out.println("...........");
		System.out.println(str1);
		System.out.println(str2);
	}
}

From the above program it is clear that Strings are not eligible for GC.
----------------------------------------------------------------
* What is the difference between the following two statements ?
----------------------------------------------------------------

String x = "Naresh";   [Creating String by Literal]

String y = new String("Hyderabad"); [Creating String Object by new keyword]

----------------------------------------------------------------------
String x = "Naresh"; 

It will create one String object and one reference variable and String object will be created in the String constant pool.
----------------------------------------------------------------------
String y = new String("Hyderabad");

It will create two String objects one is inside the heap memory(non SCP area) which will be refered by y reference variable and the same String object will be placed in the String constant pool area, if it is not available there.
Hence two String Objects and one reference variable will be created.
-----------------------------------------------------------------
Program in java that describes whenever we create String object by using new keyword then two String objects are created with same content with same hash code.

package com.ravi.method_parameter_local;

public class Test {

	public static void main(String[] args) 
	{
                String str1 = new String("Hyderabad");
		
		String str2 = "Hyderabad";
		
		System.out.println(str1.hashCode());
		System.out.println(str2.hashCode());
		
		System.out.println(str1 == str2);  //false
	}
}
-----------------------------------------------------------------
The String object created by using new keyword, how they are automatically placed inside SCP area.

In Java whenever we create the String Object by using new keyword then one object will be created in the non SCP area and same object will be placed inside SCP area, Actually Here JVM internally performs intern process. By using this intern process, JVM is placing the String into SCP Area.

The following program explains how to use intern() method explicitly (By user) to place the String created by new keyword into SCP Area.
----------------------------------------------------------------
package com.ravi.string_ex;

public class StringTest 
{
	public static void main(String[] args) 
	{
	   String str1 = "Java";	   
	   String str2 = new String("Java");
	   
	   System.out.println(str1 == str2); //false
	   str2 = str2.intern();
	  
	   System.out.println(str1 == str2); //true
	}

}

[Diagram 15-MARCH]
-----------------------------------------------------------------
package com.ravi.string_ex;

public class StringHashCode {

	public static void main(String[] args) 
	{
		String str1 = "Ravi";
		String str2 = "Ravi";
		String str3 = new String("Ravi");
		
		System.out.println(str1.hashCode() +" : "+str2.hashCode()+" : "+str3.hashCode());
		

	}

}
----------------------------------------------------------------
Working with methods of String :-
--------------------------------------
String class has provided number of predefined methods to work with String which are as follows :-

1) public char charAt(int indexPosition) :-
--------------------------------------
It is a predefined method available in the String class. The main purpose of this method to extract or fetch or retrieve a single character from the given String. 

We need to pass the index position as a parameter to the method and based on the index position it will extract the character. The return type of this method is char.
----------------------------------------------------------------
//Program on charAt(int indexPosition)
public class Test4 
{
	public static void main(String[] args) 
	{
	    String x = "Hello Hyderabad";

        char ch1 =  x.charAt(6); 
		System.out.println(ch1); //H

		ch1 = x.charAt(4); 
		System.out.println(ch1); //o

		ch1 = x.charAt(9); 
		System.out.println(ch1); //e
	}
}
---------------------------------------------------------------
public String concat(String str) :-
--------------------------------------
It is a predefined method available in the String class. The main purpose of this method to concat or append two Strings. This can be also done by using concatenation operator '+'. 

This method takes String as a parameter and the return type of this method is String.
--------------------------------------------------------------
 //Program on concat(String str)
public class Test5 
{
	public static void main(String[] args) 
	{
		String s1 = "Data";
		String s2 = "base";
		String s3 = s1.concat(s2);  
		System.out.println("String after concatenation :"+s3);

        String s4 = "Tata";
		String s5 = "Nagar";
		String s6 = s4+s5;
		System.out.println("String after concatenation :"+s6);

        String s7 = "Naresh";
		System.out.println(s7.concat(" Technology"));		
	}
}
----------------------------------------------------------------
07-04-2024
-----------
public boolean equals(Object obj) : [Content Comparison]
--------------------------------------------------------
It is a predefined method available in the String class. The main purpose of this method to verify whether two Strings are equal or not based on the content.

If both the Strings are equal it will return true otherwise it will return false.It is case sensitive method.

It takes Object as a parameter because it is an overridden method.It is overridden from Object class.
--------------------------------------------------------------
package com.ravi.equals;

public class EqualsComparison {

	public static void main(String[] args) 
	{
		String str1 = "India";
		String str2 = new String("India");
		
		System.out.println(str1==str2);
		System.out.println(str1.equals(str2));

	}

}
---------------------------------------------------------------
Contents comparison of two String using equals(Object obj) method by implementing Predicate<T> functional interface.

@FunctionalInterface
public interfrace Predicate<T>
{
   public abstract boolean test(T x);
}
----------------------------------------------------------------
package com.ravi.equals;

import java.util.Scanner;
import java.util.function.Predicate;

//Verify a name using Predicate
public class PredicateDemo {

	public static void main(String[] args) 
	{
		Predicate<String> p1 = str -> str.equals("Ravi");
		
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter your Name :");
		String name = sc.next();
		
		System.out.println(p1.test(name));
		sc.close();
				
				
				

	}

}
----------------------------------------------------------------
public boolean equalsIgnoreCase(String str) :-
--------------------------------------------------
It is a predefined method available in the String class. The main purpose of this method to Compare two Strings based on the content by ignoring the case.
This method takes String as a parameter and return type of this method is boolean. It comapres two Strings by ignoring the case so it is not a case sensitive method.

Hence for this method 'A' and 'a' both are same.
----------------------------------------------------------------
//Program on boolean equalsIgnoreCase(String s)
public class Test7 
{
	public static void main(String[] args) 
	{		
		String username = args[0];

		if(username.equalsIgnoreCase("Raviinfotech"))
		{
			System.out.println("Welcome to Raviinfotech channel");
		}
		else
		{
			System.out.println("Sorry! wrong username /Password");
		}
	}
}
----------------------------------------------------------------
IQ 
What is differenec b/w == operator and equals(Object obj) method of String class

equals(object obj) method of String class compares two strings based on the content because it is an overriden method where as == operator compares two Strings based on the reference i.e memory address.

//IQ
public class Test8 
{
	public static void main(String[] args) 
	{
		String s1="India";
		String s2="India";
		String s3=new String("India");

		 System.out.println(s1==s2); 
		 System.out.println(s1==s3); 

		  System.out.println(s1.equals(s2)); 
		 System.out.println(s1.equals(s3));  
	}
}

Note :- String class has overridden equals(Object obj) method from Object class because Object class equals(Object obj) method meant for memory address comparison but this overridden String class equals(Object obj) meant for content comparison.

Note :- String is a final class in java.
----------------------------------------------------------------
public int length() :-
----------------------
It is a predefined method available in the String class. The main purpose of this method to find out the length of the given String. The return type of this method is int. 

public class Demo 
{
	public static void main(String[] args) 
	{	
		String x = "India";
		System.out.println(x.length); //error

		String []y = new String[5];		
		System.out.println(y.length()); //error
		
	}

}

//Program on public int length()  
class Test9 
{
	public static void main(String[] args) 
	{		
		String x = "Naresh Tech";
        int len = x.length();      
		System.out.println("The length of "+x+" is :"+len);
	}
}
----------------------------------------------------------------
public String replace(char old, char new) :-
----------------------------------------------------
It is a predefined overloaded method available in the String class. The main purpose of this method to replace a character or a String with another character or String. The return type of this method is String. 

By using this method we can replace a single character or a complete String from the given String.
---------------------------------------------------------------
//public String replace(char old, char new)
public class Test10
{
public static void main(String [] args) 
	{
        String x = "oxoxoxox";  
		System.out.println("String before replacement :"+x);

		System.out.println("String after replacement :"+x.replace('x','X'));

		String y="Manager";		
		System.out.println(y.replace("Man","Dam"));	
    }
}
---------------------------------------------------------------
public int compareTo(String s) :-
-------------------------------------
It is a predefined method available in the String class. The main purpose of this method two compare two String based on character by character, comparison of two Strings chracter by chracter based on the UNICODE values are called Lexicographical comparison or dictionary comparison or alphabetical comparison(String case). 

The return type of this method is int.It takes String as a parameter.

If s1 and s2 are two valid Strings 

if s1==s2  -> 0

if s1>s2  -> +ve

if s1<s2   -> -ve
---------------------------------------------------------------
//public int compareTo(String s) 
public class Test11    
{
     public static void main(String [] args) 
     {
        String s1="Sachin";      //PQRS    S > R
        String s2="Sachin";
        String s3="Ratan";  

	   System.out.println(s1.compareTo(s2)); //0
	   System.out.println(s1.compareTo(s3)); //1   [Sachin   Ratan]  
	   System.out.println(s3.compareTo(s1)); //-1  [Ratan  Sachin] 

       String s4 = "Apple"; 
	   String s5 = "apple"; 
	   System.out.println(s4.compareTo(s5));  // -32
	   System.out.println(s5.compareTo(s4));  // 32

	   String s6 = "Ravi";
	   String s7 = "Raj";
	   System.out.println(s6.compareTo(s7)); // 

    }
}
---------------------------------------------------------------
public boolean isEmpty() :-
------------------------------
It is a predefined method available in the String class. The main purpose of this method to check whether a String is empty or not. This method returns true if the String is empty that means length is 0, otherwise it will return false.

The return type of this method is boolean.
-------------------------------------------------------------
//public boolean isEmpty()

public class Test13
{
	public static void main(String args[])
	{		
		String str1 = "Java by James Gosling";
		String str2 = "";

		System.out.println(str1.isEmpty()); 
		System.out.println(str2.isEmpty()); 	  
	}
}
--------------------------------------------------------------
08-04-2024
----------
public String substring(int startIndex) :-

public String substring(int startIndex, int endIndex) :-
-------------------------------------------------------------
It is a predefined method available in the String class. The main purpose of this method to extract the part of the specified string based on the index position.

In this method the startIndex starts from 0 whereas endIndex starts from 1.

Both index will be inclusive for extracting the value.

If end index will be less than start index then we will get an exception i.e StringIndexOutOfBoundsException  
substring(5,2);

If start index and end index both are equal, nothing will print.

Nither start index nor end index will accept (-ve) value otherwise StringIndexOutOfBoundsException.
---------------------------------------------------------------
public class Test12
{
	public static void main(String []  args) 
	{
        String x="HYDERABAD";		
		System.out.println(x.substring(2,7)); //DERAB

		System.out.println(x.substring(3)); //ERABAD

		System.out.println(x.substring(3,3)); 

         //java.lang.StringIndexOutOfBoundsException 
		 System.out.println(x.substring(6,3));

		//java.lang.StringIndexOutOfBoundsException 
		System.out.println(x.substring(6, -3));
	}
}

---------------------------------------------------------------
public String intern()  :
---------------------------
It is a predefined method available in the String class. The main purpose of this method to return canonical representation for the string object that means String interning ensures that all strings having the same contents use the same memory location.

//public String intern() 
//Returns the Canonical representation for the String object.
public class Test14
{
	public static void main(String args[])
	{
		     String s1 = new String("india");
			 String s2 = new String("india");
			 System.out.println(s1 == s2);

			 s1 = s1.intern();
			 s2 = s2.intern();
			 System.out.println(s1 == s2);


			 String s3 = "Hyd";
			 String s4 = new String("Hyd");
			 System.out.println(s3 == s4);
			 s4 = s4.intern();
			 System.out.println(s3 == s4); 

			 String s5 = s4.intern();
			 System.out.println(s3 == s5); 
	}
}


Note :- Java automatically interns the string literals but we can manually use the intern() method on String object created by new keyword so all the Strings which are having same content will get the same String and return the same memory address(Canonical representation for the String ).


From the above program it is clear that, All that String having same content will represent the same memory address so the hashcode value will be same as shown in the program below.

The following explains all the Strings having same content will provide 
same hashcode.

public class Demo 
{
	public static void main(String[] args) 
	{
		String s1 = "India";
		String s2 = new String("India");
		String s3 = new String("India");

		System.out.println(s1.hashCode()+" : "+s2.hashCode()+" : "+s3.hashCode());
		
	}

}
---------------------------------------------------------------
//IQ
public class Test15
{
	public static void main(String args[])
	{
		String x = "india"; //error
		System.out.println("it's length is :"+x.length);  

		String [] y = new String[10]; //error   
		System.out.println("it's length is :"+y.length()); 	
	}
}
---------------------------------------------------------------
//public boolean startsWith(String prefix)
//public boolean endsWith(String suffix)

Both the methods are available in String class. 

startsWith() is used to verify that the given String is Starting with prefix String or not, if yes it will return true otherwise it will return false.

endsWith() is used to verify that the given String is ending with suffix String or not, if yes it will return true otherwise it will return false.

Both the methods are case-sensitive.

Both methods take String as a  parameter and return type is boolean.

//public boolean startsWith(String prefix)
//public boolean endsWith(String suffix)

public class Test16
{
	 public static void main(String args[])
	{ 
		String s="Sachin Tendulkar";
		System.out.println(s.startsWith("Sa"));
		System.out.println(s.endsWith("r"));
	}
}
---------------------------------------------------------------
public int indexOf(String str) :-
---------------------------------
It is a predefined method available in the String class. The main purpose of this method to find out the index position of the specified String in the existing String.

It will serach the index position of the first occurrance of the specified String as a parameter.

It takes String as a parameter and return type of this method is int.

//public int indexOf(String x)
public class Test17
{
	 public static void main(String args[])
	{
		String  str = "India is my country and It is in Asia";
        int index = str.indexOf("is");
		System.out.println("First Occurrance of is :"+index); 
	}
}


public int lastIndexOf(String x) :-
--------------------------------------
It is a predefined method available in the String class. The main purpose of this method to find out the last index position of the Specified String in the existing String.

It will serach the index position of the last occurrance of the String.

It takes String as a parameter and return type of this method is int.
//public int lastIndexOf(String x)
public class Test18
{
	public static void main(String args[])
	 { 
         String s1 = "it is a nice city";    
		 int lastIndex = s1.lastIndexOf("it");
		System.out.println("Last occurrance of it, is :"+lastIndex+ "th position");
     }
}
---------------------------------------------------------------
//public String toUpperCase() :- converts to upper case letter
public class Test19
{
	public static void main(String args[])
	{
        String str = "india";
		System.out.println(str.toUpperCase());
    }
}
---------------------------------------------------------------
//public String toLowerCase()  converts to lower case.
public class Test20
{
	public static void main(String args[])
	{
		String str = "INDIA";
		System.out.println(str.toLowerCase());  //india
	}
}
---------------------------------------------------------------
public String trim() :- 
-------------------------
It is a predefined method available in the String class. The main purpose of this method to remove the white spaces from the begning (heading) and end (trailing) from the String.

It will not remove any white space in the between the String. The return type of this method is String.

//program on trim()  
public class Test21
{
public static void main(String args[])
	{
		String s1="   Tata    ";  
		System.out.println(s1+"Nagar"); //       Tata      Nagar     

        s1 = "          Hello       Data        ";
		System.out.println(s1.trim() +"Base"); //Hello    DataBase	

	}
}
---------------------------------------------------------------
10-04-2024
-----------
public String []  split (String delimiter)  :
-----------------------------------------------
It is a predefined method available in the String class. The main purpose of this method to split or break the given String based on specified delimiter(Criteria OR Pattern OR Regular Expression).

The return type of this method is String array because It returns the collection of String tokens or multiple Strings.

//public String []   split(String delimiter)

public class Test22
{
public static void main(String args[])
	{
		String s1="Hyderabad is a nice city";  
		String [] words = s1.split(" "); //Space is Delimiter
		for(String word : words)
		{
			System.out.println(word);
		}       
	    System.out.println("..............");

        String s2="Hyderabad is a nice city";  
		words = s2.split("a"); 

		for(String word : words)
		{
			System.out.println(word);
		} 
	}
}  
---------------------------------------------------------------
There is a predefined class called StringTokenizer available in java.util package, is also used to split the String 

public int countTokens()
public boolean hasMoreTokens()
public String nextToken()

package com.ravi.equals;

import java.util.StringTokenizer;

//Verify a name using Predicate
public class PredicateDemo {

	public static void main(String[] args) 
	{		
		String str = "Hyderabad is an IT city";
		
        StringTokenizer st = new StringTokenizer(str, " ");
        
        System.out.println("Total number of tokens :"+st.countTokens());
        System.out.println("Tokens are :");
        
        while(st.hasMoreTokens())
        {
        	System.out.println(st.nextToken());        	
        }


	}

}
----------------------------------------------------------------
public char[] toCharArray() :
-----------------------------
It is a predefined method available in the String class. The main purpose of this method to convert the given string into a sequence of characters. The returned array length is equal to the length of the string.

This method does not take any parameter and return type is character array.

//public char[] toCharArray()
public class Test23
{
public static void main(String args[])
	{
		String str = "Java technology";
		char ch [] = str.toCharArray();

		for(char c : ch)
		{
			System.out.print(c+"  ");
		}
		System.out.println();
	}
}         
----------------------------------------------------------------
public byte [] getBytes() :-
-------------------------------
It is a predefined method available in the String class. The main purpose of this method to encode the string into bytes. It converts the string into a sequence of bytes and returns an array of bytes. 

String data we cann't write to the byte oriented Stream files so, it must be converted into byte array.

//public byte [] getBytes()
//encode the String into sequence of bytes

public class Test24
{
public static void main(String args[])
	{
		String str = "ABCDEF";	
		
		byte [] b = str.getBytes();

		for(byte a : b)
		{
			System.out.println(a);  
		}
	}
}         
----------------------------------------------------------------
StringBuffer :-
----------------
While working with String class the drawback is memory consumption is very high because it is immutable so whenever we want to perform some operation on the existing String Object, a new String object will be created.

In order to solve the problem of immutability as well as high memory consumption, java software people has introdued a separate class called StringBuffer available in java.lang packge from 1.0 onwards.

StringBuffer is a mutable class so we can modify the existing String hence automatically the memory consumption will be low but we have some performance issue because almost all the methods of StringBuffer class are synchronized so at a time only one thread can access the method of StringBuffer hence it is Thread-safe. 

In order to solve this performance issue problem java software people has introduced StringBuilder class from 1.5v onwards.

StringBuilder :-
-----------------
It is a predefined class available in java.lang packge. It is also mutable class. The only difference between StringBuffer and StringBuilder is, almost all the methods of StringBuffer are synchronized where as all the methods of StringBuilder are non-synchronized hence performance wise StringBuilder is more better than StringBuffer.

Both the classes are sharing same API so, method name, return type, parameter list all are same.
---------------------------------------------------------------
//String, StringBuffer and StringBuilder Objects comparison
public class Test25
{
public static void main(String args[])
	{
		StringBuilder sb1=new StringBuilder("Data"); //mutable
		sb1.append("Base");
		System.out.println(sb1);	

		StringBuffer sb2=new StringBuffer("Data"); //mutable
		sb2.append("Base");
		System.out.println(sb2);	

		String sb3 = new String("Data");  //immutable
	    sb3.concat("Base");
        System.out.println(sb3);	
	}
}
----------------------------------------------------------------
** What is the difference String, StringBuffer and StringBuilder?
----------------------------------------------------------------
Diagram is available in paint window
-------------------------------------
----------------------------------------------------------------
public int capacity() :
-------------------------
StringBuffer class contains capacity method() through which we can find out the initial capacity of StringBuffer class in the form of Characters.

StringBuffer sb = new StringBuffer(); //default capacity is 16

new capacity = (current capacity * 2) + 2

new Capacity = (16 * 2) + 2 = 34
----------------------------------------------------------------
//public int  capacity()   
//new capacity = ( current capacity*2)+2.
public class Test26
{
public static void main(String args[])
	{        
		StringBuffer sb1 = new StringBuffer();
		System.out.println(sb1.capacity()); //16
		
	    StringBuffer sb2 = new StringBuffer("India");  //21 (16+5)
	   System.out.println(sb2.capacity()); 

        sb2.append("is great. It is in Asia"); //44  (21*2)+2 = 44
		System.out.println(sb2.capacity()); 	
		
	}
}
----------------------------------------------------------------
12-04-2024
-----------
//public StringBuffer insert(int position, String str)
//Based on the index position we can insert the String
public class Test27
{
public static void main(String args[])
	{	
		StringBuffer sb1=new StringBuffer("Hello");
		sb1.insert(1,"JSE");
		System.out.println(sb1);  //HJSEello

		StringBuilder sb2=new StringBuilder("Hello");
		sb2.insert(1,"JEE");
		System.out.println(sb2); //HJEEello 
	}
}
----------------------------------------------------------------
//public AbstractStringBuilder reverse()
//Used to reverse the given String
class Test28
{
	public static void main(String[] args) 
	{
		StringBuffer sb1=new StringBuffer("Hello");
		sb1.reverse();
		System.out.println(sb1); //olleH 

		StringBuilder sb2=new StringBuilder("Java");
		sb2.reverse();
		System.out.println(sb2);  //avaJ		
		}
}
----------------------------------------------------------------
//Program to demonstrate the performance of StringBuffer and StringBuilder classes.
package com.ravi.performance;

public class PerformanceComparison 
{
	public static void main(String[] args) 
	{
		long startTime = System.currentTimeMillis();  
		
		StringBuilder sb1 = new StringBuilder("Java");
		
		for(int i=1; i<=1000000; i++)
		{
			sb1.append(" Technology");
		}

		long endTime = System.currentTimeMillis();  
		
		System.out.println("Total Time Taken by StringBuilder class is :"+(endTime - startTime));
		
		System.out.println("...............................");
		
         startTime = System.currentTimeMillis();  
		
		StringBuffer sb2 = new StringBuffer("Java");
		
		for(int i=1; i<=1000000; i++)
		{
			sb2.append(" Technology");
		}

		endTime = System.currentTimeMillis();  
		
		System.out.println("Total Time Taken by StringBuffer class is :"+(endTime - startTime));

	}

}

Note :- From the above program, It is clear that StringBuilder is more better than StringBuffer.

Note :- System is a predefined class available in java.lang package and it contains a predefined static method currentTimeMillis() , the return type of this method is long, actually it returns the current time of the system in ms.

   public static long currentTimeMillis()
----------------------------------------------------------------
String class Constructor :
--------------------------
String class is containing 15 constructors (some are deprecated) the commonly used constructors are :

1) String s1 = new String();

2) String s2 = new String("India");

3) String s3 = new String(byte []b);

4) String s4 = new String(char []b);

5) String s5 = new String(StringBuffer sb);

6) String s6 = new String(StringBuilder sb);
-----------------------------------------------------------------
//Program to reverse a String

//String class Constructor
//WAP in java to reverse a String
import java.util.Scanner;
public class Test1
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter a String to reverse :");
		String str = sc.nextLine();  
		
        for(int i=str.length()-1; i>=0; i--)  //i =0 
		{
			 System.out.print(str.charAt(i)); 
		}	
        System.out.println();
	}
}
----------------------------------------------------------------
//WAP in java to reverse a String
import java.util.Scanner;
public class Test2 
{
    public static void main(String[] args) 
	{
        Scanner sc = new Scanner(System.in);
		System.out.println("Enter a String to reverse :");
		String input = sc.nextLine();

        StringBuilder sb = new StringBuilder();
        sb.append(input);
        System.out.println(sb.reverse());
    }
}
----------------------------------------------------------------
//Program to find out the duplicate characters in String as well as count it in a String
import java.util.*;
public class Test3 
{
public static void main(String ...x)
{
  Scanner sc = new Scanner(System.in);
  System.out.println("Enter a String :");
  String str = sc.nextLine(); //ravishankar

  int count = 0;
  char[] arr = str.toCharArray();  //{'r','a'....} 

  System.out.println("Duplicate Characters are:");

  for (int i = 0; i < str.length(); i++)     //i=1   length = 11
  {
    for (int j = i + 1; j < str.length(); j++) //j = 2  length = 11
	{
      if (arr[i] == arr[j])   //
		  {
             System.out.println(arr[j]);  //r  a  a
             count++;                     //count = 3
             break;
          }
     }
  }
   System.out.println("Total duplicate characters are :"+count);
 }
}
----------------------------------------------------------------
//Remove a specified character from the given String  
import java.util.*;
public class Test4    
{
  public static void main(String[] args) 
  {
    Scanner sc = new Scanner(System.in);
    System.out.println("Enter a String :");
    String str = sc.nextLine();  //ravi

	System.out.println("Enter a character you want to remove :");
    char removeChar = sc.next().charAt(0); //v

    StringBuilder result = new StringBuilder(); //rai

    for (char c : str.toCharArray()) // {'r', 'a', 'v', 'i'}
		{
          if (c != removeChar)    //i != v
		  {
             result.append(c);   
          }
       }
    System.out.println(result);
  }
}
----------------------------------------------------------------
//Program to check whether a String contains vowels or not?
import java.util.*;
public class Test5
{
  public static void main(String[] args) 
  {
    Scanner sc = new Scanner(System.in);
    System.out.println("Enter a String :");
    String str = sc.nextLine();             //SKY  - sky

    boolean containsVowel = false;

    for (char c : str.toLowerCase().toCharArray())   //{'s','k'..} 
	{
      if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') 
	  {
        containsVowel = true;
        break;
      }
    }

    if (containsVowel) 
	{
      System.out.println("The string contains a vowel.");
    } 
	else 
	{
      System.out.println("The string does not contain a vowel.");
    }
  }
}
----------------------------------------------------------------
//How to sort a String data
import java.util.Scanner;
public class Test6
{
  public static void main(String[] args)
  {
    Scanner sc = new Scanner(System.in);
    System.out.println("Enter a String :");
    String str = sc.nextLine();  //mango

    char[] chars = str.toCharArray();    

    for (int i = 0; i < chars.length; i++)   
	{
      for (int j = i + 1; j < chars.length; j++)  
	  {
        if (chars[i] > chars[j])   
		{
          char temp = chars[i];
          chars[i] = chars[j];
          chars[j] = temp;
        }
      }
    }
    System.out.println(new String(chars));
  }
}
---------------------------------------------------------------
//count the occurrence of a given character in the existing String
import java.util.*;

public class Test7
{
public static void main(String[] args) 
{
    Scanner sc = new Scanner(System.in);
    System.out.println("Enter a String :");
    String str = sc.nextLine().toLowerCase();; //apple    

	System.out.println("Enter a character :");
    char target = sc.next().toLowerCase().charAt(0); //p

    int count = 0;

    for (int i = 0; i < str.length(); i++) // i = 0     length = 5
	{
            if (str.charAt(i) == target)   //e == p
			{
                count++;  //2
            }
     }
        System.out.println("The character '" + target + "' appears " + count + " times in the string '" + str + "'");
    }
}
---------------------------------------------------------------
Character class in java :
------------------------
It is a predefined Wrapper class available in java.lang package. It contains the following static methods to check whether a chracter is digit or uppercase or lowecase or not?

public static boolean isDigit(char ch);  //ravi1ui

public static boolean isUpperCase(char ch);

public static boolean isLowerCase(char ch);
---------------------------------------------------------------
//Program to find out a String contains digit or not
//public static boolean isDigit(char ch) 

import java.util.*;
public class Test8
{
public static void main(String[] args) 
{
    Scanner sc = new Scanner(System.in);
    System.out.println("Enter a String :");
    String str = sc.nextLine();

    boolean containsDigits = false;

    for (int i = 0; i < str.length(); i++)   ///Ravi123
	{
      if (Character.isDigit(str.charAt(i))) 
	  {
        containsDigits = true;
        break;
      }
    }

    if (containsDigits) 
	{
      System.out.println("The string contains digits.");
    } 
	else 
    {
      System.out.println("The string does not contain digits.");
    }
  }
}
----------------------------------------------------------------
//program to count capital and small letter from the given String
//public static boolean isUpperCase(char ch)
//public static boolean isLowerCase(char ch)

import java.util.Scanner;
public class Test9
{
public static void main(String[] args) 
{
  Scanner sc = new Scanner(System.in);
  System.out.print("Enter a string: ");
  String str = sc.nextLine();  //RaVi

  int upperCase = 0, lowerCase = 0;    

    for (int i = 0; i < str.length(); i++) 
	{
      char ch = str.charAt(i);    
      
	  if (Character.isUpperCase(ch)) 
	  {
        upperCase++;
      } 
	  else if (Character.isLowerCase(ch)) 
	  {
        lowerCase++;  
       }
    }    
    System.out.println("Uppercase letters: " + upperCase);
    System.out.println("Lowercase letters: " + lowerCase);
  }
}
----------------------------------------------------------------
//Program to count the consonants and vowels in the given String
import java.util.Scanner;
public class Test10
{
public static void main(String[] args) 
{
     Scanner sc = new Scanner(System.in);
     System.out.print("Enter a string: ");
     String str = sc.nextLine();

    int vowels = 0, consonants = 0;

    for (int i = 0; i < str.length(); i++) 
	{
      char c = str.charAt(i);  

      if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||
          c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') 
	  {
        vowels++;
      } 
	  else  
	  {
        consonants++;
      }
    }
    System.out.println("Vowels: " + vowels);
    System.out.println("Consonants: " + consonants);
  }
}
----------------------------------------------------------------
//check a String  is palindrome or not  
import java.util.Scanner;
public class Test11
{
public static void main(String[] args) 
{
  Scanner sc = new Scanner(System.in);
  System.out.print("Enter a string: ");
  String str = sc.nextLine();            // madam

    boolean isPalindrome = true;                    

    for(int i = 0; i < str.length() / 2;   i++) //i=1   i<2  i++    
	{
        if (str.charAt(i) != str.charAt(str.length() - i - 1)) //a != a
		{
           isPalindrome = false;  
           break;
        }
    }

    if (isPalindrome) 
	{
      System.out.println(str + " is a palindrome.");
    } 
	else 
	{
      System.out.println(str + " is not a palindrome.");
    }
  }
}
----------------------------------------------------------------
13-04-2024
-----------
Inner classes in java :
------------------------
In java it is possible to define a class (inner class) inside another class (outer class) called nested class.

In the same way it is also possible to define an interface OR enum OR Annotation inside another interface OR enum OR Annotation is called inner class or nested class.

Inner classes in Java create a strong encapsulation and  HAS-A  relationship between the inner class and its outer class.

An inner class, .class file will be represented by $ symbol.

Advantages of inner class :
--------------------------------
1) It is a way of logically grouping classes that are only used in one place.

2) It is used to achieve encapsulation.

3) It enhance the readability and maintainability of the code.

Types of Inner classes in java :
--------------------------------
There are 4 types of inner classes in java :

1) Member Inner class OR Nested Inner class OR Regular class 
2) Local inner class OR Method local inner class
3) Nested inner class
4) Anonymous inner class.
----------------------------------------------------------------
15-04-2024
-----------
1) Member Inner class OR Nested Inner class OR Regular class :
----------------------------------------------------------------
A non-static class that is created inside a class but outside of a method is called Member Inner class OR Nested Inner class OR Regular class.  

It can be declared with access modifiers like private, default, protected, public, abstract and final.

It is also called as Regular Inner class.

An inner class can also access the private member of outer class.

Note :- The .class file of an inner class will be represented by $ symbol at the time of compilation.

An outer class can be declared as public, abstract and final only.
----------------------------------------------------------------
class Outer 
{
	private int a = 15;

	class Inner 
	{
		public void displayValue() 
		{
			System.out.println("Value of a is " + a);
		}
	}
}
public class Test1
{
	public static void main(String... args)  
	{		
		//Outer mo = new Outer(); //Outer class Object is created
		//Outer.Inner inner = mo.new Inner(); //Inner class object is created

        Outer.Inner inner = new Outer().new Inner();
		inner.displayValue();
	}
}

Note :- It is clear that an inner class can directlty access the 
private data of outer class (Encapsulation)
----------------------------------------------------------------
class MyOuter
{
      private int x = 7;
      public void makeInner()
      {
            MyInner in = new MyInner();
			System.out.println("Inner y is "+in.y);
            in.seeOuter();
      }

      class MyInner
      {
		    private int y = 15;
            public void seeOuter()
            {
                  System.out.println("Outer x is "+x);
            }
      }
}
public class Test2
{
      public static void main(String args[])
      {
            MyOuter m = new MyOuter();
            m.makeInner();   
      } 
}

Note :- It is clear that an inner class can directlty access the 
private data of outer class as well as outer class can also access the private data of inner class. (Encapsulation)
----------------------------------------------------------------
class MyOuter
{
      private int x = 15;
      class MyInner
      {
            public void seeOuter()
            {
                  System.out.println("Outer x is "+x);
            }
      }
}
public class Test3
{
      public static void main(String args[])
      {
		  //Creating inner class object in a single line
           MyOuter.MyInner m = new MyOuter().new MyInner();
			m.seeOuter();
      } 
}
----------------------------------------------------------------
class MyOuter  
{
      static int x = 7;
	  class MyInner
      {
            public static void seeOuter()  //MyInner.seeOuter();
            {
                  System.out.println("Outer x is "+x);
            }
      }
}

public class Test4
{
      public static void main(String args[])
      {
          MyOuter.MyInner.seeOuter();
      } 
}
---------------------------------------------------------------
class Car 
{    
    private String make;
    private String model;
    private Engine engine; 

   public Car(String make, String model, int horsePower) 
   {
        this.make = make;
        this.model = model;
        this.engine = new Engine(horsePower);
    }

   //Inner class
   private class Engine 
   {
      private int horsePower;

       public Engine(int horsePower)
	   {
            this.horsePower = horsePower;
        }

        public void start() 
		{
            System.out.println("Engine started! Horsepower: " + horsePower);
        }

        public void stop() 
	    {
            System.out.println("Engine stopped.");
        }
    }

    public void startCar() 
	{
        System.out.println("Starting " + make + " " + model);
        this.engine.start();
    }

    public void stopCar() 
	{
        System.out.println("Stopping " + make + " " + model);
        this.engine.stop();
    }
}
public class Test5
{

    public static void main(String[] args) {
        
        Car myCar = new Car("Swift", "Desire", 1200);

        myCar.startCar();

        myCar.stopCar();
    }
}

Note : Whenever we start the car, internally engine will be started.
---------------------------------------------------------------
class Laptop 
{
    private String brand;
    private String model;
    private Motherboard motherboard;

    public Laptop(String brand, String model, String motherboardModel, String chipset) 
	{
        this.brand = brand;
        this.model = model;
        this.motherboard = new Motherboard(motherboardModel, chipset);
    }

    
    public void switchOn()
	{
        System.out.println("Turning on " + brand + " " + model);
        this.motherboard.boot();
    }

   //Motherboard inner class
   public class Motherboard 
   {
        private String model;
        private String chipset;

        
        public Motherboard(String model, String chipset) 
		{
            this.model = model;
            this.chipset = chipset;
        }

        
        public void boot() 
		{
            System.out.println("Booting " + brand + " " + model + " with " + chipset + " chipset");
        }
    }
}
public class Test6
{
    public static void main(String[] args) 
	{
        
        Laptop laptop = new Laptop("HP", "ENVY", "IRIS", "Intel");

        laptop.switchOn();
    }
}
---------------------------------------------------------------
class Person
{
    private String name;
    private int age;
    private Heart heart;

    public Person(String name, int age)
	{
        this.name = name;
        this.age = age;
        this.heart = new Heart();
    }

    public void describe() 
	{
        System.out.println("Name: " + name);
        System.out.println("Age: " + age);
        System.out.println("Heart beats per minute: " + heart.getBeatsPerMinute());
    }

    // Inner class representing the Heart
    private class Heart 
	{
        private int beatsPerMinute;

        public Heart() {
            this.beatsPerMinute = 72; 
        }

        public int getBeatsPerMinute() 
		{
            return this.beatsPerMinute;
        }

        public void setBeatsPerMinute(int beatsPerMinute) 
		{
            this.beatsPerMinute = beatsPerMinute;
        }
    }
}
public class Test7
{
    public static void main(String[] args)
	{
        Person person = new Person("Virat", 30);
        person.describe();
    }
}
---------------------------------------------------------------
class University 
{
    private String name;

    public University(String name)
	{
        this.name = name;
    }
    
    public void displayUniversityName()
	{
        System.out.println("University Name: " + name);
    }

    public class Department 
	{
        private String name;
        private String headOfDepartment;

        public Department(String name, String headOfDepartment) 
		{
            this.name = name;
            this.headOfDepartment = headOfDepartment;
        }

        // Method to display department details
        public void displayDepartmentDetails()
		{
			displayUniversityName();
            System.out.println("Department Name: " + name);
            System.out.println("Head of Department: " + headOfDepartment);
            
        }
    }
}
public class Test8
{
    public static void main(String[] args) 
	{
       
        University university = new University("JNTU");

       University.Department cs = university.new Department("Computer Science", "Dr. John");

        University.Department ee = university.new Department("Electrical Engineering", "Dr. Scott");

       
        cs.displayDepartmentDetails();
        ee.displayDepartmentDetails();
    }
}
---------------------------------------------------------------
class OuterClass 
{
	private int x = 200;
	class InnerClass
	{
		public void display()  //Inner class display method
		{
		System.out.println("Inner class display method");
		}
		
		public void getValue()
		{
			display();
			System.out.println("Can access outer private var :"+x);
		}
	}
       
		public void display()  //Outer class display method
		{
			System.out.println("Outer class display");
		}	
}
public class Test9
{
	public static void main(String [] args)
	{
		OuterClass.InnerClass inobj = new OuterClass().new InnerClass();
		inobj.getValue();
		
		new OuterClass().display();
	}
}
----------------------------------------------------------------
class OuterClass 
{
	int x;
	public class InnerClass  //private, def, prot, public, abstract 
	{                        //final
		int x;
	}
}
public class Test10
{
}

----------------------------------------------------------------
2) Method local inner class :
 -------------------------------
 If a class is declared inside the method then it is called  method local inner class.

 We cann't apply any access modifier on method local inner class but they can be marked as abstract and final.

 A local inner class we can't access outside of the method that means the scope of method local inner class within the same method only.
---------------------------------------------------------------
//program on method local inner class
class MyOuter3
{
      private String x = "Outer class private data";

      public void doSttuff()
      { 
           String x = "local variable";  

           class MyInner  //only final and abstract is possible
           {
                 public void seeOuter()
                 {
                      System.out.println("Outer x is "+MyOuter3.this.x);
                      System.out.println("Local variable z is : "+x);
                 }
           }
		  MyInner mi = new MyInner();
            mi.seeOuter();
	   
      }
	   
	 
}
public class Test11
{
      public static void main(String args[])
      {
            MyOuter3 m = new MyOuter3();
            m.doSttuff();  
      } 
}
----------------------------------------------------------------
16-04-2024
-----------
//local inner class we can't access outside of the method
class MyOuter3
{
      private String x = "Outer class Data";

      public void doSttuff()
      { 
           String z = "local variable";  
            class MyInner        
            {
				 String z = "CLASS variable"; 
                 public void seeOuter()
                 {
                      System.out.println("Outer x is "+x);
                      System.out.println("Local variable z is : "+z);
                 }
           }
	  }
		   MyInner mi = new MyInner();
	        mi.seeOuter(); 
		      
      
	     	
	  
}
public class Test12
{
      public static void main(String args[])
      {
            MyOuter3 m = new MyOuter3();
            m.doSttuff();  
      } 
}

Note : Here We will get an error because Method local inner class must be accessible within the same method only.
----------------------------------------------------------------
3) Static Nested Inner class :
---------------------------------
A static inner class which is declared with static keyword inside an outer class is called static Nested inner class.

It cann't access non-static variables and methods  i.e (instance members) of outer class.

For static nested inner class, Outer class object is not required.

If a static nested inner class contains static method then object is not required for inner class. On the other hand if the static inner class contains instance method then we need to create an object for static nested inner class.
---------------------------------------------------------------
//static nested inner class
class BigOuter
{
     static class Nest   //static nested inner class   
     {
          void go()  //Instance method of static inner class
          {
               System.out.println("Hello welcome to static nested class");  
          }  
     }
}
class Test13
{    
      public static void main(String args[])
      {
          BigOuter.Nest n = new BigOuter.Nest();
          n.go();
			
			
      } 
}

---------------------------------------------------------------
class Outer
{  
	   static int x=15;  

	  static class Inner
	  {  
	     void msg()
		{
		System.out.prstaticintln("x value is  "+x);
		}  
	  }
}
class Test14
{  
	public static void main(String args[])
	{  
		Outer.Inner obj=new Outer.Inner();  
		obj.msg();  
	}  
}  
----------------------------------------------------------------
class Outer    
{  
	  static int x = 25;  
	  static class Inner 
	  {  
			static void msg()
				{
					System.out.println("x value is  "+x);					
				}		
	  }	  
}
class Test15
{  
	public static void main(String args[])
	{  
		Outer.Inner.msg();
	}  
}  
---------------------------------------------------------------
class Outer
{  
	  int x=15;  //error (not possible because try to access instance variable)
	  static class Inner
	  {  
			void msg()
				{
					System.out.println("x value is  "+x);
				}  
	  }
}
class Test16
{  
	public static void main(String args[])
	{  
		Outer.Inner obj=new Outer.Inner();  
		obj.msg();  
	}  
}  
----------------------------------------------------------------
4) Anonymous inner class :
------------------------------ 
It is an inner class which is defined inside a method without any name and for this kind of inner class only single Object is created. (Singleton class)

*An anonymous inner class is mainly used for extending a class or implementing an interface that means creating sub type of a class or interface.

*A normal class can implement any number of interfaces but an anonymous inner class can implement only one interface at a time.

A normal class can extend one class and implement any number of interfaces at the same time but an anonymous inner class can extend one class or can implement one interface at a time.

Inside an anonymous inner class we can write static , non static variable, static block and non-static block. Here we can't write abstract method and constructor.
---------------------------------------------------------------
//Anonymous inner class
class Tech
{
       public void tech() 
       {
	      System.out.println("Tech");
       }
}
public class Test17
{     
       public static void main(String... args)
       {
		   

	       Tech a = new Tech()  //Anonymous inner class
			{
				    @Override
					public void tech() 
					{
						 System.out.println("anonymous tech");
					}

                    

			};
			a.tech();	
       }
}
---------------------------------------------------------------
@FunctionalInterface
interface Vehicle
{
	void move();  //SAM(Single Abstract Method)
}

class Test18 
{
	public static void main(String[] args) 
	{
		Vehicle car = new Vehicle()
		{
			@Override
			public void move()
			{
				System.out.println("Moving with Car...");
			}
		};
		car.move();

       Vehicle bike = new Vehicle()
		{
			@Override
			public void move()
			{
				System.out.println("Moving with Bike...");
			}
		};
		bike.move();
	}
}
----------------------------------------------------------------
class Test19 
{
	public static void main(String[] args) 
	{
        //Anonymous class with Runnable
		Runnable r1 = new Runnable()
		{
			
			@Override
			public void run()
			{
                System.out.println("Run method implementation inside Runnable");
			}
		};
             Thread obj = new Thread(r1);
			 obj.start();



        //Anonymous Thread class with reference
		Thread t1 = new Thread()
		{
			@Override
			public void run()
			{
                System.out.println("Anonymous Thread class with reference...");
			}
		};
		t1.start();
		
        //Anonymous Thread class without reference
        new Thread()
		{
			@Override
			public void run()
			{
                System.out.println("Anonymous Thread class without reference...");
			}
		}.start();
	}
}
----------------------------------------------------------------
Collection Framework in java (40 - 45% IQ):
-------------------------------------------
Collections framework is nothing but handling individual Objects(Collection Interface) and Group of objects(Map interface).

We know only object can move from one network to another network.

A collections framework is a class library to handle group of Objects.

It is implemented by using java.util package.

It provides an architecture to store and manipulate group of objects.

All the operations that we can perform on data such as searching, sorting, insertion and deletion can be done by using collections framework because It is the data structure of Java.

The simple meaning of collections is single unit of Objects.
----------------------------------------------------------------

It provides the following sub interfaces :

1) List (Accept duplicate elements)
2) Set (Not accepting duplicate elements)
3) Queue (Storing and Fetching the elements based on some order i.e FIFO)


Collection is an interface in java.util package where as Collections is predefined class which contains various static method available in java.util package available from JDK 1.2v.
----------------------------------------------------------------
Methods of Collection interface :
---------------------------------
a) public boolean add(Object element) :- It is used to add an item/element in the collection.

b) public boolean addAll(Collection c) :- It is used to insert the specified collection elements in the existing collection(For merging the Collection)

c) public boolean retainAll(Collection c) :- It is used to retain all the elements from existing element. (Common Element)


d) public boolean removeAll(Collection c) :- It is used to delete all the elements from the existing collection.

e) public boolean remove(Object element) :- It is used to delete an element from the collection.

f) public int size() :- It is used to find out the size of the Collection.

g) public void clear() :- It is used to clear all the elements at once from the Collection.

All the above methods of Collection interface will be applicable to all the sub interfaces like List, Set and Queue.
----------------------------------------------------------------
List interface :
----------------
It is the sub interface of Collection interface introduced from JDK 1.2v.

It works on the basis of index.

It accepts duplicate elements.

We can perform manual sorting operation on List interface.
----------------------------------------------------------------
List interface Hierachy :
-------------------------
Available in paint diagram 17-Apr-24
----------------------------------------------------------------
Behavior of List interface Specific classes :
----------------------------------------------
1) It works on the basis of index.
2) It can accept homogeneous as well as hetrogeneous types of data.
3) Most of the classes are dynamically growable.
4) It can accept null value.
5) Collection stroes everything in the form of object.
6) By using Generics we can hold type safe collection object.
   It can be hetrogeneous also (Vector<Object>).
7) Sorting operation is possible.
-----------------------------------------------------------------
Methods of List interface :
------------------------------
1) public boolean isEmpty() :- Verify whether List is empty or not

2) public 
void clear() :- Will clear all the elements

3) public int size() :- To get the size of the Collections

4) public void add(int index, Object o) :- Insert the element based on the index position.

5) public boolean addAll(int index, Collection c) :- Insert the Collection based on the index position

6) public Object get(int index) :- To retrieve the element based on the index position

7) public Object set(int index, Object o) :- To override or replace the existing element based on the index position

8) public Object remove(int index) :- remove the element based on the index position

9) public boolean remove(Object element) :-  remove the element based on the object element, It is the Collection interface method extended by List interface 

10) public int indexOf() :- index position of the element

11) public int lastIndex() :- last index position of the element

12) public Iterator iterator() :- To fetch or iterate or retrieve the elements from Collection in forward direction only.

13) public ListIterator listIterator() :- To fetch or iterate or retrieve the elements from Collection in forward and backward direction
---------------------------------------------------------------
19-04-2024
-----------
How many ways we can fetch/Print the Collection Object
-------------------------------------------------------
We can fetch the Collection Object by using 9 ways :

1) By using toString() method of respective Collection class.
2) By using Enumeration interface(JDK 1.0)
3) By using Ordinary for loop
4) By using for Each loop (JDK 1.5)
5) By using Iterator interface (JDK 1.2)
6) By using ListIterator interface (JDK 1.2)
7) BY using Spliterator interface (JDK 1.8)
8) By using forEach(Consumer <T>) (JDK 1.8)
9) By using Method Reference (::) (JDK 1.8)

NOTE : Among all these Enumeration, Iterator, ListIterator and Spliterator are the CURSORS.
-----------------------------------------------------------------
 Enumeration :
----------------
It is a predefined interface available in java.util package from JDK 1.0 onwards(Legacy interface).

We can use Enumeration interface to fetch or retrieve the Objects one by one from the Collection because it is a cursor.

We can create Enumeration object by using elements() method of the legacy Collection class.

public Enumeration elements();   

Enumeration interface contains two methods :
---------------------------------------------------
1) public boolean hasMoreElements() :- It will return true if the Collection is having more elements.

2) public Object nextElement() :- It will return collection object so return type is Object.
------------------------------------------------------------------
Iterator interface :
----------------------
It is a predefined interface available in java.util package available from 1.2 version.

It is used to fetch/retrieve the elements from the Collection in forward direction only because it is also a cursor.

public Iterator iterator();

Example :
-----------
 Iterator itr = v.iterator();

Now, Iterator interface has provided two methods 


public boolean hasNext() :- 

It will verify, the element is available in the next position or not, if available it will return true otherwise it will return false.

public Object next() :- It will return the collection object.
-----------------------------------------------------------------
ListIterator interface :
-------------------------
It is a predefined interface available in java.util package and it is the sub interface of Iterator.

It is used to retrieve the Collection object in both the direction i.e in forward direction as well as in backward direction.

public ListIterator listIterator();

Example :
-----------
ListIterator lit =   v.listIterator();

1) public boolean hasNext() :- 
It will verify the element is available in the next position or not, if available it will return true otherwise it will return false.

2) public Object next() :- It will return the next position collection object.

3) public boolean hasPrevious() :- 
It will verify the element is available in the previous position or not, if available it will return true otherwise it will return false.


4) public Object previous () :- It will return the previous position collection object.

Note :- Apart from these 4 methods we have add(), set() and remove() method in ListIterartor interface
------------------------------------------------------------------
Spliterator interface :
-----------------------
It is a predefined interface available in java.util package from java 1.8 version.

It is a cursor through which we can fetch the elements from the 
Collection [Collection, array, Stream]

It is the combination of hasNext() and next() method.

It is using forEachRemaining(Consumer <T>) method for fetching the 
elements.

By using forEach() method :
--------------------------------
From java 1.8 onwards every collection class provides a method forEach() method, this method takes Consumer functional interface as a  parameter.

-----------------------------------------------------------------
//Program in java that describes how to fetch Collection data by using all 9 ways :

package com.ravi.collection;

import java.util.Enumeration;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.Spliterator;
import java.util.Vector;

public class RetrievingCollectionObject 
{
	public static void main(String[] args)
	{                   
		Vector<String> fruits = new Vector<>();
		fruits.add("Orange");
		fruits.add("Apple");
		fruits.add("Mango");
		fruits.add("Banana");
		fruits.add("Gauva");
		            
		System.out.println("BY USING TOSTRING() METHOD");
		System.out.println(fruits.toString());
		
		System.out.println("BY USING ORDINARY FOR LOOP");
		for(int i = 0; i<fruits.size(); i++)
		{
			String fruit = fruits.get(i);
			System.out.println(fruit);
		}
		
		System.out.println("BY USING FOR  EACH LOOP");
		
		for(String fruit : fruits)
		{
			System.out.println(fruit);
		}
     
		System.out.println("BY USING ENUMERATION INTERFACE");
         
		Enumeration<String> ele = fruits.elements();
		while(ele.hasMoreElements())
		{
			System.out.println(ele.nextElement());
		}
           
		System.out.println("BY USING ITERATOR INTERFACE");
		
		Iterator<String> itr = fruits.iterator();
		while(itr.hasNext())
		{
			System.out.println(itr.next());
		}
		
		System.out.println("BY USING LISTITERATOR INTERFACE");
		
	    ListIterator<String> lst = fruits.listIterator();
		
		System.out.println("IN FORWARD DIRECTION");
		
		while(lst.hasNext())
		{
			System.out.println(lst.next());
		}
		
		System.out.println("IN BACKWARD DIRECTION");
		while(lst.hasPrevious())
		{
			System.out.println(lst.previous());
		}
		
		System.out.println("BY USING SPLITERATOR INTERFACE");
		
		Spliterator<String> spl = fruits.spliterator();
		spl.forEachRemaining(fruit -> System.out.println(fruit));
		
		System.out.println("BY USING FOR EACH METHOD");
		fruits.forEach(fruit -> System.out.println(fruit));
		
		System.out.println("BY USING METHOD REFERENE");
		fruits.forEach(System.out::println);
		
	}

}
----------------------------------------------------------------
How forEach() and forEachRemaining() method is working internally ?
------------------------------------------------------------------
Case 1:
---------
By using Anonymous inner class
-------------------------------

package com.ravi.for_each_method;

import java.util.Vector;
import java.util.function.Consumer;

public class ForEachInternals {

	public static void main(String[] args)
	{
		Vector<String> listOfCity = new Vector<>();
		listOfCity.add("Hyderabad");
		listOfCity.add("Noida");
		listOfCity.add("Pune");
		listOfCity.add("Indore");
		
		//Anonymous inner class 
		Consumer<String> cons = new Consumer<>() 
		{
			@Override
			public void accept(String str) 
			{
				System.out.println(str.toUpperCase());				
			}
		};

		listOfCity.forEach(cons);

		Spliterator<String> spl = listOfCity.spliterator();
	spl.forEachRemaining(cons);
	}

}

-----------------------------------------------------------------
Case 2 :
--------
By using Lambda
----------------
package com.ravi.for_each_method;

import java.util.Spliterator;
import java.util.Vector;
import java.util.function.Consumer;

public class ForEachInternals {

	public static void main(String[] args)
	{
		Vector<String> listOfCity = new Vector<>();
		listOfCity.add("Hyderabad");
		listOfCity.add("Noida");
		listOfCity.add("Pune");
		listOfCity.add("Indore");
		
		//Lambda
		Consumer<String> cons = str ->System.out.println(str.toUpperCase());

		listOfCity.forEach(cons);
		System.out.println("....................");
		
	Spliterator<String> spl = listOfCity.spliterator();
	spl.forEachRemaining(cons);
	
	}

}


------------------------------------------------------------------
Case 3:
--------
Passing Lambda into the method
-------------------------------
package com.ravi.for_each_method;

import java.util.Spliterator;
import java.util.Vector;
import java.util.function.Consumer;

public class ForEachInternals {

	public static void main(String[] args)
	{
		Vector<String> listOfCity = new Vector<>();
		listOfCity.add("Hyderabad");
		listOfCity.add("Noida");
		listOfCity.add("Pune");
		listOfCity.add("Indore");
		
		

		listOfCity.forEach( str ->System.out.println(str.toUpperCase()));
		System.out.println("....................");
		
	Spliterator<String> spl = listOfCity.spliterator();
	spl.forEachRemaining( str ->System.out.println(str.toUpperCase()));
	
	}

}
------------------------------------------------------------------
Method Reference (Introduction) :
---------------------------------
3 files :
---------
Worker.java(I)
---------------
package com.ravi.for_each_method;

public interface Worker 
{
   void work();
}

Employee.java(C)
----------------
package com.ravi.for_each_method;

public class Employee 
{
  public void work()
  {
	  System.out.println("Employee is working");
	  System.out.println("Working in WIPRO ");
  }
}


LambdaToMethodRef.java(C)
--------------------------
package com.ravi.for_each_method;

public class LambdaToMethodRef {

	public static void main(String[] args) 
	{
		//By using Lambda
		Worker w1 = ()-> 
		{
			System.out.println("Employee is working");
			System.out.println("Working in TCS");
		};
		w1.work();
		
		//Method Reference (We can refer to an existing method)
		Worker w2 = new Employee()::work;
		w2.work();

	}

}
-----------------------------------------------------------------
ArrayList :
-----------
public class ArrayList<E>  extends AbstractList<E> implements List<E>, Serializable, Clonable, RandomAccess  

It is a predefined class available in java.util package under List interface from java 1.2v.

It accepts duplicate elements and null values.

It is dynamically growable array.

It stores the elements on index basis so it is simillar to dynamic array.

Initial capacity of ArrayList is 10. The new capacity of Arraylist can be calculated by using the  formula
new capacity = (current capacity * 3)/2 + 1

*All the methods declared inside an ArrayList is not synchronized so multiple thread can access the method of ArrayList. 

*It is highly suitable for fetching or retriving operation when duplicates are allowed and Thread-safety is not required.

It implements List,Serializable, Clonable, RandomAccess interfcaes

Constructor of ArrayList :
----------------------------
In ArrayList we have 3 types of Constructor:
Constructor of ArrayList :
----------------------------
We have 3 types of Constructor in ArrayList

1) ArrayList al1 = new ArrayList();
   Will create ArrayList object with default capacity 10.

2) ArrayList al2 = new ArrayList(int initialCapacity);
   Will create an ArrayList object with user specified Capacity

3) ArrayList al3 = new ArrayList(Collection c)
   We can copy any Collection interface implemented class data to the current object   reference (Coping one Collection data to another) 

Programs :
-----------
package com.ravi.arraylist;

import java.util.*;
public class ArrayListDemo
{
	public static void main(String... a)
	{
		ArrayList<String> arl = new ArrayList<>();//Generic type		
		arl.add("Apple");   
		arl.add("Orange");
		arl.add("Grapes");
		arl.add("Mango");
		arl.add("Guava");
		arl.add("Mango");
		
		Collections.sort(arl);
		System.out.println("In Ascending Order");
		arl.forEach(System.out::println);
		
		Collections.reverse(arl);
		System.out.println("In reverse Order");
		arl.forEach(System.out::println);
		
			
	}
}
------------------------------------------------------------------
//How to work with Custom Object

package com.ravi.arraylist;

import java.util.ArrayList;

record Product(int productId, String productName)
{
	
}


public class ArrayListDemo1 {

	public static void main(String[] args) 
	{
	  ArrayList<Product> al = new ArrayList<>();
	  al.add(new Product(333, "Camera"));
	  al.add(new Product(111, "Laptop"));
	  al.add(new Product(222, "Mobile"));
	  al.add(new Product(444, "Apple phone"));
	  
	  al.forEach(System.out::println);

	}

}
-----------------------------------------------------------------
22-04-2024
-----------
import java.util.*;
public class ArrayListDemo
{
	public static void main(String... a)
	{
		ArrayList<String> arl = new ArrayList<>();//Generic type		
		arl.add("Apple");   
		arl.add("Orange");
		arl.add("Grapes");
		arl.add("Mango");
		arl.add("Guava");
		arl.add("Mango");

		System.out.println("Contents :"+arl); //toString()  [Apple,....]

		arl.remove(2); //based on the index position [List]
		arl.remove("Guava"); //based on the Object [Collection]

		System.out.println("Contents After Removing :"+arl);
		System.out.println("Size of the ArrayList:"+arl.size());

		Collections.sort(arl); 
		
	    arl.forEach(System.out::println);	
	}
}
----------------------------------------------------------------
package com.ravi.arraylist;

//Program to merge and retain of two collection 
import java.util.*;
public class ArrayListDemo2
	{
		public static void main(String args[]) 
		{ 
		  ArrayList<String> al1=new ArrayList<>();
		  al1.add("Ravi");
		  al1.add("Rahul");
		  al1.add("Rohit");		  
		  
		  ArrayList<String> al2=new ArrayList<>();
		  al2.add("Pallavi");
		  al2.add("Sweta");
		  al2.add("Puja");		  

		  al1.addAll(al2);  

        al1.forEach(x -> System.out.println(x.toUpperCase()));

        System.out.println(".................................");

		  ArrayList<String> al3=new ArrayList<>();
		  al3.add("Ravi");
		  al3.add("Rahul");
		  al3.add("Rohit");		  
		  
		  ArrayList<String> al4=new ArrayList<>();
		  al4.add("Pallavi");
		  al4.add("Rahul");
		  al4.add("Raj");
		  
		  al3.retainAll(al4);  

        al3.forEach(x -> System.out.println(x));		  
   }
}
----------------------------------------------------------------
How to create immutable List :
------------------------------
We can create immutable list by using following two ways :

1) Arrays.asList(T... x) : asList() is a predefined static method of Arrays class which creates fixed size arrays so, we can't perform any modification operation later. 

2) List.of() : It came from java 9, of is static method of List 
intertface which creates immutable list so further we can't perform any modification.

In the both the methods if we try to perform any modification
operation then we will get java.lang.UnsupportedOperationException
---------------------------------------------------------------
package com.ravi.arraylist;

import java.util.Arrays;
import java.util.List;

public class ImmutableList {

	public static void main(String[] args) 
	{
		List<Integer> listOfNum = Arrays.asList(1,2,3,4,5,6,7,8);
		listOfNum.add(9); //java.lang.UnsupportedOperationException
		
		List<Integer> listOfNumbers = List.of(1,2,3,4,5,6,7);
		listOfNumbers.add(8); //java.lang.UnsupportedOperationException
	}
}
---------------------------------------------------------------
//Program to fetch the elements in forward and backward 
//direction using ListIterator interface

package com.ravi.arraylist;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.ListIterator;

public class ArrayListDemo3   
{                             
public static void main(String args[])
  {
	 List<String> listOfName = Arrays.asList("Rohit","Akshar","Pallavi","Sweta"); 
	 
	 Collections.sort(listOfName);
	 
	 //Fetching the data in both the direction
	 ListIterator<String> lst = listOfName.listIterator();
	 
	 System.out.println("In Forward Direction..");	 
	 while(lst.hasNext())
	 {
		System.out.println(lst.next()); 
	 }
	 System.out.println("In Backward Direction..");	 
	 while(lst.hasPrevious())
	 {
		System.out.println(lst.previous()); 
	 }
	 
  }
}
----------------------------------------------------------------
//Serialization and De-serialization on ArrayList Object
package com.ravi.arraylist;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.ArrayList;

public class ArrayListDemo4
{  
  public static void main(String [] args) throws IOException, Exception 
  {
    ArrayList<String> al = new ArrayList<>();
    al.add("B.Tech");
    al.add("M.Tech");
    al.add("BCA");
    al.add("MCA");
    al.add("BE");
    al.add("B.Pharma");
    
    var fos = new FileOutputStream("C:\\Batch28\\Course.txt");
    var oos = new ObjectOutputStream(fos);
    
    try(fos; oos)
    {
    	oos.writeObject(al);
    	System.out.println("Object Stored Successfully");
    }
    catch(Exception e)
    {
    	e.printStackTrace();
    }
    
    
    var fin = new FileInputStream("C:\\Batch28\\Course.txt");
    var ois = new ObjectInputStream(fin);
    
    try(ois;fin)
    {
    	@SuppressWarnings("unchecked")
		ArrayList<String> arl =(ArrayList<String>)ois.readObject();        
        System.out.println(arl);
    }
    
    
  }
       
}         
----------------------------------------------------------------
//Serialization and De-serialization on ArrayList Object using Product record

package com.ravi.arraylist;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.ArrayList;

record Prod(int pid, String pname) implements Serializable
{
	
}

public class ArrayListSerialization 
{
	public static void main(String[] args) throws Exception
	{
		ArrayList<Prod> al = new ArrayList<>();
		al.add(new Prod(1, "Camera"));
		al.add(new Prod(2, "Mobile"));
		al.add(new Prod(3, "Laptop"));
		
		var fos = new FileOutputStream("C:\\Batch28\\Product.txt");
	    var oos = new ObjectOutputStream(fos);
	    
	    try(fos; oos)
	    {
	    	oos.writeObject(al);
	    	System.out.println("Object Stored Successfully");
	    }
	    catch(Exception e)
	    {
	    	e.printStackTrace();
	    }
	    
	    
	    var fin = new FileInputStream("C:\\Batch28\\Product.txt");
	    var ois = new ObjectInputStream(fin);
	    
	    try(ois;fin)
	    {
	    	@SuppressWarnings("unchecked")
			ArrayList<Prod> arl =(ArrayList<Prod>)ois.readObject();        
	        System.out.println(arl);
	    }
	    
	}

}

Note :- Here Prod record must implements java.io.Serializable.
In the last program String class already implementing java.io.
Serializable.
---------------------------------------------------------------
public void ensureCapacity(int minimumCapacity) :
--------------------------------------------------
It is a predefined method of ArrayList class, by using this method we can resize the capacity of ArrayList Object.

Here by specifying the parameter it ensures that it can hold at least the number of elements specified by the minimum capacity argument.

ArrayList class does not provide capacity() method support.

package com.ravi.arraylist;

import java.util.ArrayList;
import java.util.LinkedList;

public class ArrayListDemo5
{
	public static void main(String[] args) 
	{		    
		ArrayList<String> city= new ArrayList<>();
		
		
		city.ensureCapacity(3); //resize the capacity of Arraylist	
		city.add("Hyderabad");
		city.add("Mumbai");
		city.add("Delhi"); 
		

		city.add("Kolkata");
		System.out.println("ArrayList: " + city);		
	 }
}
----------------------------------------------------------------
package com.ravi.arraylist;

//Program on ArrayList that contains null values as well as we can pass the element based on the index position
import java.util.ArrayList;
import java.util.LinkedList;
public class ArrayListDemo6
{
	public static void main(String[] args) 
	{
		ArrayList<Object> al = new ArrayList<>(); //Generic type
		al.add(12);
		al.add("Ravi");
		al.add(12);		
		al.add(3,"Hyderabad"); //add(int index, Object o)method of List interface
		al.add(1,"Naresh");
		al.add(null);
		al.add(11);
		System.out.println(al);  //12 Naresh Ravi  12  Hyderabad
	}
}
---------------------------------------------------------------
package com.ravi.arraylist;

import java.util.ArrayList;
import java.util.List;

class Professor
{
    private String name;
    private String specialization;

    public Professor(String name, String specialization) 
    {
        this.name = name;
        this.specialization = specialization;
    }

    public String getName() 
    {
        return name;
    }

    public String getSpecialization() 
    {
        return specialization;
    }
}

class Department 
{
    private String name;
    private final List<Professor> professors; // Department "HAS-A" relationship with Professor

    public Department(String name) 
    {
        this.name = name;
        this.professors = new ArrayList<>();
    }

    public void addProfessor(Professor prof)
    {
        professors.add(prof);
    }

    public String getName() 
    {
        return name;
    }

    public List<Professor> getProfessors() 
    {
        return professors;
    }
}

public class ArrayListDemo7
{
    public static void main(String[] args) 
    {
        Professor prof1 = new Professor("Ravi", "Java");
        Professor prof2 = new Professor("Rahul", "Python");
        Professor prof3 = new Professor("Samir", ".Net");
        
        Department csd = new Department("Computer Science");
        csd.addProfessor(prof1);
        csd.addProfessor(prof2);
        csd.addProfessor(prof3);
        
        // Accessing properties through the "HAS-A" relationship
        System.out.println("Department Name: " + csd.getName());

        System.out.println("Professors in " + csd.getName() + ":");
               
        csd.getProfessors().forEach(prof ->System.out.println("-> " + prof.getName() + " (" + prof.getSpecialization() + ")") );
        
    }
}
--------------------------------------------------------------
23-04-2024
-----------
Time Complexcity of ArrayList :
-------------------------------
The time complexcity of ArrayList to insert and delete an element from the middle would be O(n) because 'n' number of elements will be re-located so it is not a good choice to perform insertion and deletion operation in the middle of the List. 

On the other hand time complexcity of ArrayList to retrieve an element from the List would be O(1) because by using get(int index) method we can retrieve the element randomly by using the time complexcity O(1) [It implements RandomAccess interface]

[23-APRIL-24]

To avoid this we introduced LinkedList.
---------------------------------------------------------------
LinkedList :
------------
public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, Serializable

It is a predefined class available in java.util package under List interface.

It is ordered by index position like ArrayList except the elements (nodes) are doubly linked to one another. This linkage provide us new method for adding and removing the elements from the middle of LinkedList.

*The important thing is, LikedList may iterate more slowely than ArrayList but LinkedList is a good choice when we want to insert or delete the elements frequently in the list.

From jdk 1.6 onwards LinkedList class has been enhanced to support basic queue operation by implementing Deque<E> interface.

LinkedList methods are not synchronized.


ArrayList is using Array data structure but LinkedList class is using LinkedList data structure.


Constructor:
-------------
It has 2 constructors 

1) LinkedList list1 = new LinkedList();
    It will create a LinkedList object with 0 capacity.

2) LinkedList list2 = new LinkedList(Collection c);
    Interconversion between the collection

Methods of LinkedList class:
-------------------------------
1) void addFirst(Object o)
2) void addLast(Object o)

3) Object getFirst()
4) Object getLast()

5) Object removeFirst()
6) Object removeLast()

Note :- It stores the elements in non-contiguous memory location.           
	   
	   The time complexcity for insertion and deletion is  O(1)

	   The time complexcity for seraching O(n)
----------------------------------------------------------------
package com.ravi.linked_list;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
public class LinkedListDemo
{
 public static void main(String args[])
 { 
      List<Object> list=new LinkedList<>();
	  list.add("Ravi");
	  list.add("Vijay");
	  list.add("Ravi");
	  list.add(null);
	  list.add(42);
	  
	  System.out.println("1st Position Element is :"+list.get(3));

	  //Iterator interface 
	  
	   Iterator<Object> itr = list.iterator();
	   itr.forEachRemaining(System.out::println); //JDK 1.8
	   
	  
	 
  }
}
----------------------------------------------------------------
package com.ravi.linked_list;

import java.util.*;
public class LinkedListDemo1
{
      public static void main(String args[])
      {
           LinkedList<String> list= new LinkedList<>(); //generic
           list.add("Item 2");//2
           list.add("Item 3");//3
           list.add("Item 4");//4
           list.add("Item 5");//5
           list.add("Item 6");//6
           list.add("Item 7");//7
           
           list.add("Item 9"); //10

           list.add(0,"Item 0");//0
           list.add(1,"Item 1"); //1

           list.add(8,"Item 8");//8
		   list.add(9,"Item 10");//9
            System.out.println(list);
			
			  list.remove("Item 5"); 
			  
			  System.out.println(list);
			  
			    list.removeLast(); 
			    System.out.println(list);
			 
			    list.removeFirst(); 
			    System.out.println(list);
			
			  list.set(0,"Ajay"); //set() will replace the existing value
			  list.set(1,"Vijay"); 
			  list.set(2,"Anand"); 
			  list.set(3,"Aman");
			  list.set(4,"Suresh"); 
			  list.set(5,"Ganesh");
			  list.set(6,"Ramesh");
			  list.forEach(x -> System.out.println(x)); 
			 		
			
      } 
}
----------------------------------------------------------------
package com.ravi.linked_list;

//Methods of LinkedList class
import java.util.LinkedList;
public class LinkedListDemo2
{
    public static void main(String[] argv) 
    {
          LinkedList<String> list = new LinkedList<>();
          
          list.addFirst("Ravi");  
          list.add("Rahul"); 
          list.addLast("Anand");	
          
          System.out.println(list.getFirst()); 
          System.out.println(list.getLast()); 
          
          list.removeFirst();
          list.removeLast(); 
          
          System.out.println(list); 
    }
}
---------------------------------------------------------------
24-04-2024
----------
//ListIterator methods [add(), set() and remove()]
package com.ravi.linked_list;
//ListIterator methods
import java.util.*;
public class LinkedListDemo3 
{
	public static void main(String[] args) 
	{
		LinkedList<String> city = new LinkedList<> ();
         city.add("Kolkata");
		 city.add("Bangalore");
		 city.add("Hyderabad");
		 city.add("Pune");
		 System.out.println(city);   

		ListIterator<String> lt = city.listIterator();

       while(lt.hasNext())
		  {
			String cityName =  lt.next();

			if(cityName.equals("Kolkata"))
			{
                 lt.remove();
			}
			else if(cityName.equals("Hyderabad"))
			{
                 lt.add("Ameerpet");
			}
			else if(cityName.equals("Pune"))
			{
                 lt.set("Mumbai");
			}
		}
		city.forEach(System.out::println);
	}
}
---------------------------------------------------------------
package com.ravi.linked_list;

//Insertion, deletion, displaying and exit

import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

public class LinkedListDemo4
{
 public static void main(String[] args)
	{
      List<Integer> linkedList = new LinkedList<>();
      Scanner scanner = new Scanner(System.in);

        while (true) 
		{
          System.out.println("Linked List: " + linkedList); 
          System.out.println("1. Insert Element");
          System.out.println("2. Delete Element");
		  System.out.println("3. Display Element");
          System.out.println("4. Exit");
          System.out.print("Enter your choice: ");

          int choice = scanner.nextInt();
          switch (choice) 
			{
              case 1: 
                  System.out.print("Enter the element to insert: ");
                  int elementToAdd = scanner.nextInt();
                  linkedList.add(elementToAdd);
                  break;
              case 2:
                  if (linkedList.isEmpty()) 
					{
                      System.out.println("Linked list is empty. Nothing to delete.");
                  } 
					else 
					{
                      System.out.print("Enter the element to delete: ");
                      int elementToDelete = scanner.nextInt();
             boolean remove= linkedList.remove(Integer.valueOf(elementToDelete));
                      
                       if(remove)
                       {
                    	   System.out.println("Element "+elementToDelete+ " is deleted Successfully" );
                       }
                       else
                       {
                    	   System.out.println(elementToDelete+" not available is the LinkedList");
                       }
                    
                  }
                  break;
				case 3:
					System.out.println("Elements in the linked list.");
                   System.out.println(linkedList);
				     break;
              case 4:
                  System.out.println("Exiting the program.");
                  scanner.close();
                  System.exit(0);
              default:
                  System.out.println("Invalid choice. Please try again.");
          }
      }
  }
}
---------------------------------------------------------------
package com.ravi.linked_list;

import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;

public class LinkedListDemo5 {

	public static void main(String[] args) 
	{
		List<String> listOfName = Arrays.asList("Ravi","Rahul","Ankit", "Rahul");
		
		LinkedList<String> list = new LinkedList<>(listOfName); 
		list.forEach(System.out::println);
		System.out.println(".......");
		
	}

}
--------------------------------------------------------------
import java.util.LinkedList;
import java.util.Iterator;
import java.util.List;

class Dog 
{
      private String name;
      Dog(String n) 
      {
           name = n;
      }

	public String getName()
	{
		return this.name;
	}

    public String toString()
	{
		return this.name;
	}
}
public class LinkedListDemo5
{
       public static void main(String[] args)
       {
             List<Dog> d = new LinkedList<>();
             Dog dog = new Dog("Tiger");
             d.add(dog);
             d.add(new Dog("Tommy"));
             d.add(new Dog("Rocky"));

             Iterator<Dog> i3 = d.iterator();
		    i3.forEachRemaining(x -> System.out.println(x.getName().toUpperCase())); //java 8      


             System.out.println("size " + d.size());
             System.out.println("Get 1st Position Object " + d.get(1).getName());
             
            
        }
}
--------------------------------------------------------------
import java.util.Deque;
import java.util.LinkedList;

public class LinkedListDemo6
{
    public static void main(String[] args) 
		{
        // Create a LinkedList and treat it as a Deque
        Deque<String> deque = new LinkedList<>();

        // Adding elements to the front of the deque
        deque.addFirst("Ravi");
        deque.addFirst("Raj");   //Raj  Ravi Pallavi Sweta

        // Adding elements to the back of the deque
        deque.addLast("Pallavi");   
        deque.addLast("Sweta");

        
        System.out.println("Deque: " + deque);  //Raj Ravi P  S

       
        String first = deque.removeFirst();
        String last = deque.removeLast();

       
        System.out.println("Removed first element: " + first);
        System.out.println("Removed last element: " + last);
        System.out.println("Updated Deque: " + deque);
    }
}

--------------------------------------------------------------
Vector :
--------
public class Vector<E> extends AbstractList<E>  implements List<E>, Serializable, Clonable, RandomAccess

Vector is a predefined class available in java.util package under List interface. 

Vector is always from java means it is available from jdk 1.0 version.

Vector and Hashtable, these two classes are available from jdk 1.0, remaining Collection classes were added from 1.2 version. That is the reason Vector and Hashtable are called legacy(old) classes.

The main difference between Vector and ArrayList is, ArrayList methods are not synchronized so multiple threads can access the method of ArrayList where as on the other hand most the methods are synchronized in Vector so performance wise Vector is slow.

*We should go with ArrayList when Threadsafety is not required on the other hand we should go with Vector when we need ThreadSafety for reterival operation.

It also stores the elements on index basis.It is dynamically growable with initial capacity 10. The next capacity will be 20 i.e double of the first capacity.

new capacity = current capacity * 2;

It implements List, Serializable, Clonable, RandomAccess interfaces.

Constructors in Vector :
-------------------------
We have 4 types of Constructor in Vector

1) Vector v1 = new Vector();        
     It will create the vector object with default capacity is 10        
    
2) Vector v2 = new Vector(int initialCapacity);     
     Will create the vector object with user specified capacity.

3) Vector v3 = new Vector(int initialCapacity, int capacityIncrement);     
     Eg :-     Vector v = new Vector(1000,5);

     Initially It will create the Vector Object with initial capacity 1000 and then when  the capacity will be full then increment by 5 so the next capacity would be 1005, 1010 and so on.

 4) Vector v4 = new Vector(Collection c);
    We can achieve loose coupling.
---------------------------------------------------------------
//Performance comparison of ArrayList and Vector class

package com.ravi.performance;

import java.util.ArrayList;
import java.util.Deque;
import java.util.Vector;

public class PerformanceComparison 
{
	public static void main(String[] args) 
	{
		long startTime = System.currentTimeMillis();
		ArrayList<Integer> al = new ArrayList<>();
		for(int i=0; i<1000000; i++)
		{
			al.add(i);
		}
		long endTime = System.currentTimeMillis();
		System.out.println("Time Taken by ArrayList class :"+(endTime-startTime)+" ms");
		
		 
		startTime = System.currentTimeMillis();
		Vector<Integer> v = new Vector<>();
		for(int i=0; i<1000000; i++)
		{
			v.add(i);
		}
		endTime = System.currentTimeMillis();
		System.out.println("Time Taken by Vector class :"+(endTime-startTime)+" ms");

	}

}
--------------------------------------------------------------
//Vector Program on capacity
import java.util.*;
public class VectorExampleDemo1
{
	public static void main(String[] args) 
	{
		Vector<Integer> v = new Vector<>(100,5);  //initial capacity is 100
		System.out.println("Initial capacity is :"+v.capacity());

        for(int i =0; i<100; i++)
		{
             v.add(i);
		}

		System.out.println("After adding 100 elements  capacity is :"+v.capacity());
		v.add(101);		
		System.out.println("After adding 101th elements  capacity is :"+v.capacity());

		System.out.println(v);
	}
}
--------------------------------------------------------------
package com.ravi.performance;

import java.util.Vector;

record Product(Integer productId, String productName, Double price)
{
	
}
public class VectorExampleDemo2 {

	public static void main(String[] args) 
	{
		Vector<Product> v = new Vector<>();
		v.add(new Product(1, "Camera",74000D));
		v.add(new Product(2, "Laptop",94000D));
		v.add(new Product(3, "Mobile",44000D));
		v.add(new Product(4, "HeadPhone",12000D));
		
		//Fetch all the product whose price is more than 30K
		v.stream().filter(p -> p.price()>=30000).forEach(System.out::println);
		

	}

}
---------------------------------------------------------------
25-04-2024
-----------
package com.ravi.vector;

import java.util.Scanner;
import java.util.Vector;

public class VectorDemo2
{
    public static void main(String[] args) 
    {        
        Vector<String> toDoList = new Vector<>();

        Scanner scanner = new Scanner(System.in);

        int choice;
        do 
        {
            System.out.println("ToDo List Menu:");
            System.out.println("1. Add Task");
            System.out.println("2. View Tasks");
            System.out.println("3. Mark Task as Completed");
            System.out.println("4. Exit");
            System.out.print("Enter your choice: ");

            choice = scanner.nextInt();
            scanner.nextLine(); 

            switch (choice) 
            {
                case 1:
                    // Add Task
                    System.out.print("Enter task description: ");
                    String task = scanner.nextLine();
                    toDoList.add(task);
                    System.out.println("Task added successfully!\n");
                    break;
                case 2:
                    // View Tasks
                    System.out.println("ToDo List:");
                    for (int i = 0; i < toDoList.size(); i++) {
             System.out.println((i + 1) + ". " + toDoList.get(i));
                    }
                    System.out.println();
                    break;
                case 3:
                    // Mark Task as Completed
                    System.out.print("Enter task number to mark as completed: ");
                    int taskNumber = scanner.nextInt();
                    if (taskNumber >= 1 && taskNumber <= toDoList.size()) 
                    {
                        String completedTask = toDoList.remove(taskNumber - 1);
                        System.out.println("Task marked as completed: " + completedTask + "\n");
                    } else {
                        System.out.println("Invalid task number!\n");
                    }
                    break;
                case 4:
                    System.out.println("Exiting ToDo List application. Goodbye!");
                    break;
                default:
                    System.out.println("Invalid choice. Please enter a valid option.\n");
            }

        } while (choice != 4);

       
        scanner.close();
    }
}
----------------------------------------------------------------
package com.ravi.vector;
//Array To Collection
import java.util.*;
public class VectorDemo3
{
	public static void main(String args[])
	{
		Vector<Integer> v = new Vector<>();  
		
		int x[]={22,20,10,40,15,58};
   
        //Adding array values to Vector
		for(int i=0; i<x.length; i++)
		{
			v.add(x[i]);
		}		
		Collections.sort(v);
		System.out.println("Maximum element is :"+Collections.max(v));
		System.out.println("Minimum element is :"+Collections.min(v));
		System.out.println("Vector Elements :");
		v.forEach(y -> System.out.println(y));
		System.out.println(".....................");
		Collections.reverse(v);
		v.forEach(y -> System.out.println(y));
	}
}
-----------------------------------------------------------------
Removing elements from Vector class based on the index and Object by using legacy class method 

package com.ravi.vector;

import java.util.Vector;

public class VectorDemo5
{
  public static void main(String[] args) 
  {
	Vector<Integer> v = new Vector<>();
	v.addElement(12);
	v.addElement(18);
	v.addElement(20);
	
	v.removeElement(Integer.valueOf(18)); //based on the object
	v.removeElementAt(0); //based on the index
	
	System.out.println(v);
  }
}
-----------------------------------------------------------------
Stack :
------
public class Stack<E> extends Vector<E>

It is a predefined class available in java.util package. It is the sub class of Vector class introduced from JDK 1.0 so, It is also a legacy class. 

It is a linear data structure that is used to store the Objects in LIFO (Last In first out) order.

Inserting an element into a Stack is known as push operation  where as extracting an element from the top of the stack is known as pop operation.

It throws an exception called EmptyStackException, if Stack is empty and we want to fetch the element.

It has only one constructor as shown below

Stack s = new Stack();

------------------------------------------------------------------------------------
Methods :
----------
E push(Object o) :- To insert an element in the bottom of the Stack.

E pop() :- To remove and return the element from the top of the Stack.

E peek() :- Will fetch the element from top of the Stack without removing.

boolean empty() :- Verifies whether the stack is empty or not (return type is boolean)

int search(Object o) :- It will search a particular element in the Stack and it returns OffSet position (int value). If the element is not present in the Stack it will return -1
-----------------------------------------------------------------
//Program to insert and fetch the elements from stack
package com.ravi.stack;
import java.util.*;
public class Stack1
{
      public static void main(String args[])
      {
            Stack<Integer> s = new Stack<>();
            try
            {     s.push(12);
                  s.push(15);
				  s.push(22);
				  s.push(33);
				  s.push(49);				  
				  System.out.println("After insertion elements are :"+s); 

                  System.out.println("Fetching the elements using pop method");
                  System.out.println(s.pop());
                  System.out.println(s.pop()); 
                  System.out.println(s.pop());  
                  System.out.println(s.pop());  
                  System.out.println(s.pop());
                  
                  
				  	
	 				 				  
				  System.out.println("After deletion elements are :"+s); //[]
				  System.out.println("Is the Stack empty ? :"+s.empty());  
              }
			catch(EmptyStackException e)
			{
			   e.printStackTrace();
			} 
      }
}
----------------------------------------------------------------
//add(Object obj) is the method of Collection
package com.ravi.stack;
import java.util.*;
public class Stack2
{
      public static void main(String args[])
      {
            Stack<Integer> st1 = new Stack<>();
            st1.add(10);
            st1.add(20);      
            st1.forEach(x -> System.out.println(x));

            Stack<String> st2 = new Stack<>();
            st2.add("Java");  
            st2.add("is");
            st2.add("programming");
            st2.add("language"); 
            st2.forEach(x -> System.out.println(x));

            Stack<Character> st3 = new Stack<>();
            st3.add('A');  
            st3.add('B');
            st3.forEach(x -> System.out.println(x));

            Stack<Double> st4 = new Stack<>();
            st4.add(10.5);
            st4.add(20.5);               
            st4.forEach(x -> System.out.println(x));          
      }  
}

Note :- add(Object obj) method is available in Collection interface overridden by Vector class so it is available in Stack class.
-----------------------------------------------------------------
package com.ravi.stack;
import java.util.Stack;  

public class Stack3
{  
	public static void main(String[] args)   
		{  
			Stack<String> stk= new Stack<>();  
			stk.push("Apple");  
			stk.push("Grapes");  
			stk.push("Mango");  
			stk.push("Orange");  
			System.out.println("Stack: " + stk);  
			
			String fruit = stk.peek(); 			
			System.out.println("Element at top: " + fruit);  
			System.out.println("Stack elements are : " + stk); 
		}  
}  
-----------------------------------------------------------------
//Searching an element in the Stack
package com.ravi.stack;
import java.util.Stack;  
public class Stack4
{  
	public static void main(String[] args)   
		{  
			Stack<String> stk= new Stack<>();  
			stk.push("Apple");  
			stk.push("Grapes");  
			stk.push("Mango"); 					
			System.out.println("Offset Position is : " + stk.search("Mango")); //1			
			System.out.println("Offser Position is : " + stk.search("Banana")); //-1
		    System.out.println("Is stack empty ? "+stk.empty());	//false
			
			System.out.println("Index Position is : " + stk.indexOf("Mango")); //2
		}  
}  
-----------------------------------------------------------------
Set(I)
-------
Set interface is the sub interface of Collection(I) which came from JDK 1.2v

Set interface never accept duplicate elements, Here internally equals(Object obj) method is working to verify two object are identical or not, if identical then it will accept only 1.

Set intreface does not use any indexing technique.

ListIterator interface does not work with Set interface.

Set interface uses methods of Collection interface as well as It has more methods from java 9.
-----------------------------------------------------------------
Set interface Hierarchy :
--------------------------
Available in the paint diagram (25-APRIL)
-----------------------------------------------------------------
HashSet (UNSORTED, UNORDERED , NO DUPLICATES)
---------------------------------------------
public class HashSet<E> extends AbstractSet<E> implements Set<E>, Clonabale, Serializable

It is a predefined class available in java.util package under Set interface and introduced from JDK 1.2V.

It is an unsorted and unordered set.  

It accepts hetrogeneous kind of data.

*It uses the hashcode of the object being inserted into the Collection. Using this hashcode it finds the bucket location.

It doesn't contain any duplicate elements as well as It does not maintain any order while iterating the elements from the collection.

It can accept null value.

HashSet methods are not synchronized.

HashSet is used for fast searching operation.

It contains 4 types of constructors 
1) HashSet hs1 = new HashSet();
    It will create the HashSet Object with default capacity is 16. The default load fator or Fill Ratio is 0.75   (75% of HashSet is filled up then new HashSet Object will be created having double capacity)

2) HashSet hs2 = new HashSet(int initialCapacity);
    will create the HashSet object with user specified capacity


3) HashSet hs3 = new HashSet(int initialCapacity, float loadFactor);
    we can specify our own initialCapacity and loadFactor(by default load factor is 0.75)

4) HashSet hs = new HashSet(Collection c);
    Interconversion of Collection
 ---------------------------------------------------------------
 //Unsorted, Unordered and no duplicates
import java.util.*;
public class HashSetDemo 
{
 public static void main(String args[])
 { 
	    HashSet<Integer> hs = new HashSet<>();
		hs.add(67); 
		hs.add(89);
		hs.add(33);
		hs.add(45);
		hs.add(12);
		hs.add(35);
		hs.add(35); 

		
		hs.forEach(str-> System.out.println(str));
	}
}
-----------------------------------------------------------------
import java.util.*;
public class HashSetDemo1
{
      public static void main(String[] argv) 
      {
      HashSet<String> hs=new HashSet<>();	  
	  hs.add("Ravi");
	  hs.add("Vijay");
	  hs.add("Ravi");
	  hs.add("Ajay");
	  hs.add("Palavi");
	  hs.add("Sweta");
	  hs.add(null);
	  hs.add(null);
	  hs.forEach(str -> System.out.println(str));

      }
}

By defualt hashCode() value of null is 0, bacause we can't call hashCode() method on null, otherwise we will get NPE.
-----------------------------------------------------------------
//Finding Custom hashcode for String object

package com.ravi.basic;

public class CustomStringHashCode 
{
    public static int customHashCode(String str) 
    {
        if (str == null) 
        {
            return 0; // defualt value for null is 0
        }

        int hashCode = 0;

        for (int i = 0; i < str.length(); i++) 
        {
            char charValue = str.charAt(i);
            hashCode = 31 * hashCode + charValue;
        }

        return hashCode;
    }

    public static void main(String[] args) 
    {
        String exampleString = "Hyd";
        
        // Using the built-in hashCode method
        int hashCodeBuiltIn = exampleString.hashCode();
        System.out.println("Built-in hashCode: " + hashCodeBuiltIn);

        // Using the customHashCode method
        int customHashCode = customHashCode(exampleString);
        System.out.println("Custom hashCode: " + customHashCode);
    }
}
-----------------------------------------------------------------
//add() method return type is boolean

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class HashSetDemo2 {

	public static void main(String[] args) 
	{
		boolean []arr = new boolean[5];
		
		Set<Object> set = new HashSet<>();
		arr[0] = set.add(12);
        arr[1]  = set.add(13);
        arr[2] = set.add("ravi");
        arr[3] = set.add(12);
        arr[4] = set.add(new String("NIT"));
        System.out.println(Arrays.toString(arr));
        
		
        if(set.contains("NIT"))
        {
        	System.out.println("NIT object is available");
        }
        else
        {
        	System.out.println("NIT object is not available");
        }
        System.out.println("..............");
        set.forEach(System.out::println); 
	}

}
-----------------------------------------------------------------
//add, delete, display and exit
import java.util.HashSet;
import java.util.Scanner;

public class HashSetDemo3
{
    public static void main(String[] args) 
		{
        HashSet<String> hashSet = new HashSet<>();
        Scanner scanner = new Scanner(System.in);

        while (true) 
		{
            System.out.println("Options:");
            System.out.println("1. Add element");
            System.out.println("2. Delete element");
            System.out.println("3. Display HashSet");
            System.out.println("4. Exit");

            System.out.print("Enter your choice (1/2/3/4): ");
            int choice = scanner.nextInt();

            switch (choice) 
			{
                case 1:
                    System.out.print("Enter the element to add: ");
                    String elementToAdd = scanner.next();
                    if (hashSet.add(elementToAdd)) 
					{
                        System.out.println("Element added successfully.");
                    } 
					else
					{
                        System.out.println("Element already exists in the HashSet.");
                    }
                    break;
                    case 2:
                    System.out.print("Enter the element to delete: ");
                    String elementToDelete = scanner.next();
                    if (hashSet.remove(elementToDelete)) 
					{
                        System.out.println("Element deleted successfully.");
                    } 
					else 
					{
                        System.out.println("Element not found in the HashSet.");
                    }
                    break;
                    case 3:
                    System.out.println("Elements in the HashSet:");
                    hashSet.forEach(System.out::println);
                    break;
                    case 4:
                    System.out.println("Exiting the program.");
                    scanner.close();
                    System.exit(0);
                    default:
                    System.out.println("Invalid choice. Please try again.");
            }

            System.out.println(); 
        }
    }
}
----------------------------------------------------------------
LinkedHashSet :
------------------
public class LinkedHashSet extends HashSet implements Set, Clonable, Serializable

It is a predefined class in java.util package under Set interface and introduced from java 1.4v. 

It is the sub class of HashSet class.

It is an orderd version of HashSet that maintains a doubly linked list across all the elements. 

It internally uses Hashtable and LinkedList data structures.

We should use LinkedHashSet class when we want to maintain an order.

When we iterate the elements through HashSet the order will be unpredictable, while when we iterate the elments through LinkedHashSet then the order will be same as they were inserted in the collection.

It accepts hetrogeneous and null value is allowed.

It has same constructor as HashSet class.
-----------------------------------------------------------------
import java.util.*;
public class LinkedHashSetDemo
{
 public static void main(String args[])
	{ 
		  LinkedHashSet<String> lhs=new LinkedHashSet<>();
		  lhs.add("Ravi");
		  lhs.add("Vijay");
		  lhs.add("Ravi");
		  lhs.add("Ajay");
		  lhs.add("Pawan");
		  lhs.add("Shiva");
		  lhs.add(null);
		  lhs.add("Ganesh");          
		  lhs.forEach(str -> System.out.println(str));	   
	}
}
-----------------------------------------------------------------
import java.util.LinkedHashSet;

public class LinkedHashSetDemo1 
{
    public static void main(String[] args) 
	{
       LinkedHashSet<Integer> linkedHashSet = new LinkedHashSet<>();

        linkedHashSet.add(10);
        linkedHashSet.add(5);
        linkedHashSet.add(15);
        linkedHashSet.add(20);
        linkedHashSet.add(5); 

        System.out.println("LinkedHashSet elements: " + linkedHashSet);

        System.out.println("LinkedHashSet size: " + linkedHashSet.size());

        int elementToCheck = 15;
        if (linkedHashSet.contains(elementToCheck)) 
		{
            System.out.println(elementToCheck + " is present in the LinkedHashSet.");
        } 
		else 
		{
            System.out.println(elementToCheck + " is not present in the LinkedHashSet.");
        }

        int elementToRemove = 10;
        linkedHashSet.remove(elementToRemove);
        System.out.println("After removing " + elementToRemove + ", LinkedHashSet elements: " + linkedHashSet);

              linkedHashSet.clear(); 
        System.out.println("After clearing, LinkedHashSet elements: " + linkedHashSet); //[]
    }
}
-----------------------------------------------------------------
27-04-2024
----------
SortedSet :
-----------
It is the sub interface of Set interface which is available from JDK 1.2 onwards.

As we known sort() method accepts List interface as a parameter so, we can't perform sorting operation using sort() method in Set.

In order to provide sorting in Set interface, Java software people has provided SortedSet interface.

It provides default natural sorting order, that means elements are sorted in ascending order. If elements are number then ascending order but if elements are String then alphabetical order OR 
Dictionary order.

In ordert to sort the elements, It uses Comparable and Comparator interfaces.
-------------------------------------------------------------------
***Difference between Comparable and Comparator ?
--------------------------------------------------
Difference is available in paint diagram 27-APR-24
-------------------------------------------------------------------
Program on Comparable interface :
----------------------------------
Employee.java(R)
----------------
package com.ravi.comparable;

public record Employee(Integer empId, String empName, Double empSalary ) implements Comparable<Employee>
{
	@Override
	public int compareTo(Employee e2) 
	{
	  //Sorting Employee based on the name
		return this.empName.compareTo(e2.empName);
			 
	}

	
}

EmployeeComparable.java(C)
--------------------------
package com.ravi.comparable;

import java.util.ArrayList;
import java.util.Collections;

public class EmployeeComparable 
{
  public static void main(String[] args)
  {	 
	ArrayList<Employee> listOfEmployee = new ArrayList<>();
	listOfEmployee.add(new Employee(333, "Arman", 34000.90));
	listOfEmployee.add(new Employee(111, "Zuber", 45000.90));
	listOfEmployee.add(new Employee(222, "Rahul", 44000.90));
	
	Collections.sort(listOfEmployee);
	listOfEmployee.forEach(System.out::println);
	
  }
}
------------------------------------------------------------------
Limitation of Comparable interface :
------------------------------------
With Comparable we have 2 limitations :
---------------------------------------
1) In comparable interrface we need to modify the source code(BLC class).

2) We can write only one sorting logic.

To avoid the above said problem Comparator interface came into the picture :
Program On Comapartor :
-----------------------
Product.java(R)
---------------
package com.ravi.comparator;

public record Product(Integer prodId, String productName) 
{

}

ProductComparator.java
----------------------
package com.ravi.comparator;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class ProductComparator 
{
  public static void main(String[] args) 
  {
	ArrayList<Product> listOfProduct = new ArrayList<>();
	listOfProduct.add(new Product(333, "Camera"));
	listOfProduct.add(new Product(111, "Mobile"));
	listOfProduct.add(new Product(222, "Laptop"));
	
	//Anonymous inner class
	Comparator<Product> compId = new Comparator<Product>() 
	{
		@Override
		public int compare(Product p1, Product p2) 
		{
			return p1.prodId() - p2.prodId();
		}
		
	};
	
	Collections.sort(listOfProduct, compId);
	System.out.println("Sorting the product based on the ID :");
	listOfProduct.forEach(System.out::println);
	
	//Lambda 
	Comparator<Product> compName = (p1,p2)-> p1.productName().compareTo(p2.productName());
	
	Collections.sort(listOfProduct, compName);
	System.out.println("Sorting the product based on the Name :");
	listOfProduct.forEach(System.out::println);
	
  }
}

-------------------------------------------------------------------
Program on Comparator to Convert the Integer Object into Descending:
---------------------------------------------------------------------
package abstract_with_array;

import java.util.ArrayList;
import java.util.Collections;

public class IntegerDescending {

	public static void main(String[] args) 
	{
		ArrayList<Integer> al = new ArrayList<>();
		al.add(12);
		al.add(45);
		al.add(67);
		al.add(10);		
		
		Collections.sort(al,(i1,i2)-> i2-i1);
		al.forEach(System.out::println);
	}

}
----------------------------------------------------------------
29-04-2024
----------
TreeSet :
---------
public class TreeSet<E> extends AbstractSet<E> implements NavigableSet<E>, Clonable, Serializable

It is a predefined class available in java.util package under Set interface.

TreeSet, TreeMap  and PriorityQueue are the three sorted collection in the entire Collection Framework so these classes never accepting non comparable objects.

It will sort the elements in natural sorting order i.e ascending order in case of number , and alphabetical order or Dictionary order in the case of String. In order to sort the elements according to user choice, It uses Comparable/Comparator  interface.

It does not accept duplicate and null value (java.lang.NullPointerException).

It does not accept non comparable type of data if we try to insert it will throw a runtime exception i.e java.lang.ClassCastException

TreeSet implements NavigableSet.

NavigableSet extends SortedSet.

It contains 4 types of constructors :
----------------------------------------
1) TreeSet t1 = new TreeSet();
     create an empty TreeSet object, elements will be inserted in a natural sorting order.

2) TreeSet t2 = new TreeSet(Comparator c);
    Customized sorting order

3)  TreeSet t3 = new TreeSet(Collection c);

4) TreeSet t4 = new TreeSet(SortedSet s);

----------------------------------------------------------------
//program that describes TreeSet provides default natural sorting order
import java.util.*;
public class TreeSetDemo 
{
	public static void main(String[] args) 
	{
		SortedSet<Integer> t1 = new TreeSet<>();
		t1.add(4);
		t1.add(7);
		t1.add(2);
		t1.add(1);
		t1.add(9);	

	
		System.out.println(t1);

		NavigableSet<String> t2 = new TreeSet<>();
		t2.add("Orange");
		t2.add("Mango");
		t2.add("Banana");
		t2.add("Grapes");
		t2.add("Apple");		
		System.out.println(t2);		
	}
}
Note : Integer and String both classes are implementing java.lang.Comparable so internally compareTo() is invoked the 
compare the Integer and String Object.
----------------------------------------------------------------
import java.util.*;
public class TreeSetDemo1
{
	public static void main(String[] args) 
	{
		TreeSet<String> t1 = new TreeSet<>();
		t1.add("Orange"); 
		t1.add("Mango");
		t1.add("Pear");
		t1.add("Banana");
		t1.add("Apple");	
		System.out.println("In Ascending order");
		t1.forEach(i -> System.out.println(i));

		TreeSet<String> t2 = new TreeSet<>();
		t2.add("Orange");
		t2.add("Mango");
		t2.add("Pear");
		t2.add("Banana");
		t2.add("Apple");

        System.out.println("In Descending order");
		Iterator<String> itr2 = t2.descendingIterator();  //for descending order

         itr2.forEachRemaining(x -> System.out.println(x));		
	}
}

Note :- descendingIterator() is a predefined method of TreeSet class which will traverse in the descending order and return type of this method is Iterator interface.

public Iterator descendingIterator()
----------------------------------------------------------------
import java.util.*;
public class TreeSetDemo2
{
	public static void main(String[] args) 
	{
		Set<String> t = new TreeSet<>();  
		t.add("6");   
		t.add("5");
		t.add("4");
		t.add("2");
		t.add("9");	
		Iterator<String> iterator = t.iterator();
		iterator.forEachRemaining(x -> System.out.println(x));

		//From 1.8 to replace hasNext() and next() method
	}
}
----------------------------------------------------------------
import java.util.*;  

public class TreeSetDemo3 
	{
	public static void main(String[] args)
	{
		Set<Character> t = new TreeSet<>();  
		t.add('A'); 
		t.add('C');
		t.add('B');
		t.add('E');
		t.add('D');	
		Iterator<Character> iterator = t.iterator();
		iterator.forEachRemaining(x -> System.out.println(x)); 			
	}
}
----------------------------------------------------------------
Program on TreeSet which accepts Comparator as a parameter to TreeSet constructor for sorting the elements on Comparator logic

2 files :
---------
Student.java(R)
--------------
package com.ravi.treeset_comp;

public record Student(Integer studentId, String studentName, Double studentFees) 
{

}

StudentComparator.java(C)
--------------------------
package com.ravi.treeset_comp;

import java.util.TreeSet;

public class StudentComparator 
{
	public static void main(String[] args) 
	{
		TreeSet<Student> ts1 = new TreeSet<>((s1,s2)-> s1.studentId()-s2.studentId());
		ts1.add(new Student(333,"Aman",12890.89));
		ts1.add(new Student(111,"Zuber",12890.89));
		ts1.add(new Student(222,"Ramesh",12890.89));
		ts1.add(new Student(444,"Suresh",12890.89));
		System.err.println("Sorted based on Student ID in Ascending Order :");
		ts1.forEach(System.out::println);
		
		
		TreeSet<Student> ts2 = new TreeSet<>((s1,s2)-> s2.studentId()-s1.studentId());
		ts2.add(new Student(333,"Aman",12890.89));
		ts2.add(new Student(111,"Zuber",12890.89));
		ts2.add(new Student(222,"Ramesh",12890.89));
		ts2.add(new Student(444,"Suresh",12890.89));
		System.err.println("Sorted based on Student ID in Descending Order :");
		ts2.forEach(System.out::println);
		
		
		TreeSet<Student> ts3 = new TreeSet<>((s1,s2)-> s1.studentName().compareTo(s2.studentName()));
		ts3.add(new Student(333,"Aman",12890.89));
		ts3.add(new Student(111,"Zuber",12890.89));
		ts3.add(new Student(222,"Ramesh",12890.89));
		ts3.add(new Student(444,"Suresh",12890.89));
		System.err.println("Sorted based on Student Name in Ascending Order :");
		ts3.forEach(System.out::println);
		
		

		TreeSet<Student> ts4 = new TreeSet<>((s1,s2)-> s2.studentName().compareTo(s1.studentName()));
		ts4.add(new Student(333,"Aman",12890.89));
		ts4.add(new Student(111,"Zuber",12890.89));
		ts4.add(new Student(222,"Ramesh",12890.89));
		ts4.add(new Student(444,"Suresh",12890.89));
		System.err.println("Sorted based on Student Name in Descending Order :");
		ts4.forEach(System.out::println);
	}

}
----------------------------------------------------------------
Program on TreeSet which accepts Employee object, Employee records implements Comparable 

2 files :
---------
Employee.java(R)
-----------------
package com.ravi.treeset_comp;

public record Employee(Integer empId, String empName) implements 
Comparable<Employee>
{

	@Override
	public int compareTo(Employee e2) 
	{
		return this.empName.compareTo(e2.empName);
	}
}


EmployeeComparable.java
------------------------
package com.ravi.treeset_comp;

import java.util.TreeSet;

public class EmployeeComparable {

	public static void main(String[] args) 
	{
		TreeSet<Employee> ts1 = new TreeSet<>();
		ts1.add(new Employee(222, "Aman"));
		ts1.add(new Employee(111, "Juber"));
		ts1.add(new Employee(444, "Suresh"));
		ts1.add(new Employee(333, "Dhoni"));
		
		ts1.forEach(System.out::println);
	}

}

Note : While taking the object in the TreeSet class , the class must implements either Comparable OR Comparator otherwise we will get ClassCastException
----------------------------------------------------------------
---------------------------------------------------------------
Methods of SortedSet interface :
--------------------------------------
public E first() :- Will fetch first element

public E last() :- Will fetch last element

public SortedSet headSet(int range) :- Will fetch the values which are less than specified range

public SortedSet tailSet(int range) :- Will fetch the values which are equal and greater than the specified range.

public SortedSet subSet(int startRange, int endRange) :- Will fetch the range of values where startRange is inclusive and endRange is exclusive.

Note :- headSet(), tailSet() and subSet(), return type is SortedSet
----------------------------------------------------------------
import java.util.*;
public class SortedSetMethodDemo
{
       public static void main(String[] args) 
       {
            TreeSet<Integer> times = new TreeSet<>();
            times.add(1205);
            times.add(1505);
            times.add(1545);
			times.add(1600);
            times.add(1830);
            times.add(2010);
            times.add(2100);
            
            SortedSet<Integer> sub = new TreeSet<>();
            
			sub = times.subSet(1545,2100); 
            System.out.println("Using subSet() :-"+sub);//[1545, 1600,1830,2010]
            System.out.println(sub.first());
            System.out.println(sub.last());   
			
		    sub = times.headSet(1545); 
			System.out.println("Using headSet() :-"+sub); //[1205, 1505]
            
		     sub =  times.tailSet(1545); 
			 System.out.println("Using tailSet() :-"+sub); //[1545 to 2100] 
       }
}
----------------------------------------------------------------
NavigableSet(I) :
-----------------
With the help of SortedSet interface method we can find out the range of values but we can't navigate among those elements.

Now to frequently navigate among those range of elements, Java software people introduced new interface called NavigableSet from 1.6V

NavigableSet extends SortedSet
----------------------------------------------------------------
import java.util.*;

public class NavigableSetDemo 
{   
    public static void main(String[] args)
    {
        NavigableSet<Integer> ns = new TreeSet<>(); 
        ns.add(1);
        ns.add(2);
        ns.add(3);
        ns.add(4);
        ns.add(5);
        ns.add(6);

		System.out.println("lower(3): " + ns.lower(3));//Just below than the specified element or null
        
       System.out.println("floor(3): " + ns.floor(3)); //Equal  less or null
      
        System.out.println("higher(3): " + ns.higher(3));//Just greater than specified element or null
  
       System.out.println("ceiling(3): " + ns.ceiling(3));//Equal or greater or null 
	   
        	
    }
}
---------------------------------------------------------------
30-04-2024
----------
Map interface :
---------------
As we know Collection interface is used to hold single Or individual object but Map interface will hold group of objects in the form key and value pair. {key = value}

Map interface is not the part the Collection.

Before Map interface We had Dictionary(abstract class) class and it is extended by Hashtable class in JDK 1.0V

Map interface works with key and value pair introduced from 1.2V.

Here key and value both are objects.

Here key must be unique and value may be duplicate.

Each key and value pair is creating one Entry.(Entry is nothing but the combination of key and value pair)

interface Map
{   
     interface Entry
      {
         //key and value
      }
}

How to represent this entry interface (Map.Entry in .java) [Map$Entry in .class]

In Map interface whenever we have a duplicate key then the old key value will be replaced by new key(duplicate key) value.

forEach(BiConsumer cons) method is available in Map interface.

Iterator and ListIterator we can't use directly using Map.
-----------------------------------------------------------------
Map interface Hierarchy :
-------------------------
Map interface Hierarchy [30-APR-24]
---------------------------------------------------------------
Methods of Map interface :
--------------------------
Methods of Map interface :
--------------------------
1) Object put(Object key, Object value) :- To insert one entry in the Map collection. It will return the old object key value if the key is already available(Duplicate key), If key is not available then it will return null.

2) putIfAbsent(Object key, Object value) :- It will insert an entry if and only if key is not present , if the key is already available then it will not insert the Entry to the Map Collection


3) Object get(Object key) :- It will return  corresponding value of key, if the key is not present then it will return null.

4) Object getOrDefault(Object key, Object defaultValue) :- To avoid null value this method has been introduced, here we can pass some defaultValue to avoid the null value.

5) boolean containsKey(Object key) :- To Search a particular key

6) boolean containsValue(Object value) :- To Search a particular value

7) int size() :- To count the number of Entries.

8) remove(Object key) :- One complete entry will be removed.

9) void clear() :- Used to clear the Map

10) boolean isEmpty() :- To verify Map is empty or not?

11) void putAll(Map m) :- Merging of two Map collection
------------------------------------------------------------------
Note :- Iterator interface will not work with Map interface because Map interface works with Group of Object, If we want to iterate the map data then we should use Collection view Method.

Collection views Methods :
------------------------------
public Set keySet() :- Will return only keys (Set of keys)

Collection values() :- Will return all values.

Set<Map.Entry> entrySet() :- It will return key and value pair in the form of Entry.

          a) getKey()    b) getValue()   c) setValue()
----------------------------------------------------------------
01-05-2024
-----------
*** How HashMap Works internally ?
----------------------------------
a) While working with HashSet or HashMap every object must be compared because duplicate objects are not allowed.

b) Whenever we add any new key to verify whether key is unique or duplicate, HashMap internally uses hashCode(), == operator and equals method.

c) While adding the key object in the HashMap, first of all it will invoke the hashCode() method to retrieve the corresponding key hashcode value.
    Example :- hm.put(key,value);
               then internally key.hashCode();

d) If the newly added key and existing key hashCode value both are same (Hash collision), then only == operator is used for comparing those keys by using reference or memory address, if both keys references are same then existing key value will be replaced with new key value.

        If the reference of both keys are different then equals(Object obj) method is invoked to compare those keys by using state(data). [content comparison]

	If the equals(Object obj) method returns true (content wise both keys are same), this new key is duplicate then existing key value will be replaced by new key value.

	If equals(Object obj) method returns false, this new key is unique, new entry (key-value) will be inserted.

	Note :- equals(Object obj) method is invoked only when two keys are having same hashcode as well as their references are different.

e) Actually by calling hashcode method we are not comparing the objects, we are just storing the objects in a group so the currently adding key object will be compared with its HASHCODE GROUP objects, but not with all the keys which are available in the Map.

f) The main purpose of storing objects into the corresponding group to decrease the number of comparison so the efficiency of the program will increase.

g) To insert an entry in the HashMap, HashMap internally uses Hashtable data structure

h) Now, for storing same hashcode object into a single group, hash table data structure internally uses one more data structure called Bucket.

i) The Hashtable data structure internally uses Node class array object.

j) The bucket data structure internally uses LinkedList data structure, It is a single linked list again implemented by Node class only.

*k) A bucket is group of entries of same hash code keys.

l) Performance wise LinkedList is not good to serach, so from java 8 onwards LinkedList is changed to Binary tree to decrease the number of comparison within the same bucket hashcode if the number of entries are greater than 8.

* equals() and hashCode() method contract :
-----------------------------------------
Both the methods are working together to find out the duplicate objects in the Map.

*If equals() method invoked on two objects and it returns true then hashcode of both the objects must be same.

Note : IF TWO OBJECTS ARE HAVING SAME HASH CODE THEN IT MAY BE SAME OR DIFFERENT BUT if we call equals() methdo then hashCode of both the objects must be same.
-----------------------------------------------------------------
package com.ravi.single_level;

import java.util.HashMap;

public class HashMapInternals {

	public static void main(String[] args) 
	{
		HashMap<String,Integer> hm1 = new HashMap<>();
		hm1.put("A", 1);
		hm1.put("A", 2);
		hm1.put(new String("A"), 3);
		System.out.println("Size is :"+hm1.size());
		System.out.println(hm1);
		System.out.println("....................");
		HashMap<Integer,Integer> hm2 = new HashMap<>();
		hm2.put(128, 1);
		hm2.put(128, 2);
		System.out.println("Size is :"+hm2.size());
		System.out.println(hm2);
		System.out.println("....................");
		HashMap hm3 = new HashMap();
		hm3.put("A", 1);
		hm3.put("A", 2);
		hm3.put(new String("A"), 3);
		hm3.put(65, 4);
		System.out.println("Size is :"+hm3.size());
		System.out.println(hm3);
		
	}

}
----------------------------------------------------------------import java.util.*;
class Employee
{
	int eid;
	String ename;

	Employee(int eid, String ename)
	{
		this.eid = eid;
		this.ename = ename;
	}

    @Override
	public boolean equals(Object obj)  //obj = e2
	{		
		if(obj instanceof Employee)
        {
			Employee e2 = (Employee) obj; //downcasting

			if(this.eid == e2.eid && this.ename.equals(e2.ename))
			{
				return true;
			}
			else
			{
				return false;
			}
	    }
		else
		{
			System.out.println("Comparison is not possible");
			return false;
		}		
	}

	public String toString()
		{
			 return " "+eid+" "+ename;
		}
}
public class HashMapDemo8
{
	public static void main(String[] args) 
	{
		Employee e1 = new Employee(101,"Aryan");
		Employee e2 = new Employee(102,"Pooja");
		Employee e3 = new Employee(101,"Aryan");
		Employee e4 = e2;

		
		HashMap<Employee,String> hm = new HashMap<>();
		hm.put(e1,"Ameerpet");
		hm.put(e2,"S.R Nagar");
		hm.put(e3,"Begumpet");
		hm.put(e4,"Panjagutta");

		hm.forEach((k,v)-> System.out.println(k+" : "+v));
	}
}
---------------------------------------------------------------
02-05-2024
----------
HashMap<K,V> :-  [Unsorted, Unordered, No Duplicate keys]
------------
public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Serializable, Clonable 

It is a predefined class available in java.util package under Map interface available from JDK 1.2.

It gives us unsorted and Unordered map. when we need a map and we don't care about the order while iterating the elements through it then we should use HashMap.

It inserts the element based on the hashCode of the Object key using hashing technique [hasing alogorithhm]

It does not accept duplicate keys but value may be duplicate.

It accepts only one null key(because duplicate keys are not allowed) but multiple null values are allowed.

HashMap is not synchronized.  

Time complexcity of search, insert and delete will be O(1)

We should use HashMap to perform fast searching opeartion.

It contains 4 types of constructor 

1) HashMap hm1 = new HashMap();
    It will create the HashMap Object with default capacity is 16. The default load fator or Fill Ratio is 0.75   (75% of HashMap is filled up then new HashMap Object will be created having double capacity)

2) HashMap hm2 = new HashMap(int initialCapacity);
    will create the HashMap object with user specified capacity


3) HashMap hm3 = new HashMap(int initialCapacity, float loadFactor);
    we can specify our own initialCapacity and loadFactor(by default load factor is 0.75%)

4)HashMap hm4 = new HashMap(Map m);
    Interconversion of Map Collection
---------------------------------------------------------------
//Program that shows HashMap is unordered
import java.util.*;
public class HashMapDemo 
{
      public static void main(String[] a) 
      {
           Map<String,String> map = new HashMap<>();
		   map.put("Ravi", "12345");  
		   map.put("Rahul", "12345");
		   map.put("Aswin", "5678");
		   map.put(null, "6390");
		   map.put("Ravi","1529");
		   map.put("Aamir","890");

		   System.out.println(map); 
           
           System.out.println(map.get(null));  
		   System.out.println(map.get("Virat"));  
		   
		   map.forEach((k,v)-> System.out.println("Key is :"+k+" value is "+v)); 
		                 
      }
}
---------------------------------------------------------------
//Program to search a particular key and value in the Map collection
import java.util.*;
public class HashMapDemo1
{
	public static void main(String args[]) 
	{
		HashMap<Integer,String> hm = new HashMap<>();			 
		hm.put(1, "JSE");  
		hm.put(2, "JEE");
		hm.put(3, "JME"); 
		hm.put(4,"JavaFX");
		hm.put(5,null);
		hm.put(6,null);
		
		System.out.println("Initial map elements: " + hm); 
		System.out.println("key 2 is present or not :"+hm.containsKey(2));   

		System.out.println("JME is present or not :"+hm.containsValue("JME")); 

		System.out.println("Size of Map : " + hm.size()); 
		hm.clear(); 	
		System.out.println("Map elements after clear: " + hm);
	}
}
---------------------------------------------------------------
//Collection view methods [keySet(),  values(), Set<Map.Entry> entrySet()]
import java.util.*;
public class HashMapDemo2
{
public static void main(String args[]) 
	{
			Map<Integer,String> map = new HashMap<>(); 
			map.put(1, "C");
			map.put(2, "C++");
			map.put(3, "Java");
			map.put(4, ".net");
		
			map.forEach((k,v)->System.out.println("Key :"+k+" Value :"+v) );           
			           
			System.out.println("Return Old Object value :"+map.put(4,"Python"));  

			Set keys =  map.keySet();
			System.out.println("All keys are :"+keys);

			Collection values = map.values();
			System.out.println("All values are :"+values);
		
			for(Map.Entry m : map.entrySet())
			 {  
				 System.out.println(m.getKey()+" = "+m.getValue());  
			}  
	}    
}
----------------------------------------------------------------
import java.util.*;
public class HashMapDemo3
{
public static void main(String args[]) 
  {
		HashMap<Integer,String> map = new HashMap<>(26,0.95f);
		map.put(1, "Java");
		map.put(2, "is");
		map.put(3, "best");
		map.remove(3);  //will remove the complete Entry
		String val=(String)map.get(3);
		System.out.println("Value for key 3 is: " + val);
		map.forEach((k,v)->System.out.println(k +" : "+v));
   }    
}
--------------------------------------------------------------
//To merge two Map Collection (putAll)  
import java.util.*;
public class HashMapDemo4
{
public static void main(String args[]) 
	{
		HashMap<Integer,String> newmap1 = new HashMap<>();

		HashMap<Integer,String> newmap2 = new HashMap<>();	  

		newmap1.put(1, "OCPJP");
		newmap1.put(2, "is");
		newmap1.put(3, "best");
			  
		System.out.println("Values in newmap1: "+ newmap1);

		newmap2.put(4, "Exam");

		newmap2.putAll(newmap1);

		newmap2.forEach((k,v)->System.out.println(k+" : "+v));		
   }    
}
---------------------------------------------------------------
import java.util.*;
public class HashMapDemo5 
{
     public static void main(String[] argv) 
     {
          Map<String,String> map = new HashMap<>(9, 0.85f);
          map.put("key", "value");
          map.put("key2", "value2");
          map.put("key3", "value3");
		  map.put("key7","value7");


		   Set keys = map.keySet();//keySet return type is Set
		   System.out.println(keys ); //[]

          Collection val = map.values(); //values return type is collection
          System.out.println(val);
         
		  map.forEach((k,v)-> System.out.println(k+" : "+v));
		  
          	  
      }
}
---------------------------------------------------------------
//getOrDefault() method
import java.util.*;
public class  HashMapDemo6
{
	public static void main(String[] args) 
	{
		Map<String, String> map = new HashMap<>();
		map.put("A", "1");
		map.put("B", "2");
		map.put("C", "3");
        //if the key is not present, it will return default value .It is used to avoid null
		String value = map.getOrDefault("D","Key is not available");
		System.out.println(value);
		System.out.println(map); 
	}
}
----------------------------------------------------------------
//interconversion of two HashMap
import java.util.*;
public class HashMapDemo7
	{
	public static void main(String args[])
	{		
		HashMap<Integer, String> hm1 = new HashMap<>();

		hm1.put(1, "Ravi");
		hm1.put(2, "Rahul");
		hm1.put(3, "Rajen");

		HashMap<Integer, String> hm2	= new HashMap<>(hm1);

		System.out.println("Mapping of HashMap hm1 are : "	+ hm1);
	
		System.out.println("Mapping of HashMap hm2 are : " + hm2);
	}
}
---------------------------------------------------------------
LinkedHashMap<K,V>
-------------------
LinkedHashMap :
------------------
public class LinkedHashMap<K,V> extends HashMap<K,V> implements Map<K,V>

It is a predefined class available in java.util package under Map interface available from 1.4.

It is the sub class of HashMap class.

It maintains insertion order. It contains a doubly linked with the elements or nodes so It will iterate more slowly in comparison to HashMap.

It uses Hashtable and LinkedList data structure.

If We want to fetch the elements in the same order as they were inserted then we should go with LinkedHashMap.

It accepts one null key and multiple null values.

It is not synchronized.

It has also 4 constructors same as HashMap

1) LinkedHashMap hm1 = new LinkedHashMap();
    will create a  LinkedHashMap with default capacity 16 and load factor 0.75

2) LinkedHashMap hm1 = new LinkedHashMap(iny initialCapacity);

3) LinkedHashMap hm1 = new LinkedHashMap(iny initialCapacity, float loadFactor);


4) LinkedHashMap hm1 = new LinkedHashMap(Map m);
---------------------------------------------------------------
import java.util.*;
public class LinkedHashMapDemo 
{
	public static void main(String[] args) 
	{
		LinkedHashMap<Integer,String> l = new LinkedHashMap<>();
		l.put(1,"abc");
		l.put(3,"xyz");
		l.put(2,"pqr");
		l.put(4,"def");
		l.put(null,"ghi");
		System.out.println(l);
	}
}
----------------------------------------------------------------
import java.util.*;

public class LinkedHashMapDemo1 
{
      public static void main(String[] a) 
      {
           Map<String,String> map = new LinkedHashMap<>();
           map.put("Ravi", "1234");
		   map.put("Rahul", "1234");
		   map.put("Aswin", "1456");
		   map.put("Samir", "1239");
           
		   map.forEach((k,v)->System.out.println(k+" : "+v));
      }
}
---------------------------------------------------------------
Hashtable<K,V>
--------------
public class Hashtable<K,V> extends Dictionary<K,V> implements Map<K,V>, Clonable, Serializable

It is predefined class available in java.util package under Map interface from JDK 1.0.

Like Vector, Hashtable is also form the birth of java so called legacy class.

It is the sub class of Dictionary class which is an abstract class.

*The major difference between HashMap and Hashtable is, HashMap methods are not synchronized where as Hastable methods are synchronized. 

HashMap can accept one null key and multiple null values where as Hashtable does not contain anything as a null(key and value both). if we try to add null then JVM will throw an exception i.e NullPointerException.

The initial default capacity of Hashtable class is 11 where as loadFactor is 0.75.


It has also same constructor as we have in HashMap.(4 constructors)

1) Hashtable hs1 = new Hashtable();
    It will create the Hashtable Object with default capacity as 11 as well as load factor is 0.75

2) Hashtable hs2 = new Hashtable(int initialCapacity);
    will create the Hashtable  object with specified capacity


3) Hashtable hs3 = new Hashtable(int initialCapacity, float loadFactor);
    we can specify our own initialCapacity and loadFactor

4) Hashtable hs = new Hashtable(Map c);
    Interconversion of Map Collection
---------------------------------------------------------------
import java.util.*;  
public class HashtableDemo
	{  
	 public static void main(String args[])
		{  
		  Hashtable<Integer,String> map=new Hashtable<>(); 
		  map.put(1, "Java");
		  map.put(2, "is");
		  map.put(3, "best");		
		  map.put(4,"language");
		  
		  //map.put(5,null);  

		  System.out.println(map);

		  System.out.println(".......................");

		    for(Map.Entry m : map.entrySet())
			 {  
				 System.out.println(m.getKey()+" = "+m.getValue());  
			} 
        }  
}  
---------------------------------------------------------------
import java.util.*;  
public class HashtableDemo1
{  
   public static void main(String args[])
	{  
    Hashtable<Integer,String> map=new Hashtable<>();          
     map.put(1,"Priyanka");    
     map.put(2,"Ruby");   
     map.put(3,"Vibha");    
     map.put(4,"Kanchan");
	
	 map.putIfAbsent(5,"Bina");  
	 map.putIfAbsent(24,"Pooja");
	 map.putIfAbsent(26,"Ankita");     
    
     map.putIfAbsent(1,"Sneha");  
     System.out.println("Updated Map: "+map); 
 }  
}  
---------------------------------------------------------------
WeakHashMap :
-------------
public class WeakHashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>

It is a predefined class in java.util package under Map interface.It was introduced from JDK 1.2v onwards.

While working with HashMap, keys of HashMap are of strong reference type. This means the entry of  map will not be deleted by the garbage collector even though the key is set to be null and  still it is not eligible for Garbage Collector.

On the other hand while working with WeakHashMap, keys of WeakHashMap are of weak reference type. This means the entry of a map is  deleted by the garbage collector if the key value is set to be null because it is of weak type.

So, HashMap dominates over Garbage Collector where as Garbage Collector dominates over WeakHashMap.

It contains 4 types of Constructor :
---------------------------------------
1) WeakHashMap wm1 = new WeakHashMap();
   
    Creates an empty WeakHashMap object with default capacity is 16 and load fator 0.75


2) WeakHashMap wm2 = new WeakHashMap(int initialCapacity);

3) WeakHashMap wm3 = new WeakHashMap(int initialCapacity, float loadFactor);

    Eg:- WeakHashMap wm = new WeakHashMap(10,0.9);

    capacity - The capacity of this map is 10. Meaning, it can store 10 entries.

    loadFactor - The load factor of this map is 0.9. This means whenever our hashtable is filled up by 90%, the entries are moved to a new hashtable of double the size of the original hashtable.

4) WeakHashMap wm4 = new WeakHashMap(Map m);
---------------------------------------------------------------
import java.util.*;
public class WeakHashMapDemo
{
	public static void main(String args[]) throws Exception
	{
	    WeakHashMap<Test,String> map = new WeakHashMap<>();

		Test  t  = new Test();
		map.put(t," Rahul "); 

		System.out.println(map); //{Test Nit = Rahul}
		
		t = null;
		
		System.gc();	
		
		Thread.sleep(5000); 
		
		System.out.println(map); //{}
	}
}

class Test
{
	@Override
	public String toString()
	{
		return "Test Nit";
	}
	
	@Override
	public void finalize() //called automaticaly if an object is eligible 4 GC
	{
		System.out.println("finalize method is called");
	}
}
---------------------------------------------------------------
System generated hashcode for the Object :
-------------------------------------------
System class has provided a predefined static method identityHashCode(Object obj) through which we can find out system generated hashcode value.

import java.util.*;     
public class Demo 
{
 public static void main(String args[])
  { 
    String str = "nit";
	System.out.println(str.hashCode());
	System.out.println(System.identityHashCode(str));
  }
}

IdentityHashMap :        
-----------------
public class IdentityHashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Clonable, Serializable.

It was introduced from JDK 1.4 onwards.

The IdentityHashMap uses == operator to compare keys.

As we know HashMap uses equals() and hashCode() method for comparing the keys based on the hashcode of the object it will serach the bucket location and insert the entry their only.

So We should use IdentityHashMap where we need to check the reference or memory address instead of logical equality.

HashMap uses hashCode of the "Object key" to find out the bucket loaction in Hashtable, on the other hand IdentityHashMap does not use hashCode() method actually It uses System.identityHashCode(Object o)

IdentityHashMap is more faster than HashMap in case of key Comparison.

It has three constrcutors, It does not contain loadFactor specific constructor.
--------------------------------------------------------------
import java.util.*;
public class IdentityHashMapDemo 
{
	public static void main(String[] args) 
	{
		HashMap<String,Integer> hm = new HashMap<>();

		IdentityHashMap<String,Integer> ihm = new IdentityHashMap<>();
		
		hm.put("Ravi",23);
		hm.put(new String("Ravi"), 24);
		
		ihm.put("Ravi",23);
		ihm.put(new String("Ravi"), 27); //compares based on == operator
		
		System.out.println("HashMap size :"+hm.size());  
		System.out.println(hm);
		System.out.println("........................");
		System.out.println("IdentityHashMap size :"+ihm.size()); 
		System.out.println(ihm);

	}

}
----------------------------------------------------------------
SortedMap<K,V>
--------------
It is a predefined interface available in java.util package under Map interface.

We should use SortedMap interface when we want to insert the key element based on some sorting order i.e the default natural sorting order.
--------------------------------------------------------------
TreeMap<K,V>
------------
public class TreeMap<K,V> extends AbstractMap<K,V> implements NavigableMap<K,V> , Clonable, Serializable

It is a predefined class avaialble in java.util package under Map interface available for 1.2V.

It is a sorted map that means it will sort the elements by natural sorting order based on the key or by using Comparator interface as a constructor parameter.

It does not allow non comparable keys.

It does not accept null key but null value allowed.

TreeMap implements NavigableMap and NavigableMap extends SortedMap. SortedMap extends Map interface.

TreeMap contains 4 types of Constructors :

1) TreeMap tm1 = new TreeMap(); //creates an empty TreeMap

2)  TreeMap tm2 = new TreeMap(Comparator cmp); //user defined soting logic

3)  TreeMap tm3 = new TreeMap(Map m);

4)  TreeMap tm4 = new TreeMap(SortedMap m);
---------------------------------------------------------------
import java.util.*;
public class TreeMapDemo 
{
	public static void main(String[] args) 
	{
		TreeMap<Integer,String> t = new TreeMap<>(); 
		t.put(4,"Ravi");
		t.put(7,"Aswin");
		t.put(2,"Ananya");
		t.put(1,"Dinesh");
		t.put(9,"Ravi");	
		t.put(3,"Ankita");
		t.put(5,null);
		
				
		System.out.println(t);
	}
}
--------------------------------------------------------------
import java.util.*;                        
public class TreeMapDemo1 
{
      public static void main(String args[]) 
      {
            TreeMap map = new TreeMap();
            map.put("one","1");
            map.put("two",null);
            map.put("three","3");
			map.put("four",4);

            displayMap(map);  

	map.forEach((k, v) -> System.out.println("Key = " + k + ", Value = " + v));
	 	       
      }
      static void displayMap(TreeMap map) 
      {
           Collection c = map.entrySet();   //Set<Map.Entry>

           Iterator i = c.iterator();
           i.forEachRemaining(x -> System.out.println(x));
      }
}
----------------------------------------------------------------
//firstKey()  lastKey()  headMap()  tailMap()  subMap()      Map
// first()     last()     headSet()  tailSet()  subSet()     Set

import java.util.*;
public class TreeMapDemo2
{
    public static void main(String[] argv) 
    {
        Map map = new TreeMap();  
        map.put("key2", "value2");
        map.put("key3", "value3");
        map.put("key1", "value1");

        System.out.println(map); //{}

        SortedMap x = (SortedMap) map;
        System.out.println("First key is :"+x.firstKey());
        System.out.println("Last Key is :"+x.lastKey()); 
     }
}
----------------------------------------------------------------
package com.ravi.treemap_comparator;

import java.util.TreeMap;

public class TreeMapComparator 
{
	public static void main(String[] args) 
	{
		TreeMap<Product,String> tm1 = new TreeMap<>((p1,p2)-> p1.prodId()-p2.prodId());
		tm1.put(new Product(444,"Laptop"), "Warangal");
		tm1.put(new Product(111,"Camera"), "Hyderabad");
		tm1.put(new Product(222,"Mobile"), "Nagpur");
		tm1.put(new Product(333,"HeadPhone"), "Pune");
		
		tm1.forEach((k,v)-> System.out.println(k+" : "+v));
		
	}

}
----------------------------------------------------------------
Methods of SortedMap interface :
--------------------------------
1) firstKey()  //first key

2) lastKey()  //last key

3) headMap(int keyRange) //less than the specified range

4) tailMap(int keyRange)  //equal or greater than the specified range

5) subMap(int startKeyRange, int endKeyRange) //the range of key where startKey will be inclusive and endKey will be exclusive.

return type of headMap(), tailMap() and subMap() would be SortedMap(I)
---------------------------------------------------------------
import java.util.*;  
public class SortedMapMethodDemo
	{  
 public static void main(String args[])
	 {  
		SortedMap<Integer,String> map=new TreeMap<>();    
		  map.put(100,"Amit");    
		  map.put(101,"Ravi");    

		  map.put(102,"Vijay");    
		  map.put(103,"Rahul");   

		  System.out.println("First Key: "+map.firstKey());  //100
		   System.out.println("Last Key "+map.lastKey());   //103
		   System.out.println("headMap: "+map.headMap(102));  //100 101
		   System.out.println("tailMap: "+map.tailMap(102));  //102 103
		   System.out.println("subMap: "+map.subMap(100, 102)); //100 101 

	 }
 }  
----------------------------------------------------------------
Assignment 
NavigableMap Method 
----------------------------------------------------------------
Properties class :
------------------
Properties class:
-----------------
Properties class is used to maintain the data in the key-value form. It takes both key and value as a string. 

Properties class is a subclass of Hashtable. It provides the methods to store properties in a properties file and to get the properties from the properties file, we should use load method of Properties class.
---------------------------------------------------------------
FileReader reader = new FileReader("db.properties");

Proprties p = new Properties();
p.load(redaer);
p.getProperty(String key); //read the corresonding key value
----------------------------------------------------------------
System.getProperties() returns the all system properties.

Here we need to create a file with with extension .properties

Example :
---------
 driver = oracle.jdbc.driver.OracleDriver
 user = system
 password = tiger

 FileReader fr = new FileReader("db.properties");

 Properties p = new Properties();
 p.load(fr);
----------------------------------------------------------------
Here we need to create db.properties file 

db.properties 
-------------
 driver = oracle.jdbc.driver.OracleDriver
 user = scott
 password = tiger


PropertiesExample1.java
------------------------
import java.util.*;  
import java.io.*;  
public class PropertiesExample1 
{  
public static void main(String[] args)throws Exception
 {  
    FileReader reader=new FileReader("db.properties");  
      
    Properties p=new Properties();  
    p.load(reader);  
    
    System.out.println(p.getProperty("user"));  
    System.out.println(p.getProperty("password")); 
	System.out.println(p.getProperty("driver"));
 }  
}
----------------------------------------------------------------
import java.util.*;  
import java.io.*;  
public class PropertiesExample2 
{  
public static void main(String[] args)throws Exception
{  
	Properties p=System.getProperties();  
	Set set=p.entrySet();  
	
	Iterator itr=set.iterator();  
	while(itr.hasNext())
    {  
		Map.Entry entry=(Map.Entry)itr.next();  
		System.out.println(entry.getKey()+" = "+entry.getValue());  
	}  
  
}  }

Note :- Now we can make changes in the properties file(db.properties) and then execute the program without compilation.
---------------------------
---------------------------------------------------------------
Generics :
----------
Why generic came into picture : 
------------------------------------
As we know our compiler is known for Strict type checking because java is a statically typed checked language.

The basic problem with collection is It can hold any kind of Object.

ArrayList al = new ArrayList();
al.add("Ravi");
al.add("Aswin");
al.add("Rahul");
al.add("Raj");
al.add("Samir");

for(int i =0; i<al.size(); i++)
{ 
   String s = (String) al.get(i);
   System.out.println(s);
}

By looking the above code it is clear that Collection stores everything in the form of Object so here even after adding String type only we need type casting as shown below.

import java.util.*;
class Test1 
{
	public static void main(String[] args) 
	{
		ArrayList al = new ArrayList(); //raw type
		al.add("Ravi");
		al.add("Ajay");
		al.add("Vijay");
							
		for(int i=0; i<al.size(); i++)
		{
		String name = (String) al.get(i); //type casting is required
		System.out.println(name.toUpperCase());
		}	
		

	}
}
----------------------------------------------------------------
Even after type casting there is no guarantee that the things which are coming from ArrayList Object is Integer only because we can add anything in the Collection as a result java.lang.ClassCastException as shown in the program below.
 
import java.util.*;
class Test2
{
	public static void main(String[] args) 
	{
		ArrayList t = new ArrayList(); //raw type
		t.add("alpha");
		t.add("beta");
		for (int i = 0; i < t.size(); i++) 
		{
		  String str =(String) t.get(i);
		  System.out.println(str);
		}

		 t.add(1234);
		 t.add(1256);
		  for (int i = 0; i < t.size(); ++i)
	       {	 
			 String obj= (String)t.get(i); //we can't perform type casting here
			 System.out.println(obj);
		  }
	}
}
----------------------------------------------------------------
To avoid all the above said problem Generics came into picture from JDK 1.5 onwards
 
 -> It deals with type safe Object so there is a guarantee of both the end i.e putting inside and getting out.
 
 Example:-
 ArrayList<String > al = new ArrayList<>();

 Now here we have a guarantee that only String can be inserted as well as only String will come out from the Collection so we can perform String related operation.

 Advantages :-
 ---------------
 a) Type safe Object (No compilation warning)

 b) Strict compile time checking (Type erasure)

 c) No need of type casting

import java.util.*;
public class Test3
{
public static void main(String[] args) 
{
		ArrayList<String> al = new ArrayList<>();  //Generic type
		al.add("Ravi");
		al.add("Ajay");
		al.add("Vijay");		
		
        for(int i=0; i<al.size(); i++)
		{
		String name = al.get(i); //no type casting is required
		System.out.println(name.toUpperCase());
		}
   }
}
----------------------------------------------------------------
//Program that describes the return type of any method can be type safe 
//[We can apply generics on method return type]

import java.util.*;
public class Test4
{
	public static void main(String [] args)
	{
		Dog d1 = new Dog();
		Dog d2 = d1.getDogList().get(0);
		System.out.println(d2);
	}
}
class Dog
{
	public List<Dog> getDogList()
	{
		ArrayList<Dog> d = new ArrayList<>();
        d.add(new Dog());
		d.add(new Dog());
		d.add(new Dog());
		return d;
	}
}

Note :- In the above program the compiler will stop us from returning anything which is not compaitable List<Dog> and there is a guarantee that only "type safe list of Dog object" will be returned so we need not to provide type casting as shown below
Dog d2 = (Dog) d1.getDogList().get(0);  //before generic.
----------------------------------------------------------------
//Mixing generic with non-generic
import java.util.*;

class Car
{
}
public class Test5
{
	public static void main(String [] args) 
	{
	ArrayList<Car> a = new ArrayList<>();
	a.add(new Car());
	a.add(new Car());
    a.add(new Car());

	ArrayList b = a;  //assigning Generic to raw type 	          
	
    System.out.println(b);   
	}
}
----------------------------------------------------------------
//Mixing generic to non-generic
import java.util.*; 
public class Test6 
{
	public static void main(String[] args) 
	{ 
		List<Integer> myList = new ArrayList<>(); 
		myList.add(4); 
		myList.add(6); 
		myList.add(5);
        
		UnknownClass u = new UnknownClass(); 
		int total = u.addValues(myList); 
		System.out.println("The sum of Integer Object is :"+total); 
	} 
}  
class UnknownClass 
{ 
	public int addValues(List list)  //generic to raw type OR 
	{ 
	Iterator it = list.iterator();    
	int total = 0; 
	while (it.hasNext()) 
	{
		int i = ((Integer)it.next());
		total += i;                           //total = 15
	} 
	return total; 
	} 
} 

Note :-
In the above program the compiler will not generate any warning message because even though we are assigning type safe Integer Object to unsafe or raw type List Object but this List Object is not inserting anything new in the collection so there is no risk to the caller.
----------------------------------------------------------------
//Mixing generic to non-generic
import java.util.*; 
public class Test7 
{
	public static void main(String[] args) 
	{ 
		List<Integer> myList = new ArrayList<>(); 

		myList.add(4); 
		myList.add(6); 
		UnknownClass u = new UnknownClass(); 
		int total = u.addValues(myList); 
		System.out.println(total); 
	} 
}  
class UnknownClass 
{ 
    public int addValues(List list)  
	{ 
		list.add(5);	//adding object to raw type
		Iterator it = list.iterator(); 
		int total = 0; 
		while (it.hasNext()) 
		{
		int i = ((Integer)it.next()); 
		total += i; 
		} 
		return total; 
	} 
} 
-------------------------------------------------------------
//Mixing generic to non-generic
import java.util.*; 
public class Test7 
{
	public static void main(String[] args) 
	{ 
		List<Integer> myList = new ArrayList<>(); 

		myList.add(4); 
		myList.add(6); 
		UnknownClass u = new UnknownClass(); 
		int total = u.addValues(myList); 
		System.out.println(total); 
	} 
}  
class UnknownClass 
{ 
    public int addValues(List list)  
	{ 
		list.add(5);	//adding object to raw type
		Iterator it = list.iterator(); 
		int total = 0; 
		while (it.hasNext()) 
		{
		int i = ((Integer)it.next()); 
		total += i; 
		} 
		return total; 
	} 
} 
Here Compiler will generate warning message because the unsafe object is inserting the value 5 to safe object.
----------------------------------------------------------------
*Type Erasure
------------
In the above program the compiler will  generate  warning message because the unsafe List Object is inserting the Integer object 5 so the type safe Integer object is getting value 5 from unsafe type so there is a problem to the caller method.

By writing ArrayList<Integer> actually JVM does not have any idea that our ArrayList was suppose to hold only Integers. 

All the type safe generics information does not exist at runtime. All our generic code is Strictly for compiler. 

There is a process done by java compiler called "Type erasure" in which the java compiler converts generic version to non-generic type.

List<Integer> myList = new ArrayList<Integer>();

At the compilation time it is fine but at runtime for JVM the code becomes

List myList = new ArrayList();

Note :- GENERIC IS STRICTLY A COMPILE TIME PROTECTION.
----------------------------------------------------------------
06-05-2024
----------
Behavior of Polymorphism with Array and Generics :
--------------------------------------------------
//Polymorphism with array

import java.util.*;
abstract class Animal
{
	public abstract void checkup();
}

class Dog extends Animal
{
	@Override
	public void checkup()
	{
		System.out.println("Dog checkup");
	}
}

class Cat extends Animal
{
	@Override
	public void checkup()
	{
		System.out.println("Cat checkup");
	}
}

class Bird extends Animal
{
	@Override
	public void checkup()
	{
		System.out.println("Bird checkup");
	}
}

public class  Test8
{
	public void checkAnimals(Animal animals[])  
	{
		for(Animal animal : animals)
		{
			animal.checkup();
		}
	}

	public static void main(String[] args) 
	{
		Dog []dogs={new Dog(), new Dog()};

		Cat []cats={new Cat(), new Cat(), new Cat()};

		Bird []birds = {new Bird(), new Bird()};

		Test8 t = new Test8();

		t.checkAnimals(dogs);
		t.checkAnimals(cats);
		t.checkAnimals(birds);
	}
}
Note :-From the above program it is clear that polymorphism(Upcasting) concept works with array.
----------------------------------------------------------------
import java.util.*;
abstract class Animal
{
	public abstract void checkup();
}

class Dog extends Animal
{
    @Override
	public void checkup()
	{
		System.out.println("Dog checkup");
	}
}

class Cat extends Animal
{
	@Override
	public void checkup()
	{
		System.out.println("Cat checkup");
	}
}
class Bird extends Animal
{
	@Override
	public void checkup()
	{
		System.out.println("Bird checkup");
	}
}
public class Test9
{
	public void checkAnimals(List<Animal> animals)  
	{
		for(Animal animal : animals)
		{
             animal.checkup();
		}
	}
	public static void main(String[] args) 
	{
		List<Dog> dogs = new ArrayList<>();
		dogs.add(new Dog());
		dogs.add(new Dog());

		List<Cat> cats = new ArrayList<>();
		cats.add(new Cat());
		cats.add(new Cat());

		List<Bird> birds = new ArrayList<>();
		birds.add(new Bird());
		
		Test9 t = new Test9();
		t.checkAnimals(dogs);
		t.checkAnimals(cats);
		t.checkAnimals(birds);

	}
}

Note :- The above program will generate the compilation error.

So from the above program it is clear that polymorphism does not work in the same way for generics as it does with arrays.

Eg:-

Parent [] arr = new Child[5]; //valid
Object [] arr = new String[5]; //valid

But in generics the same type is not valid

List<Object> list = new ArrayList<Integer>(); //Invalid
List<Parent> mylist = new ArrayList<Child>(); //Invalid
----------------------------------------------------------------
import java.util.*;
public class Test10
{
public static void main(String [] args)
	{	
	   //ArrayList<Number> al = new ArrayList<Integer>(); [Compile time]
	   //ArrayList al = new ArrayList();  [Runtime]
	   //al.add("Ravi");
	     

		Object []obj = new String[3]; //valid with Array
		obj[0] = "Ravi";
		obj[1] = "hyd";
		obj[2] =  90; //java.lang.ArrayStoreException
		System.out.println(Arrays.toString(obj));
	}
}
----------------------------------------------------------------

Wild card character(?) :
------------------------
<?>			-: Many possibilities

<Animal>		-: Only <Animal> can assign, but not Dog                             or sub type of animal

<? super Dog>	-: Dog, Animal, Object can assign (Compiler has                      surity)

<? extends Animal> -: Below of Animal(Child of Animal) means, sub classes of Animal (But the compiler does not have surity because you can have many sub classes of Animal in the future, so chances of wrong collections)
----------------------------------------------------------------
import java.util.*;
class Parent
{
}
class Child extends Parent
{
}

public class Test11
{
public static void main(String [] args)
	{	
		ArrayList<?> lp = new ArrayList<Child>();

		ArrayList<Parent> lp1 = new ArrayList<Parent>(); 

		ArrayList<Child> lp2 = new ArrayList<>(); 

		System.out.println("Success");
	}
}
---------------------------------------------------------------
//program on wild-card chracter
import java.util.*;
class Parent
{

}
class Child extends Parent
{
}
public class Test12
{
public static void main(String [] args)
	{	
		List<?> lp = new ArrayList<Parent>(); 
		System.out.println("Wild card....");
	}
}
----------------------------------------------------------------
import java.util.*;
public class Test13 
{
	public static void main(String[] args) 
	{
		List<? extends Number> list1 = new ArrayList<Integer>();

		List<? super String> list2 = new ArrayList<Object>();

		List<? super Beta> list3 = new ArrayList<Alpha>();

		List list4 = new ArrayList();
		
		System.out.println("yes");
	}
}

class Alpha
{
}
class Beta extends Alpha
{
}
class Gamma extends Alpha
{
}
----------------------------------------------------------------
class Test<R,A>
{
	private R r;
	public void set(A a) 
	{
		r = a;
	}
	
	public R get() 
	{
		return r;
	}
}
public class Test14 
{
   public static void main(String[] args) 
   {
      Test<String,String> test = new Test(); 
      test.set("Info");
      System.out.println(test.get());
   }
}
---------------------------------------------------------------
class MyClass<T>     
{
	T obj;
	public MyClass(T obj)       //obj = new Student(
	{
		this.obj=obj;
	}

	T getObj()
	{
		return obj;
	}
}
public class Test15
{
	public static void main(String[] args) 
	{
		Integer i=12;
		MyClass<Integer> mi = new MyClass<>(i);
		System.out.println("Integer object stored :"+mi.getObj());

		Float f=12.34f;
		MyClass<Float> mf = new MyClass<>(f);
		System.out.println("Float object stored :"+mf.getObj());

		MyClass<String> ms = new MyClass<>("Rahul");
		System.out.println("String object stored :"+ms.getObj());

		MyClass<Boolean> mb = new MyClass<>(false);
		System.out.println("Boolean object stored :"+mb.getObj());

		Double d=99.34;
		MyClass<Double> md = new MyClass<>(d);
		System.out.println("Double object stored :"+md.getObj());

		MyClass<Student> std = new MyClass<>(new Student(1,"A"));
		System.out.println("Student object stored :"+std.getObj());
	}
}

record Student(int id, String name)
{

}
----------------------------------------------------------------
T -> Type Parameter
E -> Element Type

//E stands for Element type
class Fruit    
{
}
class Apple extends Fruit   //Fruit is super, Apple is sub class
{
	@Override
	public String toString()
	{
		return "Apple";
	}
}

class Basket<E>   // E is fruit type 
{
	private E element;  	
	public void setElement(E element) //Fruit element = new Apple();
	{
		this.element = element;
	}	

	public E getElement() // public Fruit getElement{}
	{
		return this.element;		
	}
}

public class Test16
{
	public static void main(String[] args) 
	{
		Basket<Fruit> b = new Basket<>();
		b.setElement(new Apple());

		Apple x = (Apple) b.getElement();	
		System.out.println(x);

       
        Basket<Fruit> b1 = new Basket<>();
		b1.setElement(new Mango());
		Mango y = (Mango)b1.getElement();	
		System.out.println(y);
		
	}
}
class Mango extends Fruit
{
	@Override
	public String toString()
	{
		return "Mango";
	}
}
----------------------------------------------------------------
Queue interface :
-----------------

Queue interface :-
-------------------
1) It is sub interface of Collection(I)

2) It works in FIFO(First In first out) 

3) It is an ordered collection.

4) In a queue, insertion is possible from last is called REAR where as deletion is possible from the starting is called FRONT of the queue.

5) From jdk 1.5 onwards LinkedList class implments Queue interface to handle the basic queue operations. 


PriorityQueue :
----------------
public class PriorityQueue extends AbstractQueue implements Serializable 

It is a predefined class in java.util package, available from Jdk 1.5 onwards.

It inserts the elements based on the priority HEAP (Using Binary tree).

The elements of the priority queue are ordered according to their natural ordering, or by a Comparator provided at queue construction time, depending on which constructor is used.

A priority queue does not permit null elements as well as It uses Binary tree to insert the elements.

It provides natural sorting order so we can't take non-comparable objects(hetrogeneous types of Object)

The initial capacity of PriorityQueue is 11.

Constructor :
--------------
1) PriorityQueue pq1 = new PriorityQueue();

2) PriorityQueue pq2 = new PriorityQueue(int initialCapacity);

3) PriorityQueue pq3 = new PriorityQueue(int initialCapacity, Comparator cmp);

4-) PriorityQueue pq3 = new PriorityQueue(Comparator cmp);


5) PriorityQueue pq4 = new PriorityQueue(Collection c);

Methods :-
----------
add() / offer() :- Used to add an element in the Queue

poll() :- It is used to fetch the elements from top of the queue, after fetching it will delete the element.


peek() :- It is also used to fetch the elements from top of the queue, Unlike poll it will only fetch but not delete the element.

boolean remove(Object element) :- It is used to remove an element. The return  type is boolean. 
----------------------------------------------------------------

import java.util.PriorityQueue;

public class PriorityQueueDemo 
{
      public static void main(String[] argv)
      {
            PriorityQueue<String> pq = new PriorityQueue<>();
            pq.add("Orange");
			pq.add("Apple");
			pq.add("Mango");
			pq.add("Guava");
			pq.add("Grapes");	
			
			System.out.println(pq);            

      }
}
--------------------------------------------------------------
import java.util.PriorityQueue;
public class PriorityQueueDemo1 
{
      public static void main(String[] argv) 
      {
            PriorityQueue<String> pq = new PriorityQueue<>();
            pq.add("9");     
            pq.add("8");
			pq.add("7");
            System.out.print(pq.peek() + " "); //7 3  5  6
            pq.offer("6");      
			pq.offer("5");
            pq.add("3");

            pq.remove("1");    
            System.out.print(pq.poll() + " ");
            if (pq.remove("2"))
                System.out.print(pq.poll() + " ");
            System.out.println(pq.poll() + " " + pq.peek());
			System.out.println(pq); 
      }
}
---------------------------------------------------------------
import java.util.PriorityQueue;
public class PriorityQueueDemo2
{
      public static void main(String[] argv)
      {
            PriorityQueue<String> pq = new PriorityQueue<>();
            pq.add("2");
            pq.add("4");          
			pq.add("6");  //      6   9   
            System.out.print(pq.peek() + " "); //2  2  3  4  4
            pq.offer("1");
			pq.offer("9");
            pq.add("3");   
			
            pq.remove("1");
            System.out.print(pq.poll() + " "); 
            if (pq.remove("2"))
                System.out.print(pq.poll() + " ");
            System.out.println(pq.poll() + " " + pq.peek()+"  "+pq.poll());
	  }
}
----------------------------------------------------------------
import java.util.PriorityQueue;
public class PriorityQueueDemo3
{
      public static void main(String[] argv)
      {
            PriorityQueue<Integer> pq = new PriorityQueue<>();
			pq.add(11);
            pq.add(2);
            pq.add(4);          
			pq.add(6);
           System.out.println(pq);
	  }
}
----------------------------------------------------------------
07-05-2024
-----------
Concurrent collections in java
-------------------------------
Concurrent Collections are introduced from JDK 1.5 onwards to enhance the performance of multithreaded application.

These are threadsafe collection and available in java.util.concurrent sub package.

Limitation of Traditional Collection :
---------------------------------------
1) In the Collection framework most of the Collection classes are not thread-safe because those are non-synchronized like ArrayList, LinkedList, HashSet, HashMap is non-synchronized in nature, So If multiple threads will perform any operation on the collection object simultaneously then we will get some wrong data this is known as Data race or Race condition.

2) Some Collection classes are synchronized like Vector, Hashtable but performance wise these classes are slow in nature.

Collections class has provided static methods to make our List, Set and Map interface classes as a synchronized.
			
	a) public static List synchronizedList(List list)
	b) public static Set synchronizedSet(Set set)
	c) public static Map synchronizedMap(Map map)

3) Traditional Collection works with fail fast iterator that means while iterating the element,
     if there is a change in structure then we will get ConcurrentModificationException,
     On the other hand concurrent collection works with fail safe iterator where even though there is a change in structure but we will not get ConcurrentModificationException.
----------------------------------------------------------------
import java.util.*;
public class Collection1
{
     public static void main(String args[])
     {
          ArrayList al = new ArrayList();
          al.add(10);
          al.add(20);
          al.add(30);
          al.add(40);
          al.add(50);
		  al.add(50);
          System.out.println("Arraylist Elements : "+al);
          Set s = new HashSet(al);         
          System.out.println("Set Elements are: "+s);
     } 
}
----------------------------------------------------------------
//Collections.synchronizedList(List list);
import java.util.*;
public class Collection2 
{
	public static void main(String[] args) 
	{
		ArrayList<String> arl = new ArrayList<>();   
		arl.add("Apple");   
		arl.add("Orange");
		arl.add("Grapes");
		arl.add("Mango");
		arl.add("Guava");
		arl.add("Mango");

		List<String> syncCollection = Collections.synchronizedList(arl);

		List<String> upperList = new ArrayList<>(); //New List
    
		Runnable listOperations = () -> 
		{
			synchronized (syncCollection) 
			{
               syncCollection.forEach(str -> upperList.add(str.toUpperCase()));           
           }
       };

	   Thread t1 = new Thread(listOperations);
	   t1.start();

      upperList.forEach(x -> System.out.println(x));
	}
}
----------------------------------------------------------------
//Collections.synchronizedSet(Set set);
import java.util.*;  
public class Collection3
{  
    public static void main(String[] args) 
		{  
        Set<String> set = Collections.synchronizedSet(new HashSet<>());  
        set.add("Apple");   
		set.add("Orange");
		set.add("Grapes");
		set.add("Mango");
		set.add("Guava");
		set.add("Mango");           
        System.out.println("Set after Synchronization :");  
        synchronized (set) 
		{  
           Spliterator<String> itr = set.spliterator();
		   itr.forEachRemaining(str -> System.out.println(str));  
         }       
     }  
}  

---------------------------------------------------------------
//Collections.synchronizedMap(Map map);
import java.util.*;  
public class Collection4
{  
    public static void main(String[] args) 
	{  
        Map<String, String> map = new HashMap<String, String>();  
        map.put("1", "Ravi");  
        map.put("4", "Elina");  
        map.put("3", "Aryan");  
        Map<String, String> synmap = Collections.synchronizedMap(map);  
        System.out.println("Synchronized map is :" + synmap);                 
     }  
}  
----------------------------------------------------------------
import java.util.*;
class ConcurrentModification extends Thread
{
	ArrayList<String> al = null;
	public ConcurrentModification(ArrayList<String> al) //al = arl
	{
		this.al = al;
	}

	@Override
	public void run()
	{
		try
		{
			Thread.sleep(1000);
		}
		catch (InterruptedException e)
		{
		}
		al.add("KIWI");
	}
}
public class Collection5  
{
	public static void main(String[] args) throws InterruptedException
	{
		ArrayList<String> arl = new ArrayList<>();
		arl.add("Apple");   
		arl.add("Orange");
		arl.add("Grapes");
		arl.add("Mango");
		arl.add("Guava");

		ConcurrentModification cm = new ConcurrentModification(arl);

		cm.start();

		Iterator<String> itr = arl.iterator();
        while(itr.hasNext())
		{
			String str = itr.next();
			System.out.println(str);
			Thread.sleep(1500);
		}
	}
}

Note :- In the above program we will get java.util.ConcurrentModificationException because Iterator is fail fast iterator.
----------------------------------------------------------------
CopyOnWriteArrayList in java :
---------------------------------
public class CopyOnWriteArrayList implements List, Cloneable, Serializable, RanomAccess

A CopyOnWriteArrayList is similar to an ArrayList but it has some additional features like thread-safe. This class is existing in java.util.concurrent sub package.

ArrayList is not thread-safe. We cant use ArrayList in the multi-threaded environment because it creates a problem in ArrayList values  (Data inconsistency).

*The CopyOnWriteArrayList is an enhanced version of ArrayList. If we are making any modifications(add, remove, etc.)  in  CopyOnWriteArrayList then JVM creates a new copy by use of Cloning.

The CopyOnWriteArrayList is costly, if we want to perform update operations, because whenever we make any changes the JVM creates a cloned copy of the  array and add/update element to it.

It is a thread-safe version of ArrayList as well as here Iterator is fail safe iterator. Multiple threads can read the data but only one thread can write the data at one time.

*CopyOnWriteArrayList is the best choice if we want to perform read operation frequently in multithreaded environment.

The CopyOnWriteArrayList is a replacement of a synchronized List, because it offers better concurrency.

Constructors of CopyOnWriteArrayList in java :
----------------------------------------------------
We have 3 constructors :

1) CopyOnWriteArrayList c = new CopyOnWriteArrayList(); 
It creates an empty list in memory. This constructor is useful when we want to create a list without any value.

2) CopyOnWriteArrayList c = new CopyOnWriteArrayList(Collection c);
Interconversion of collections.

3) CopyOnWriteArrayList c = new CopyOnWriteArrayList(Object[] obj) ;
It Creates a list that containing all the elements that is specified Array. This constructor is useful when we want to create a CopyOnWriteArrayList from Array.
----------------------------------------------------------------
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

public class CopyOnWriteArrayListExample1
{
    public static void main(String[] args) 
    {
        List<String> list = Arrays.asList("Apple", "Orange", "Mango","Kiwi", "Grapes");

		
        CopyOnWriteArrayList<String> copyOnWriteList = new CopyOnWriteArrayList<String>(list);
         
        System.out.println("Without modification = "+copyOnWriteList); 
        
		 //Iterator1
        Iterator<String> iterator1 = copyOnWriteList.iterator();
         
        //Add one element and verify list is updated
        copyOnWriteList.add("Guava");
         
        System.out.println("After modification = "+copyOnWriteList);   
         
        //Iterator2
        Iterator<String> iterator2 = copyOnWriteList.iterator();
         
        System.out.println("Element from first Iterator:");
        iterator1.forEachRemaining(System.out::println);

        System.out.println("Element from Second Iterator:");
        iterator2.forEachRemaining(System.out::println);   
    }
}
---------------------------------------------------------------
import java.util.*;
import java.util.concurrent.*;
class ConcurrentModification extends Thread
{
	CopyOnWriteArrayList<String> al = null;
	public ConcurrentModification(CopyOnWriteArrayList<String> al)
	{
		this.al = al;
	}
	@Override
	public void run()
	{			
		try
		{
			Thread.sleep(1000);
		}
		catch (InterruptedException e)
		{
		}
	    al.add("KIWI");
	}
}
public class CopyOnWriteArrayListExample2  
{
	public static void main(String[] args) throws InterruptedException
	{
		CopyOnWriteArrayList<String> arl = new CopyOnWriteArrayList<>();
		arl.add("Apple");   
		arl.add("Orange");
		arl.add("Grapes");
		arl.add("Mango");
		arl.add("Guava");
		ConcurrentModification cm = new ConcurrentModification(arl);
		cm.start();
			
		Iterator<String> itr = arl.iterator();
        while(itr.hasNext())
		{
			String str = itr.next();
			System.out.println(str);
		   Thread.sleep(1500);
		}

	    System.out.println("............");

		Spliterator<String> spl =  arl.spliterator();
		spl.forEachRemaining(x -> System.out.println(x));
	}
}
---------------------------------------------------------------
08-05-2024
----------
CopyOnWriteArraySet :
--------------------------
public class CopyOnWriteArraySet extends AbstractSet implements Serializable

A CopyOnWriteArraySet is a thread-safe version of HashSet in Java and it works like CopyOnWriteArrayList in java. 

The CopyOnWriteArraySet internally used CopyOnWriteArrayList to perform all type of operation.It means the CopyOnWriteArraySet internally creates an object of CopyOnWriteArrayList and perform operation on it. 

Whenever we perform add, set, and remove operation on CopyOnWriteArraySet, it internally creates a new object of CopyOnWriteArrayList and copies all the data to the new object. So, when it is used in by multiple threads, it doesnt create a problem, but it is well suited if we have small size collection and want to perform only read operation by multiple threads.

 The CopyOnWriteArraySet is the replacement of synchronizedSet and offers better concurrency.

It creates a new copy of the array every time iterator is created, so performance is slower than HashSet.

Constructors :
----------------
It has two constructors 

1) CopyOnWriteArraySet set1 = new CopyOnWriteArraySet();
    It will create an empty Set


2) CopyOnWriteArraySet set1 = new CopyOnWriteArraySet(Collection c); Interconversion of collection
----------------------------------------------------------------
import java.util.*;
import java.util.concurrent.CopyOnWriteArraySet;
import java.util.concurrent.CopyOnWriteArraySet;

public class CopyOnWriteArraySetExample1
{
  public static void main(String[] args) 
   {
        CopyOnWriteArraySet<String> set = new CopyOnWriteArraySet<>();

        set.add("Java");
        set.add("Python");
        set.add("C++");
		set.add("Java");

        Iterator itr = set.iterator();
		while(itr.hasNext())
	    {
			System.out.println(itr.next());
	    }

        // Adding a new element
        set.add("JavaScript");
        System.out.println("............");
        for (String language : set) 
		{
            System.out.println(language);
        }
    }
}
----------------------------------------------------------------
import java.util.concurrent.CopyOnWriteArraySet;

public class CopyOnWriteArraySetExample2
{
    public static void main(String[] args) 
    {
        CopyOnWriteArraySet<Integer> set = new CopyOnWriteArraySet<Integer>();
        set.add(1);
        set.add(2);
        set.add(3);
        set.add(4);
        set.add(5);
        
        System.out.println("Is element contains: "+set.contains(1));
        
        System.out.println("Is set empty: "+set.isEmpty());
        
        System.out.println("remove element from set: "+set.remove(3));
        
        System.out.println("Element from Set: "+ set);
    }
}
----------------------------------------------------------------
*** ConcurrentHashMap :
-----------------------
public class ConcurrentHashMap<K,V> extends AbstractMap<K,V> implements ConcurrentMap<K,V>, Serializable

Like HashMap, ConcurrentHashMap provides similar functionality except that it has internally maintained concurrency. 

It is the concurrent version of the HashMap. It internally maintains a Hashtable that is divided into segments(Buckets). 

The number of segments depends upon the level of concurrency required the Concurrent HashMap. By default, it divides into 16 segments and each Segment behaves independently. It doesnt lock the whole HashMap as done in Hashtables/synchronizedMap, it only locks the particular segment(Bucket) of HashMap. [Bucket level locking]

ConcurrentHashMap allows multiple threads can perform read operation without locking the ConcurrentHashMap object.

It does not allow null as a key or evan null as a value.

[Note :- TreeSet, TreeMap, Hashtable, PriroityQueue, ConcurrentHashMap , These 5 classes never containing null key or null element)

It contains 5 types of constructor :
----------------------------------------
1) ConcurrentHashMap chm1 = new ConcurrentHashMap();

2) ConcurrentHashMap chm2 = new ConcurrentHashMap(int initialCapacity);

3) ConcurrentHashMap chm3 = new ConcurrentHashMap(int initialCapacity, float loadFactor);

4) ConcurrentHashMap chm4 = new ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel);

5) ConcurrentHashMap chm5 = new ConcurrentHashMap(ConcurrentMap m);

Internal Working of ConcurrentHashMap :
-----------------------------------------------
Like HashMap and Hashtable, the ConcurrentHashMap is also used Hashtable data structure. But it is using the segment locking strategy to handle the multiple threads. 

A segment(bucket) is a portion of ConcurrentHashMap and ConcurrentHashMap uses a separate lock for each thread. Unlike Hashtable or synchronized HashMap,  it doesnt synchronize the whole HashMap or Hashtable for one thread.

As we have seen in the internal implementation of the HashMap, the default size of HashMap is 16 and it means there are 16 buckets. The ConcurrentHashMap uses the same concept is used in ConcurrentHashMap. It uses the 16 separate locks for 16 buckets by default because the default concurrency level is 16. It means a ConcurrentHashMap can be used by 16 threads at same time. If one thread is reading from one bucket(Segment), then the second bucket doesnt affect it.  

Why we need ConcurrentHashMap in java?
-------------------------------------------------
As we know Hashtable and HashMap works based on key-value pairs. But why we are introducing another Map? As we know HashMap is not thread safe, but we can make it thread-safe by using Collections.synchronizedMap() method and Hashtable is thread-safe by default.  

But a synchronized HashMap or Hashtable is accessible only by one thread at a time because the object get the lock for the whole HashMap or Hashtable. Even multiple threads cant perform read operations at the same time. It is the main disadvantage of Synchronized HashMap or Hashtable, which creates performance issues. So ConcurrentHashMap provides better performance than Synchronized HashMap or Hashtable.
----------------------------------------------------------------
import java.util.HashMap;
import java.util.concurrent.ConcurrentHashMap;

public class ConcurrentHashMapExample1
{
   public static void main(String args[])
   {
       
       HashMap<Integer, String> hashMap = new HashMap<Integer, String>();
       hashMap.put(1, "Ravi");
       hashMap.put(2, "Ankit");
       hashMap.put(3, "Prashant");
	   hashMap.put(4, "Pallavi");
       
       ConcurrentHashMap<Integer, String> concurrentHashMap = new ConcurrentHashMap<>(hashMap);
       System.out.println("Object from ConcurrentHashMap: "+ concurrentHashMap);

   }
 
}
----------------------------------------------------------------
import java.util.Iterator;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class ConcurrentHashMapExample2
{
   public static void main(String args[])
   { 
       // Creating ConcurrentHashMap
       Map<String, String> cityTemperatureMap = new ConcurrentHashMap<>();
        
        cityTemperatureMap.put("Delhi", "30");
        cityTemperatureMap.put("Mumbai", "32");
        cityTemperatureMap.put("Chennai", "35");
        cityTemperatureMap.put("Bangalore", "22" );
        
        Iterator<String> iterator = cityTemperatureMap.keySet().iterator();  

        while (iterator.hasNext())
        {
          System.out.println(cityTemperatureMap.get(iterator.next()));
          // adding new value, it won't throw error
          cityTemperatureMap.put("Hyderabad", "28");   
        }
   }
}

we can easily add an entry in the concurrenthashmap, even at the time of of fetching the data using iterator, It is working because internally it uses bucket level locking.
---------------------------------------------------------------
Streams in java :
------------------
It is introduced from Java 8 onwards, the Stream API is used to process the collection objects.

It contains classes for processing sequence of elements over Collection object and array.

Stream is a predefined interface available in java.util.stream sub package.

Package Information :
---------------------
java.util -> Base package
java.util.function -> Functional interfaces
java.util.concurrent -> Multithreaded support
java.util.stream -> Processing of Collection Object

forEach() method in java :
-----------------------------
The Java forEach() method is a  technique to iterate over a collection such as (list, set or map) and stream. It is used to perform a given action on each of the element of the collection.

The forEach() method has been added in following places:

Iterable interface  This makes Iterable.forEach() method available to all collection classes. Iterable interface is the super interface of Collection interface

Map interface  This makes forEach() operation available to all map classes.

Stream interface  This makes forEach() operations available to all types of stream.
-----------------------------------------------------------------
Creation of Streams to process the data :
-----------------------------------------------
We can create Stream from  collection or array with the help of stream() and of() methods:

A stream()  method is added to the Collection interface and allows creating a Stream<T> using any collection object as a source

public java.util.Stream<E> stream();

The return type of this method is Stream interafce available in java.util.stream sub package.

Eg:-
List<String> items = new ArrayList<String>();
		items.add("Apple");
		items.add("Orange");
		items.add("Mango");
		Stream<String> stream = items.stream();

-----------------------------------------------------------------
package com.ravi.basic;
import java.util.*;  //Base package
import java.util.stream.*; //Sub package
public class StreamDemo1 
{
	public static void main(String[] args) 
	{
		List<String> items = new ArrayList<>();

		items.add("Apple");
		items.add("Orange");
		items.add("Mango");

        //Collections Object to Stream
		Stream<String> strm = items.stream();
		strm.forEach(p -> System.out.println(p));
	}
}
------------------------------------------------------------------
Stream.of()       
--------------
public static java.util.stream.Stream  of(T ...x)
-----------------------------------------------------
It is a static method of Stream interface through which we can create Stream of arrays and Stream of Collection. The return type of this method is Stream interface

//Stream.of()
package com.ravi.basic;
import java.util.stream.*;
public class StreamDemo2 
{
	public static void main(String[] args) 
	{
		//Stream of Collection
		Stream<Integer> stream = Stream.of(1,2,3,4,5,6,7,8,9);
		stream.forEach(p -> System.out.println(p));

		System.out.println("...............................");

         //Anonymous Array Object (Stream of Arrays)
		Stream<Integer> strm = Stream.of( new Integer[]{15,29,45,8,16} );
		strm.forEach(p -> System.out.println(p));
	}
}
---------------------------------------------------------------
Intermediate Operations:
------------------------
filter(Predicate<T> predicate): Returns a new stream which contains filtered elements based on the boolean expression using Predicate.

map(Function<T, R> mapper): Transforms elements in the stream using the provided mapping function.  

flatMap(Function<T, Stream<R>> mapper): Flattens a stream of streams into a single stream. 

distinct(): Returns a stream with distinct elements (based on their equals method).

sorted(): Returns a stream with elements sorted in their natural order.

sorted(Comparator<T> comparator): Returns a stream with elements sorted using the specified comparator.

peek(Consumer<T> action): Allows us to perform an action on each element in the stream without modifying the stream.

limit(long maxSize): Limits the number of elements in the stream to a specified maximum size.

skip(long n): Skips the first n elements in the stream.

takeWhile(Predicate<T> predicate): Returns a stream of elements from the beginning until the first element that does not satisfy the predicate.

dropWhile(Predicate<T> predicate): Returns a stream of elements after skipping elements at the beginning that satisfy the predicate.
------------------------------------------------------------------
-----------------------------------------------------------------
public abstract Stream<T> filter(Predicate<T> p) : 
----------------------------------------------------
It is a predfined method of Stream interface. It is used to select/filter elements as per the Predicate passed as an argument. It is basically used to filter the elements based on boolean condition.

public abstract <T>  collect(java.util.stream.Collectors c)
----------------------------------------------------------------
It is a predfined method of Stream interface. It is used to return the result of the intermediate operations performed on the stream.

It is a terminal operation. It is used to collect the data after filteration and convert the data to the Collection(List/Set).

Collectors is a predfined final class available in java.util.stream sub package which conatins a static method toList() and toSet() to convert the data as a List/Set i.e Collection object. The return type of this method is List/Set interface.
-----------------------------------------------------------------
//Filter all the even numbers from Collection 
package com.ravi.basic;
import java.util.*;
import java.util.stream.*;
public class StreamDemo3 
{
	public static void main(String[] args) 
	{
		List<Integer> list = Arrays.asList(1,2,3,4,5,6,7,8,9,10,3, 10);

          //Without Stream
          List<Integer> listEven = new ArrayList<Integer>();

		  for(Integer i : list)
			{
			       if(i%2==0)
				      listEven.add(i);
			}
            System.out.println(listEven);
           System.out.println(".........................................");

           //By using Stream API
           System.out.println("Using for Each method");
           list.stream().filter(num -> num%2==0).forEach(System.out::println);
           
 System.out.println("..........................");
 
           System.out.println("Using Collectors.toList()");
           List<Integer> listOfEven = list.stream().filter(num -> num%2==0).collect(Collectors.toList());
        listOfEven.forEach(System.out::println);
        
        System.out.println("Using Collectors.toSet()");
             Set<Integer> setOfOdd = list.stream().filter(num-> num%2==1).collect(Collectors.toSet());
             setOfOdd.forEach(System.out::println);
        
	}
}
------------------------------------------------------------------
//Filtering the name
package com.ravi.basic;
import java.util.*;
import java.util.stream.*;
public class StreamDemo4 
{
	public static void main(String[] args) 
	{
		List<String> list = Arrays.asList("Ravi", "Rahul", "Akshar", "Roshan","Raj","Ankit","Ravi");		

		list.stream().filter(str -> str.startsWith("R")).sorted().distinct().forEach(System.out::println);		
    
	}
}
------------------------------------------------------------------
//Sorting the data
package com.ravi.basic;
import java.util.*;
import java.util.stream.*;
public class StreamDemo5 
{
	public static void main(String[] args) 
	{
	List<String> names = Arrays.asList("Zaheer","Rahul","Aryan","Sailesh");

		List<String> sortedName =
            names.stream().sorted().collect(Collectors.toList());
		
        System.out.println(sortedName);
	}
}
-----------------------------------------------------------------
package com.ravi.basic;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

record Customer(int cid, String cname, double custBill)
{
	
}

public class StreamDemo6 
{  
    public static void main(String[] args) 
	{  
       ArrayList<Customer> al = new ArrayList<>(); 
       al.add(new Customer(1, "Aryan", 27000));
       al.add(new Customer(2, "Bina", 37000));
       al.add(new Customer(3, "karan", 47000));
       al.add(new Customer(4, "Deepak", 57000));
       
       //Print all customers records whose Bill is > 30000
       
       List<Customer> listOfCustomer = al.stream().filter(cust -> cust.custBill()>30000).collect(Collectors.toList());
       
       listOfCustomer.forEach(System.out::println);
             
	}
}  
--------------------------------------------------------------
public Stream map(Function<T,R> mapper) :
-------------------------------------------------
It is a predefined method of Stream interface.

It takes Function (Predefined functional interafce ) as a parameter.

It performs intermediate operation and consumes single element from input Stream and produces single element to output Stream. (1:1 transformation)

Here mapper function is functional interface which takes one input and provides one output.
------------------------------------------------------------------
package com.ravi.basic;

import java.util.List;

public class MapMethod 
{
	public static void main(String[] args) 
	{
         List<Integer> numbers = List.of(1,2,3,4,5,6,7,8,9,10);
         
         numbers.stream().filter(n -> n%2==0).map(num -> num*10).forEach(System.out::println);
         
         


	}

}
-----------------------------------------------------------------
//Find even numbers in stream and collect the cubes
package com.ravi.basic;
import java.util.List;
import java.util.stream.Collectors;
 
public class StreamDemo7 
{
    public static void main(String[] args) 
    {
    	List<Integer> numbers =    List.of(1,2,3,4,5,6,7,8,9,10);  
    	               
        
        
        List<Integer> cubeOfNum = numbers.stream().filter(n -> n%2==0).map(x -> x*x*x).collect(Collectors.toList());
        System.out.println(cubeOfNum);     
        
        System.out.println("................");
        List<String> listOfString =       List.of("Raj","Rahul","Hyderabad", "ArrayIndexOutOfBoundsException");
        
        listOfString.stream().map(str -> str.toUpperCase()).forEach(System.out::println);        
    }
}
------------------------------------------------------------------
//Program on map(Function<T,R> mapped)
package com.ravi.basic;
import java.util.*;
import java.util.stream.*;
public class StreamDemo8
{ 
	public static void main(String args[])
	{
		List<Player> players = createMyPlayerList();
		
		//Journey from Player object to name of the player
		Set<String> playersName = players.stream().map(p -> p.name()).collect(Collectors.toSet());
		playersName.forEach(System.out::println);
		
	}		
	
	public static List<Player> createMyPlayerList()
	{
		List<Player> listOfPlayers = new ArrayList<>();
		listOfPlayers.add(new Player("Virat",32));
		listOfPlayers.add(new Player("Rohit",33));
		listOfPlayers.add(new Player("Shami",34));
		listOfPlayers.add(new Player("Siraj",28));
		listOfPlayers.add(new Player("Sarfaraj",26));
		listOfPlayers.add(new Player("Virat",32));
		
		return listOfPlayers;
	}
}
 
record Player(String name, int age)
{
	
}
-----------------------------------------------------------------
public Stream flatMap(Function<? super T,? extends Stream<? extends R>> mapper)
---------------------------------------------------------
It is a predefined method of Stream interface.

The map() method produces one output value for each input value in the stream. So if there are n elements in the stream, map() operation will produce a stream of n output elements.

flatMap() is two step process i.e. map() + Flattening. It helps in converting Collection<Collection<T>> to Collection<T> [to make flat i.e converting Collections of collection into single collection or merging of all the collection]
------------------------------------------------------------------
//flatMap()
//map + Flattening [Converting Collections of collection into single collection]
package com.ravi.basic;
import java.util.*;
import java.util.stream.*;
public class StreamDemo9  
{
	public static void main(String[] args) 
	{
		List<String> list1 = Arrays.asList("A","B","C");
		List<String> list2 = Arrays.asList("D","E","F");
		List<String> list3 = Arrays.asList("G","H","I");
		 
		List<List<String>> listOfLists = Arrays.asList(list1, list2, list3);
		System.out.println(listOfLists); 
		System.out.println("...............");
        //Using flatMap() to convert Collections of collection into single collection
		
		List<String> collect = listOfLists.stream().flatMap(list -> list.stream()).collect(Collectors.toList());
		System.out.println(collect);
		
		
	}
}
---------------------------------------------------------------
10-05-2024
-----------
//Flattening of prime, even and odd number
package com.ravi.basic.flat_map;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class FlatMapDemo1 
{
	public static void main(String[] args)
	{
      List<Integer> primeNumbers = Arrays.asList(5,7,11);
      List<Integer> evenNumbers = Arrays.asList(2,4,6);
      List<Integer> oddNumbers = Arrays.asList(1,3,5);
      
      List<List<Integer>> listOfCollection = Arrays.asList(primeNumbers, evenNumbers, oddNumbers);
      System.out.println(listOfCollection);
      
      List<Integer> collect = listOfCollection.stream().flatMap(num -> num.stream()).collect(Collectors.toList());
      
  System.out.println(collect);
      
	
	
	}

}
---------------------------------------------------------------
//Fetching first character using flatMap()
package com.ravi.basic.flat_map;

import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class FlatMapDemo2 
{
	public static void main(String[] args)
	{
		List<String> asList = Arrays.asList("Jyoti","Ankit","Vaibhab","Aman");
		
		asList.stream().flatMap(str -> Stream.of(str.charAt(0))).forEach(ch -> System.out.print(ch));
		
		
	}

}
---------------------------------------------------------------
//Retrieving List of Product
package com.ravi.basic.flat_map;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

class Product 
{
	private Integer productId;
	private List<String> listOfProducts;

	public Product(Integer productId, List<String> listOfProducts)       
	{
		super();
		this.productId = productId;
		this.listOfProducts = listOfProducts;

	}

	public Integer getProductId() {
		return productId;
	}

	public List<String> getListOfProducts() {
		return listOfProducts;
	}
}

public class FlatMapDemo3 
{
	public static void main(String[] args) 
	{

		List<Product> listOfProduct = Arrays.asList(
	new Product(1, Arrays.asList("Camera", "Mobile", "Laptop")),
	new Product(2, Arrays.asList("Bat", "Ball", "Wicket")),
	new Product(3, Arrays.asList("Chair", "Table", "Lamp")),
	new Product(4, Arrays.asList("Cycle", "Bike", "Car"))

		);

		List<String> collect = listOfProduct.stream().flatMap(p -> p.getListOfProducts().stream())
				.collect(Collectors.toList());
		System.out.println(collect);

	}

}
---------------------------------------------------------------
**Difference between map() and flatMap()
--------------------------------------
map() method transforms each element into another single element.

flatMap() transforms each element into a stream of elements and then flattens those streams into a single stream.

We should use map() when you want a one-to-one transformation, and  we should use flatMap() when dealing with nested structures or when you need to produce multiple output elements for each input element.
--------------------------------------------------------------
public Stream sorted() :
------------------------
It is a predefined method of Stream interface.
It provides default natural sorting order.
The return type of this methof is Stream.

package com.ravi.basic;

import java.util.Arrays;
import java.util.List;

public class StreamSortedDemo 
{
	public static void main(String[] args) 
	{
		List<Integer> numbers = Arrays.asList(89,56,12,58,90,34);		
		numbers.stream().sorted().forEach(System.out::println);
		System.out.println(".........");
		numbers.stream().sorted((i1,i2)-> i2 - i1).forEach(System.out::println);

	}

}
--------------------------------------------------------------
public Stream distinct() :
--------------------------
It is a predefined method of Stream interface.

If we want to return stream from another stream by removing all the duplicates then we should use distinct() method.

package com.ravi.basic;
import java.util.stream.Stream;
public class StreamDemo10
{
	public static void main(String[] args)
		{
		Stream<String> s = Stream.of("Virat", "Rohit", "Dhoni", "Virat", "Rohit","Aswin","Bumrah");
		s.distinct().sorted((s1,s2)-> s2.compareTo(s1)).forEach(System.out::println);	
		
	}

}
---------------------------------------------------------------
public Stream<T> limit(long maxSize) :
----------------------------------------
It is a predefined method of Stream interface to work with sequence of elements.

The limit() method is used to limit the number of elements in a stream by providing maximum size.

It creates a new Stream by taking the data from original Stream.

Elements which are not in the range or beyond the range of specified limit will be ignored.
---------------------------------------------------------------
package com.ravi.basic;
import java.util.stream.Stream; 
public class StreamDemo11 
{
	public static void main(String[] args) 
	{
		Stream<Integer> numbers = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

		Stream<Integer> limitedStream = numbers.limit(6);

		limitedStream.forEach(System.out::println);
	}
}
---------------------------------------------------------------
public Stream<T> skip(long n) :
-------------------------------
It is a predefined method of Stream interface which is used to skip the elements from begning of the Stream.

It returns a new stream that contains the remaining elements after skipping the specified number of elements which is passed as a parameter.

package com.ravi.basic;
import java.util.stream.Stream; 
public class StreamDemo12 
{
	public static void main(String[] args) 
	{
		Stream<String> s = Stream.of("Virat", "Rohit", "Dhoni", "Zaheer", "Raina","Sahwag","Sachin","Bumrah");
		s.skip(3).limit(4).forEach(System.out::println);
	}
}
---------------------------------------------------------------
public Stream<T> peek(Consumer<? super T> action) :
--------------------------------------------
It is a predefined method of Stream interface which is used to perform a side-effect operation on each element in the stream while the stream remains unchanged.

It is an intermediate operation that allows us to perform operation on each element of Stream without modifying original.

The peek() method takes a Consumer as an argument, and this function is applied to each element in the stream. The method returns a new stream with the same elements as the original stream.
---------------------------------------------------------------
package com.ravi.basic;

import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class StreamDemo13 
{
	public static void main(String[] args) 
	{
		Stream<String> numbers = Stream.of("Apple","Mango","Grapes","Kiwi","pomogranate");

		List<Integer> doubledNumbers = numbers
		    .peek(str -> System.out.println("Peeking from Original: " + str.toUpperCase()))
		    .map(num -> num.length())
		    .collect(Collectors.toList());
		System.out.println("-----------------");
		System.out.println(doubledNumbers);
		
	}

}

Note :- peek(Consumer<T> cons) will not modify the Original Source.
---------------------------------------------------------------
public Stream<T> takeWhile(Predicate<T> predicate) : 
-----------------------------------------------------
It is a predefined method of Stream interface introduced from java 9 which is used to perform a side-effect operation on each element in the stream while the stream remains unchanged.

*It is used to create a new stream that includes elements from the original stream only as long as they satisfy a given predicate.

package com.ravi.basic;

import java.util.stream.Stream;

public class StreamDemo14 
{
 public static void main(String[] args) 
 {
	 Stream<Integer> numbers = Stream.of(10,11,9,13,2,1,100);

     numbers.takeWhile(n -> n > 9).forEach(System.out::println);     

     System.out.println(".......................");
    
     numbers = Stream.of(12,2,3,4,5,6,7,8,9);
     
     numbers.takeWhile(n -> n%2==0).forEach(System.out::println);
     
    
     System.out.println(".......................");
     
     numbers = Stream.of(1,2,3,4,5,6,7,8,9);
     
     numbers.takeWhile(n -> n < 9).forEach(System.out::println);
     
     System.out.println(".......................");
    
     numbers = Stream.of(11,2,3,4,5,6,7,8,9); 
     
     numbers.takeWhile(n -> n > 9).forEach(System.out::println);
    
     System.out.println(".............................");
     
     Stream<String> stream = Stream.of("Ravi", "Ankit", "Rohan", "Aman", "Ravish"); 

     stream.takeWhile(str -> str.charAt(0)=='R').forEach(System.out::println); 
     
    
     
	 
 }
}
---------------------------------------------------------------
public Stream<T> dropWhile(Predicate<T> predicate) :
----------------------------------------------------
It is a predefined method of Stream interface introduced from java 9 which is used to create a new stream by excluding elements from the original stream as long as they satisfy a given predicate.

package com.ravi.basic;

import java.util.stream.Stream;

public class StreamDemo15 {

	public static void main(String[] args) 
	{
		Stream<Integer> numbers = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

		numbers.dropWhile(num -> num < 5).forEach(System.out::println);
		
		System.out.println("..................................");
		
		numbers = Stream.of(15, 8, 7, 9, 5, 6, 7, 8, 9, 10);

		numbers.dropWhile(num -> num > 5).forEach(System.out::println);
		
        
		
	}

}
---------------------------------------------------------------
11-05-2024
-----------
Optional<T> class in Java :
------------------------
It is a predefined final and immutable class available in java.util package from java 1.8v.

It is a container object which is used to represent an object (Optional object) that may or may not contain a non-null value.

If the value is available in the container, isPresent() method will return true and get() method will return the actual value.

It is very useful in industry to avoid NullPointerException.

Methods of Optional<T> class :
-------------------------------
1) public static Optional<T> ofNullable(T x) : 
-------------------------------------------
It will return the object of Optional class with specified value. If the specified value is null then this method will return an empty object of the optional class.

2) public boolean isPresent() :
--------------------------------
It will return true, if the value is available in the container otherwise it will return false.

3) public T get() :
--------------------
It will get/fetch the value from the container, if the value is not available then it will throw java.util.NoSuchElementException.

4) public T orElse(T defaultValue) : 
-------------------------------------
It will return the value, if available  otherwise it will return the specified default value.

5) public static Optional<T> of (T value) :
--------------------------------------------
It will return the optional object with the specified value that is non- null value.

6) public static Optional<T> empty() :
---------------------------------------
It will return an empty Optional Object.

7) public java.util.stream.Stream  stream() 
-------------------------------------------
 Conversion of optional to Stream.
--------------------------------------------------------------
//Program to verify whether the container has value or not 
package com.ravi.optional_class_demo;

import java.util.Optional;

public class OptionalDemo1 
{	
	public static void main(String[] args) 
	{
		String str = null;
		
		Optional<String> optional = Optional.ofNullable(str);	
		
		String orElse = optional.orElse("No value in container");
		System.out.println("Value by orElse :"+orElse);
		
					
		//Optional is containing value or not?
		if(optional.isPresent())
		{
			System.out.println("Value by get :"+optional.get());
		}
		else
		{
			System.err.println("No value is available in the container");
		} 
		
		
	}

}
--------------------------------------------------------------
//Writing different style of getter
package com.ravi.optional_class_demo;
import java.util.Optional;
class Employee
{
	private Integer empId;
	private String empName;
	
	public Employee() {}
	
	public Employee(Integer empId, String empName) 
	{
		super();
		this.empId = empId;
		this.empName = empName;
	}

	//Changing the style of writing getter method
	public Optional<Integer> getEmpId() 
	{
		return Optional.ofNullable(empId);
	}

	public Optional<String> getEmpName() 
	{
		return Optional.ofNullable(empName);
	}	
}

public class OptionalDemo2 
{
	public static void main(String[] args) 
	{
		Employee emp = new Employee(111,"Ravi");		
		//Employee emp = new Employee();
		
		Optional<Integer> empId = emp.getEmpId();
		if(empId.isPresent())
		{
			System.out.println(empId.get());
		}
		else
		{
			System.err.println("No id value ");
		}
		
		Optional<String> empName = emp.getEmpName();
		String name = empName.orElse("name is not available");
		System.out.println(name);
		         
	}
}
-------------------------------------------------------------
//Program to verify value is available or not
package com.ravi.optional_class_demo;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

public class OptionalDemo3
{
    public static void main(String[] args) 
    {
        List<Optional<String>> optionalList = new ArrayList<>();

        optionalList.add(Optional.of("Ameerpet"));
        optionalList.add(Optional.of("S.R Nagar"));
        optionalList.add(Optional.of("Begumpet"));
        optionalList.add(Optional.of("Koti")); 
        optionalList.add(Optional.empty());

        
        for (Optional<String> optional : optionalList) 
        {
            if (optional.isPresent()) 
            {
                System.out.println(optional.get());
            } 
            else 
            {
                System.out.println("No data is available");
            }
        }
    }
}
-------------------------------------------------------------

//Immutability of Optional class

package com.ravi.optional_class_demo;
import java.util.Optional;
public class OptionalDemo4
{
    public static void main(String[] args) 
    {        
        Optional<String> optl = Optional.of("India");
        System.out.println(optl.hashCode()); 

        Optional<String> newOptnl = modifyOptional(optl);
        System.out.println(newOptnl.hashCode());

        // Check if the original Optional is still the same
        System.out.println("Address is :" + (optl == newOptnl));       
      
    }

    public static Optional<String> modifyOptional(Optional<String> optional) 
    {
       
        if (optional.isPresent())
        {
            return Optional.of("Modified: " + optional.get());
        } 
        else 
        {
            return Optional.empty();
        }
    }
}

Here == operator provides false so, it is created in two different memory location.
--------------------------------------------------------------

Method Reference :
------------------
It is a new feature introduced from java 1.8 onwards.

It is mainly used to write concise coding.

By using method reference we can refer an existing method which is available at API level or Project level.

We can use this technique in the body of Lambda expression just to call method defination.

The enitire method body will be automatically placed into Lambda Expression.

It is used to enhance the code reusability.

It uses :: (Double Colon Operator)


Method Reference Examples :
----------------------------
MethodRef.java
----------------
package com.ravi.method_ref;

interface Worker
{
	void work();
}

class Employee
{
	public void work()
	{
		System.out.println("Employee is working");
	}
}


public class MethodRef {

	public static void main(String[] args) 
	{
		//By using Lambda
		Worker w1 = ()-> System.out.println("Worker is working");
		w1.work();
		
		//By using method reference
		Worker w2 = new Employee()::work;
		w2.work();

	}

}
---------------------------------------------------------------
package com.ravi.method_ref;

interface Worker
{
	void work();
}

class Employee
{
	public static void salary()
	{
		System.out.println("Employee Salary");
	}
}


public class MethodRef {

	public static void main(String[] args) 
	{
		Worker w1 = Employee::salary;
		w1.work();

	}

}
----------------------------------------------------------------
package com.ravi.method_ref;

interface Worker
{
	void work(double salary);
}

class Employee
{
	
	public static void salary()
	{
		System.out.println("Employee Salary");
	}
	
	public static void salary(double salary)
	{
		System.out.println("Scott Salary :"+salary);
	}
}


public class MethodRef {

	public static void main(String[] args) 
	{
		Worker w1 = Employee::salary;
		w1.work(23000);
		
	}

}
---------------------------------------------------------------
There are 4 types of method reference 

1) Static Method Reference(ClassName::methodName)
2) Instance Method Reference(objectReference::methodName)
3) Constructor Reference (ClassName::new)
4) Arbitrary Referenec (ClassName::instanceMethodName)


Programs on above references :
------------------------------
Static Method Reference :
-------------------------

package com.ravi.static_method_reference;

import java.util.Vector;

class EvenOrOdd   
{
	public static void isEven(int number) 
    {
        if (number % 2 == 0)
        {
            System.out.println(number + " is even");
        } 
        else 
        {
            System.out.println(number + " is odd");
        }
    }
}
public class StaticMethodReferenceDemo1 
{
	public static void main(String[] args) 
    {
       Vector<Integer> numbers = new Vector<>();          
       numbers.add(5);
       numbers.add(2);
       numbers.add(9);
       numbers.add(12);
       System.out.println("By using Lambda....");
       numbers.forEach(x -> EvenOrOdd.isEven(x));
       
       System.out.println("_______________________________");
       
       System.out.println("By using static method reference");        
       numbers.forEach(EvenOrOdd::isEven);
    }
}
---------------------------------------------------------------
Instance Method Reerence :
-------------------------
package com.ravi.instance_method_reference;

interface Trainer 
{
  void getTraining(String name, int experience);
}

class InstanceMethod 
{
   public void getTraining(String name, int experience)
   {
	   System.out.println("Trainer name is :"+name+" having "+experience+" years of experience.");
   }
}

public class InstanceMethodReferenceDemo 
{
    public static void main(String[] args) 
    {
    	//Using Lambda Expression
    	Trainer t1 = (name,  exp)-> System.out.println("Trainer name is :"+name+" and total experience is :"+exp);
    	t1.getTraining("Smith", 5);
    	
    	
    	//By using Method reference 
    	Trainer t2 = new InstanceMethod()::getTraining;
    	t2.getTraining("Scott", 10);   	
    	
    }
}

--------------------------------------------------------------
Constructor reference :
------------------------
package com.ravi.constructor_reference;

@FunctionalInterface
interface A 
{
    Test createObject();
}

class Test 
{
    public Test() 
    {
        System.out.println("Test class Constructor invoked");
    }
}
public class ConstructorReferenceDemo1
{
    public static void main(String[] args) 
    {
        //By using Lambda
        A a1 = ()-> new Test();        
        a1.createObject(); 
        
        System.out.println("...................");        
        
       //By Using Method Reference
        A a2 = Test::new;   //calling Test class constructor 
        a2.createObject(); 
    }
}
--------------------------------------------------------------
package com.ravi.constructor_reference;

import java.util.function.Function;

class MyClass 
{
    private int value;

    public MyClass(int value)
    {
        this.value = value;
    }

    public int getValue() 
    {
        return this.value;
    }
}

public class ConstructorReferenceDemo2 
{
    public static void main(String[] args) 
    {
        Function<Integer, MyClass> constructorRef = MyClass::new;
                                  

        MyClass obj = constructorRef.apply(15);

        System.out.println("Value: " + obj.getValue());
    }
}
--------------------------------------------------------------
package com.ravi.constructor_reference;

import java.util.Scanner;
import java.util.function.Function;

class Person 
{
    private String name;

    public Person(String name) 
    {
        this.name = name;
    }

    public String getName() 
    {
        return name;
    }
}

public class ConstructorReferenceDemo3
{
    public static void main(String[] args) {
        
      Function<Integer, Person[]> arrayConstructorRef = Person[]::new;
                                  
        Person[] people = arrayConstructorRef.apply(3); //3 is size of Array

        Scanner sc = new Scanner(System.in);
        
        for (int i = 0; i < people.length; i++) 
        {
        	System.out.println("Enter person name at "+i+" position :");
        	String name = sc.nextLine();
            people[i] = new Person(name);
        }

        
        System.out.println("Names of people:");
        for (Person person : people) 
        {
            System.out.println(person.getName());
        }
    }
}
--------------------------------------------------------------
Arbitrary Reference :(ClassName::instanceMethodName)
-----------------------------------------------------
Reference to an instance method of an arbitrary object of a 
particular type.

Lambda Expression                      Method Reference
-------------------                    -----------------
s -> s.length();                        String::length;
s -> s.toUpperCase();                   String::toUpperCase;
(i1,i2)-> i1.compareTo(i2);             Integer::compareTo
(s1,s2)-> s1.compareTo(s2);             String::compareTo
---------------------------------------------------------------
package com.ravi.arbitary_reference;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class ArbitaryRefDemo1 
{
  public static void main(String[] args) 
  {
	List<Integer> list = Arrays.asList(9,5,3,7,2);
	
	//By using Lambda
	Collections.sort(list,(i1,i2)->i1.compareTo(i2));
	list.forEach(System.out::println);
		
	//By Arbitrary Reference
	Collections.sort(list,Integer::compareTo);
	list.forEach(System.out::println);
	
	String[] stringArray = { "Virat","Rohit","Ajinkya","Dhoni","Aswin"};
    Arrays.sort(stringArray, String::compareTo);
    System.out.println(Arrays.toString(stringArray));
	
  }
}
---------------------------------------------------------------
package com.ravi.arbitary_reference;

import java.util.Arrays;
import java.util.Comparator;

class Person
{
    String name;
    
    public Person(String name)
    {
        this.name = name;
    }

    public int personInstanceMethod1(Person person)
    {
        return this.name.compareTo(person.name);
    }

	@Override
	public String toString() {
		return "Person [name=" + name + "]";
	}  
    
    
}

public class ArbitraryRefDemo2 
{
    public static void main (String[] args) throws Exception
    {
    	
        Person[] personArray = {new Person("C"),new Person("B"), new Person("A")};    
        Arrays.sort(personArray, Person::personInstanceMethod1);
    
        System.out.println(Arrays.toString(personArray));
             
    }

}
-------------------------------------------------------------
14-05-2024
----------
New Date and Time API :
-----------------------
LocalDate :
-----------
It is a predefined final class which represents only Date. The java.util.Date class is providing Date and Time both so, only to get the Date we need to use LocalDate class available in java.time package.

         LocalDate d = LocalDate.now();

Here now is a static method of LocalDate class and its return type is LocalDate class. (Factory Method)

LocalTime :
-----------
It is also a final class which will provide only time.
            LocalTime d = LocalTime.now();

Here now is a static method of LocalTime class and its return type is LocalTime (Factory Method).

LocalDateTime :
----------------
It is also a final class which will provide Date and Time both without a time zone. It is a combination of LocalDate and LocalTime class.
             LocalDateTime d = LocalDateTime.now();

-------------------------------------------------------------
package com.ravi.new_date_time;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;

public class Demo1 
{
	public static void main(String[] args) 
	{	
	   LocalDate d = LocalDate.now();
	   System.out.println(d);
	   
	   LocalTime t = LocalTime.now();
	   System.out.println(t);
	   
	    LocalDateTime dt = LocalDateTime.now();
	    System.out.println(dt);
	}
}

Now, based on our application requirement we can take only date OR only time ot Date and time both
--------------------------------------------------------------
ZonedDateTime : (Date and time + Time zone)
---------------
It is a final class available in java.time package.

It is also provides date and time along with time zone so, by using this class we can work with different time zone in a global way.

ZonedDateTime x = ZonedDateTime.now();
ZoneId zone = x.getZone();

getZone() is a predefined non static method of ZonedDateTime class which returns ZoneId class, this ZoneId class provides the different zones, by using getAvailableZoneIds() static method we can find out the total zone available using this ZoneId class.

package com.ravi.new_date_time;

import java.time.ZoneId;
import java.time.ZonedDateTime;

public class Demo2 
{

	public static void main(String[] args) 
	{
		ZonedDateTime z = ZonedDateTime.now();
		System.out.println(z);
		
	    ZoneId zone = z.getZone();
	    System.out.println(zone);
	    
	    System.out.println(ZoneId.getAvailableZoneIds());    
	   
	    
	}

}
--------------------------------------------------------------
Differenr of() static method :
------------------------------
List.of();
Stream.of();
Optional.of();
ZoneId.of();
---------------------------------------------------------------
package com.ravi.new_date_time;

import java.time.ZoneId;
import java.time.ZonedDateTime;

public class Demo3 
{
    public static void main(String[] args)
    {
        ZoneId AusTimeZone = ZoneId.of("Australia/Hobart");
        ZonedDateTime aus = ZonedDateTime.now(AusTimeZone);        
        System.out.println("Current Date and Time in Australia Time Zone: " + aus);
        
        ZoneId londonTimeZone = ZoneId.of("Europe/London");
        ZonedDateTime lon = ZonedDateTime.now(londonTimeZone);
        System.out.println("Current Date and Time in London Time Zone: " + lon);
        
        
        
        
    }
}

Note :- of(String zoneId) is a static method of ZoneId abstract class it will provide the zoneId of specified zone as a parameter.
Now with ZonedDateTime we can find out the specified zoned time.
--------------------------------------------------------------
DateTimeFormatter :
-------------------
It is a predefined final class available in java.time.format sub package.

It is mainly used to formatting and parsing date and time objects according to Java Date and Time API.

Method :
--------
public static DateTimeFormatter ofPattern(String pattern) :

It is a static method of DateTimeFormatter class, It creates a 
formatter using user specified String pattern ("dd-MM-yyyy HH:mm:ss")
and LocalDateTime class contains format method which takes 
DateTimeFormatter as a parameter and returns the String value.

package com.ravi.new_date_time;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public  class Demo4 
{	
  public static void main(String[] args) 
  {
	LocalDateTime now = LocalDateTime.now();
	System.out.println(now);
	DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd-MM-YYYY");
	
	String formattedDateTime = now.format(formatter);
	System.out.println("Formatted DateTime: " + formattedDateTime);
  }
}
---------------------------------------------------------------
Terminal Operation in Stream in java:
--------------------------------------
In Java's Stream API, a terminal operation is an operation that produces a result or a side-effect from a stream.Unlike intermediate operations, which return a new stream, terminal operation consumes the elements of the stream. Once a terminal operation is applied to a stream, the stream is considered consumed and cannot be reused. It is a final operation.

Methods of Terminal Operation :
--------------------------------
public void forEach() :
------------------------
The forEach operation allows us to perform an action on each element of a stream. It takes a Consumer as a parameter and executes it for each element of the stream.
package com.ravi.advanced;

import java.util.stream.Stream;

public class ForEcahDemo1 {

	public static void main(String[] args)
	{
		Stream<Integer> streamOfNumbers = Stream.of(1,2,3,4,5,6,7,8,9,10);
		streamOfNumbers.forEach(System.out::println);
		

	}

}

public long count() :
---------------------
The count operation returns the number of elements in a stream as a long value. It is a terminal operation that terminates the stream after its execution.

package com.ravi.advanced;

import java.util.stream.Stream;

public class CountDemo1 {

	public static void main(String[] args) 
	{
		long count = Stream.of("Ravi","Raj","Elina","Aryan").count();
		System.out.println(count);

	}

}

public T collect() :
---------------------
The collect operation is used to collect the elements of a stream into a collection or a single result. It takes a Collectors as a parameter, which specifies the type of collection to be created(List/Set)

Optional<T> reduce(BinaryOperator optr) :
-----------------------------------------
It performs a reduction on the elements of the stream, using an associative accumulation function, and returns an Optional. 

package com.ravi.advanced;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.stream.Stream;

public class Test {

	public static void main(String[] args)
	{
		List<Integer> numbers = Arrays.asList(1,2,3,4,5,6);
		
		Optional<Integer> opt = numbers.stream().reduce((a,b)-> (a+b));
		System.out.println(opt.get());
		

		Optional<Integer> op1 = numbers.stream().reduce(Integer::sum);
		System.out.println(op1.get());
		
		Integer op2 = numbers.stream().reduce(0,(a,b)-> (a+b));
		System.out.println(op2);
		
		Integer reduce = Stream.of(1,2,3).reduce(1, (a,b)-> (a*b));
		System.out.println(reduce);
		
		
		
	}

}
--------------------------------------------------------------
T[]  toArray(IntFunction T[]): It returns an array containing the elements of the stream.

package com.ravi.advanced;

import java.util.Arrays;
import java.util.List;

public class ToArrayDemo1 {

	public static void main(String[] args) 
	{
		List<String> words = Arrays.asList("Java", "Stream", "API", "toArray", "Method");

        // Convert the stream to an array
        String[] wordsArray = words.stream().toArray(String[]::new);

        // Print the elements of the array
        System.out.println(Arrays.toString(wordsArray));
        System.out.println(wordsArray[0]);
	}

}
---------------------------------------------------------------

Networking in java :
-----------------------
IP Address :
-------------
An IP address is a unique identification number allocated to each and every device connected through the network.

By using this IP address we can recognise a client in the network. IP address contains some bytes which identify the network and the actual computer inside the network.

Eg:- 192.168.100.09  (ipconfig is the command in command propmpt)

Finding the IP Address of a server :
-------------------------------------- 
It is possible to find out the IP address of any website on internet. In order to do the same, java.net package has provided a predefined class called InetAddress which contains a static method getByName(String host) through which we can find out the IP address of any website.

Ex :- InetAddress.getByName("www.google.com");

Here getByName() will return the IP address of Google.com website.

The following are the important methods of InetAddress class :
-----------------------------------------------------------------------
1) public static InetAddress getByName(String host) throws 
      UnknownHostException :-
      
    It will return the IP address of the specified host.

2) public static InetAddress getLocalHost() throws 
    UnknownHostException :-
      
   It will return both the IP address and name of the local system.


3) public String getHostName() :- It will return the name of the System


4) public String getHostAddress() :-It will the return the IP Address of
    the System
-----------------------------------------------------------------------------------
//Program to find out the local host IP address and Name.
import java.net.*;
public class Inet
{
      public static void main(String args[]) throws UnknownHostException
      {
	       InetAddress ia = InetAddress.getLocalHost();
           System.out.println("Local Name and IP Address  : "+ia);
  
            
      }
}
-----------------------------------------------------------------------------------
//Program to find out the name and address of local machine
import java.net.*;
public class Inet3
{
      public static void main(String args[]) throws UnknownHostException
      {
            InetAddress ia = InetAddress.getLocalHost();
            String addr = ia.getHostAddress();
            String name = ia.getHostName();
            System.out.println("My host name is :"+name+" My address is : "+addr);
      }
}
-----------------------------------------------------------------------------------
//Name and IP address both at the same time
import java.net.*;
class LocalHost
{
	public static void main(String [] args) throws UnknownHostException
	{
		System.out.println(InetAddress.getLocalHost());
	}
}
----------------------------------------------------------------------------------
//program to find out the IP address of the given host
import java.net.*;
import java.io.*;
class IpAddress
{
public static void main(String[] args ) throws IOException 
    {
		BufferedReader br = new BufferedReader
		(new InputStreamReader(System.in));

		System.out.print("Enter the host name: ");
                String host = br.readLine();
                try 
                {
                   InetAddress ia = InetAddress.getByName(host);
                  System.out.println("IP address of "+host+" is : " + ia);
                }
		catch(UnknownHostException e )
		{
		System.err.println(e);
		}
    }
} 

/*
.com
.in
.ac.in
.edu
.gov.in
*/
-----------------------------------------------------------------------------------
URL class :
------------
It is a predefined class available in java.net package. It stands for Uniform Resource Locator. The URL class represents the address that we specify at browser URL to access some resource.

Example of URL:-

https ://www.gmail.com:25/index.jsp

From this above URL 

1) Protocol Name :- https (getProtocol())

2) server name or host name :- www.gmail.com (getHost())

3) port number :- 25 (-1 will be the value, if not supplied by the website) (getPort())

4) File name :- index.jsp (getFile())
---------------------------------------------------------------------------------
import java.net.*;
public class URLInfo
{
public static void main(String[] args)
{
	try
	{
	URL url=new URL("https://www.gmail.com:110/index.jsp");
	System.out.println("Protocol: "+url.getProtocol());
	System.out.println("Host Name: "+url.getHost());
	System.out.println("Port Number: "+url.getPort());
	System.out.println("File Name: "+url.getFile());
	}
	catch(Exception e)
	{
	System.out.println(e);
	}
 }
}
----------------------------------------------------------------------------------
URLConnection class :
------------------------
It is a predefined class availavle in java.net package. This class is useful to connect to a website or a resource in the network, it will fetch all the details of the specified web page as a part of URL class.

The URL class provides a method called openConnection(), this method will establish a connection with the specified web page and returns the URLConnection object, that is nothing but the complete details of the web page.

public URLConnection openConnection() throws IOException
-----------------------------------------------------------------------------------
import java.io.*;
import java.net.*;
public class Details 
{
public static void main(String[] args)
	{
		try
		{
		URL url=new URL("https://www.python.org/downloads/");

        //Eastablishing the connection from the Specified URL
		URLConnection urlcon=url.openConnection();

		InputStream stream = urlcon.getInputStream();
		
		while(true)
			{
			  int  i = stream.read();
				if(i==-1)
					break;
				System.out.print((char)i);

			}
		}
		catch(Exception e)
		{
		  System.out.println(e);
		}
}
}
-----------------------------------------------------------------------------------
25-Feb-23
------------
Socket :-
---------
It is possible to eastblish a logical connection point between the server and the client so that communication can be done through this point is called Socket.

Now, each socket is given an identification number which is called port number. The range of port number is 0-65535.

Eastablishing a communication between the client and server using socket is called Socket Programming.

Socket programming can be connection oriented or connection less. In java Socket (for client) and ServerSocket (for server) are the predefined classes available in java.net package for connection oriented Socket Programming.

The client socket programming must have two information.
1) Ip address of the server
2) port number

The following are the importatnt methods of Socket class :
------------------------------------------------------------------
1) public InputStream getInputStream();

2) public OutputStream getOutputStream();

3) public synchronized void close();


The following are the importatnt methods of ServerSocket class :
-------------------------------------------------------------------------
1) public Socket accept() :- It is used to put the server in wait mode till 
                                          a client accept or eastblish the connection

2) public InputStream getInputStream();

3) public OutputStream getOutputStream();

4) public synchronized void close();
-------------------------------------------------------------------------------------------
Creating a server that can send some data :
-------------------------------------------------
We can create a Socket that can be used to connect to a server and a client. Once the Socket is created, the Server can send the data to the client and client can receive the data.

All we have to do to just to send the data from server to socket. The socket will take care of whom to send the data on the network.

We should write the following java code to create a server that can send some data to the client.

1) At server side, create a server socket with some port number, This is done by using ServerSocket class

		ServerSocket ss = new ServerSocket(7777);

2) We should make the server wait till a client accept connections. This can be done by using accept().

		Socket s = ss.accept();

3) Now Attach some output stream to ServerSocket using getOutputStream() method. This method returns OutputStream object. This method is used to send the data from Socket to the client

		OutputStream obj =  s.getOutputStream();


4) Take another Stream like PrintStream or DataOutputStream to send the data till the Socket.

                PrintStream ps = new PrintStream(obj);

5) Now to print the data which we are sending from Server to the client we can use print() or println() method available in PrintStream class.

		ps.println(String data); 
		

6) Now close all the connections.
		
		ss.close();
		s.close();
		ps.close();


Creating a client that can receive some data :-
----------------------------------------------------
We can write client program that receives all the String sent from server to client machine.We should write the followinng java code

1) We should create a Socket at client side by using Socket class as

	Socket s = new Socket("Ip address", port number);

Note :- If the client and server both are running in a single machine then it is called "localhost",  we should write localhost instead of IP address.


2) We should add InputStream to the Socket so that the Socket will be able to receive the data on the InputStream. 

		InputStream obj = s.getInputStream();


3) Now to read the data from Socket to the client machine we can take the help of BufferedReader as 

		BufferedReader br  = new BufferedReader(new InputStreamReader(obj));

4) Now We can read the data from the BufferedReader as 

		String str = br.readLine();

5) close the connection

			br.close();
			s.close();
-----------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
Server1.java
---------------
//Program to send String to the client
import java.io.*;
import java.net.*;
class Server1
{
	public static void main(String args[]) throws IOException
	{
		ServerSocket ss = new ServerSocket(777);

		Socket s=ss.accept();

		System.out.println("Connection established...");

		OutputStream obj=s.getOutputStream();

		PrintStream ps = new PrintStream(obj);

		String str="Hello Client";
		ps.println(str);
		ps.println("Bye-Bye");
		ps.close();
		s.close();
		ss.close();
	}
}

Client1.java
--------------
import java.io.*;
import java.net.*;
class Client1
{
	public static void main(String args[]) throws Exception
	{
      Socket s = new Socket("localhost",777);

	  InputStream obj = s.getInputStream();

	  BufferedReader br = new BufferedReader(new InputStreamReader(obj));
	 
	  String str;

	  while((str=br.readLine()) !=null)
		{
		  System.out.println("From Server :"+str);
		}
	  br.close();
	  s.close();
	}
}
-------------------------------------------------------------------------------------------
Chating between Client and Server 
----------------------------------------
Server2.java
--------------
//A server that receives and send the data
import java.io.*;
import java.net.*;
class Server2
{
	public static void main(String [] args) throws Exception
	{
		ServerSocket ss = new ServerSocket(888);
		Socket s = ss.accept();

		System.out.println("Connection Established..");

		PrintStream ps = new PrintStream(s.getOutputStream());

		BufferedReader br = new BufferedReader
			(new InputStreamReader( s.getInputStream()));

		BufferedReader kb = new BufferedReader(new InputStreamReader(System.in));

		while(true)
		{
			String recv,send;  //send is for sending and recv is for receiving the data

			while((recv=br.readLine()) !=null)
			{
				System.out.println(recv);
				send=kb.readLine();
				ps.println(send);
			}
			ps.close();
			br.close();
			kb.close();
			s.close();
			ss.close();
			System.exit(0);//Shutdown the JVM
		}
	}
}

Client2.java
--------------
//A client that receives and send the data
import java.io.*;
import java.net.*;
class Client2
{
	public static void main(String [] args) throws Exception
	{
		Socket s = new Socket("localhost",888);

		DataOutputStream dos = new DataOutputStream(s.getOutputStream());

		BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream()));

		BufferedReader kb = new BufferedReader(new InputStreamReader(System.in));

		String send,recv; //send is for sending and recv is for receiving the data

		while(! (send=kb.readLine()).equals("exit"))   //Hello Server
		{
			dos.writeBytes(send+"\n");
			recv=br.readLine();
			System.out.println(recv);
		}
		dos.close();
		br.close();
		kb.close();
		s.close();
	}
}
-------------------------------------------------------------------------------------------
//Program to downlaod the content of a file from the Server, if the file is available at server.

FileServer.java
-----------------
//A server that can send file content to the client
import java.io.*;
import java.net.*;
class FileServer
{
	public static void main(String [] args ) throws Exception
	{
		ServerSocket ss = new ServerSocket(8888);
		Socket s = ss.accept();

		System.out.println("Connection established...");

		BufferedReader in = new BufferedReader(new InputStreamReader(s.getInputStream()));

		DataOutputStream out = new DataOutputStream(s.getOutputStream());

		String fname = in.readLine();     //fname = abc.txt		
		
		boolean flag;

        //File is existing or not
		File f = new File(fname);
		if(f.exists()) 
			flag=true;
		else
		     flag=false;

        //Sending the acknowledgement message to the client
		if(flag==true)
			out.writeBytes("yes"+"\n");
		else
			out.writeBytes("no"+"\n");


        //Reading the File content and sending it to the client
		if(flag==true)
		{
			FileReader fr=new FileReader(fname);
			BufferedReader file = new BufferedReader(fr);

			String str;
			while((str=file.readLine()) !=null)
			{
				out.writeBytes(str+"\n");
			}
			file.close();
			fr.close();
			out.close();
			in.close();			
			s.close();
			ss.close();
		}
	}
}

FileClient.java
----------------
//A Client receiving a file content 
import java.io.*;
import java.net.*;
class FileClient
{
	public static void main(String [] args ) throws Exception
	{		
		Socket s = new Socket("localhost",8888);

		BufferedReader kb = new BufferedReader(new InputStreamReader(System.in));

		System.out.print("Enter a file name :");

		String fname = kb.readLine();  //fname = abc.txt

		DataOutputStream out = new DataOutputStream(s.getOutputStream());

		out.writeBytes(fname+"\n"); //first of all client is sending file name

		BufferedReader in = new BufferedReader(new InputStreamReader(s.getInputStream()));
		
		String str = in.readLine();

		if(str.equalsIgnoreCase("yes"))
		{
			while((str=in.readLine()) !=null)
				System.out.println(str);
			kb.close();
			out.close();
			in.close();
			s.close();
		}
		else
		{
			System.out.println("File not found at Server location..");
		}
	}
}
---------------------------------------------------------------
Stream API Programs (84 Programs ):
------------------------------------

public class Employee {
    private String name;
    private int age;
    private double salary;
    private String gender;

    // Constructor
    public Employee(String name, int age, double salary, String gender) {
        this.name = name;
        this.age = age;
        this.salary = salary;
        this.gender = gender;
    }

    // Getters and setters for each variable
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public double getSalary() {
        return salary;
    }

    public void setSalary(double salary) {
        this.salary = salary;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    // Override toString() method for easy printing
    @Override
    public String toString() {
        return "Employee{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", salary=" + salary +
                ", gender='" + gender + '\'' +
                '}';
    }
}
--------------------------------------------------------------------------------------------
public class EmployeeAdder {

	public static List<Employee> addDetails() 
	{
		List<Employee> list = new ArrayList<>();
		Employee employee1 = new Employee("Anna", 27, 50000.0, "Male");
		Employee employee2 = new Employee("Employee 2", 27, 51000.0, "Female");
		Employee employee3 = new Employee("Bob", 27, 52000.0, "Male");
		Employee employee4 = new Employee("EmplSmithoyeeee 4", 28, 53000.0, "Female");
		Employee employee5 = new Employee("Employee 5", 29, 53000.0, "Male");
		Employee employee6 = new Employee("Employee 6", 30, 55000.0, "Female");
		Employee employee7 = new Employee("EmSmithployee 7", 31, 56000.0, "Male");
		Employee employee8 = new Employee("Employee 8", 32, 57000.0, "Female");
		Employee employee9 = new Employee("Employee 9", 35, 58000.0, "Male");
		Employee employee10 = new Employee("EMPLOYEEeeseeee 10", 35, 59000.0, "Female");

		list.add(employee1);
		list.add(employee2);
		list.add(employee3);
		list.add(employee4);
		list.add(employee5);
		list.add(employee6);
		list.add(employee7);
		list.add(employee8);
		list.add(employee9);
		list.add(employee10);
		return list;

	}

}
--------------------------------------------------------------------------------------------
public class Tester {
	private static final String RED = "\033[1;31m"; // RED
	private static final String RESET = "\033[0m"; // Text Reset
	public static void main(String[] args)
	{
		List<Employee> list = EmployeeAdder.addDetails();
		Set<Integer> set = new HashSet<>();
		Set<String> set2 = new HashSet<>();
//		 1. Filter Employees by Gender:
//		 - Retrieve a list of all female employees.
		System.out.println(RED+"*****Retrieve a list of all female employees********"+RESET);
		list.stream()
		.filter(t -> t.getGender().equals("Female"))
		.forEach(System.out::println);
		System.out.println(RED+"*****Get a list of employees older than 30 years.********"+RESET);
//		2. Filter Employees by Age:
//			   - Get a list of employees older than 30 years.
		list.stream()
		.filter(employee->employee.getAge()>30)
		.forEach(System.out::println);
		System.out.println(RED+"*****Find employees with a salary greater than $50,000.********"+RESET);
//		3. Filter Employees by Salary:
//			   - Find employees with a salary greater than $50,000.
		list.stream()
		.filter(employee->employee.getSalary()>50000)
		.forEach(System.out::println);

//		4. Map Employee Names:
//		   - Create a list of employee names (Strings).
		System.out.println(RED+"*************Create a list of employee names (Strings)*************"+RESET);
		list.stream()
		.map(employee->employee.getName())
		.forEach(System.out::println);

//		5. Calculate Average Salary:
//			   - Calculate the average salary of all employees.
		System.out.println(RED+"*********Calculate the average salary of all employees.*******"+RESET);
		double orElseThrow = list.stream()
				.mapToDouble(Employee::getSalary)
				.average()
				.orElseThrow();
		System.out.println("Average : "+orElseThrow);

//		6. Find Maximum Salary:
//			   - Find the employee with the highest salary.
		System.out.println(RED+"*********Find the employee with the highest salary.********"+RESET);
		double max = list.stream()
				.mapToDouble(Employee::getSalary)
				.max()
				.orElseThrow();
		System.out.println("Max Salary : "+max);

//		7.Group Employees by Gender:
//			   - Group employees by gender and return
//			   a map with gender as the key and a list of employees as the value.
		System.out.println(RED+"******Group employees by gender and return a map******"+RESET);
		list.stream()
		.collect(Collectors.groupingBy(Employee::getGender))
		.forEach((key,value)->System.out.println(key+" - "+value));

//		8. Count Male Employees:
//			   - Count the number of male employees.
		System.out.println(RED+"**********Count the number of male employees.*********"+RESET);
		long count = list.stream()
				.filter(employee -> employee.getGender().equals("Male"))
				.count();
		System.out.println("Count : "+count);

//		9. Sum of All Salaries:
//			   - Calculate the total sum of salaries for all employees.
		System.out.println(RED+"*********Calculate the total sum of salaries for all employees.**********"+RESET);
		double sum = list.stream()
				.mapToDouble(employee->employee.getSalary())
				.sum();
		System.out.println("Sum : "+sum);

//		10. Sort Employees by Name:
//		    - Sort the employees by their names in alphabetical order.
		System.out.println(RED+"*******Sort the employees by their names in alphabetical order.*****"+RESET);
		list.stream().sorted(Comparator.comparing(Employee::getName))
		.forEach(System.out::println);

//		11. Sort Employees by Age:
//		    - Sort the employees by age in ascending order.
		System.out.println(RED+"**********Sort the employees by age in ascending order.********"+RESET);
		list.stream()
		.sorted(Comparator.comparing(Employee::getAge))
		.forEach(System.out::println);

//		12. Sort Employees by Salary:
//		    - Sort the employees by salary in descending order.
		System.out.println(RED+"*********Sort the employees by salary in descending order.******"+RESET);
		list.stream()
		.sorted(Comparator.comparing(Employee::getAge).reversed())
		.forEach(System.out::println);

//		13. Find Oldest Employee:
//		    - Find the oldest employee.
		System.out.println(RED+"*********Find the oldest employee.*********"+RESET);
//		int orElseThrow2 = list.stream().mapToInt(Employee::getAge).max().orElseThrow();
		Employee employee = list.stream()
				.max((e1,e2)->(e1.getAge()-e2.getAge()))
				.get();
		System.out.println(employee);
//		System.out.println("Max Age : "+orElseThrow2);

//		14. Group Employees by Age:
//		    - Group employees into age groups (e.g., 20-30, 31-40, etc.)
//		    and return a map with age group as the key and a list of employees as the value.
		System.out.println(RED+"****Group employees into age groups (e.g., 20-30, 31-40, etc.)*****"+RESET);
		list.stream()
		.collect(Collectors.groupingBy((t) ->
						{int age = t.getAge();
							if(age>=20 && age<=30)
								return "20-30";
							else if (age>=31 && age<=40)
								return "31-40";
							else
								return "40+";
						})).forEach((key,value)->System.out.println(key+ " - "+value ));
//		15. Find Employees with a Specific Age:
//		    - Find all employees who are exactly 35 years old.
		System.out.println(RED+"************ Find all employees who are exactly 35 years old.***********"+RESET);
		list.stream().filter(k->k.getAge()==35).forEach(System.out::println);

//		16. Calculate the Sum of Salaries by Gender:
//		    - Calculate the sum of salaries for each gender (i.e., male and female)
//		    and return a map with gender as the key and the sum of salaries as the value.
		System.out.println(RED+"********* Calculate the sum of salaries for each gender**********"+RESET);
		list.stream()
		.collect(Collectors.groupingBy(Employee::getGender ,
				Collectors.summingDouble(Employee::getSalary)))
		.forEach((key,value)->System.out.println(key +" - "+value));


//		17. Find Employees with Names Starting with "J":
//		    - Find all employees whose names start with the letter "E."
		System.out.println(RED+"*********Find all employees whose names start with the letter J******"+RESET);
		list.stream().filter(k->k.getName().startsWith("E")).forEach(System.out::println);

//		18. Calculate the Average Salary for Male and Female Employees:
//		    - Calculate the average salary separately for male
//		    and female employees and return a map with gender
//		    		as the key and the average salary as the value.
		System.out.println(RED+"**********Calculate the average salary separately for male and female*********"+RESET);
		list.stream()
		.collect(Collectors.groupingBy(Employee::getGender,
				Collectors.averagingDouble(Employee::getSalary)))
		.forEach((key,value)->System.out.println(key+" - "+value));

//		19. Find the Top N Highest Paid Employees:
//		    - Find the top N employees with the highest salaries.

		System.out.println(RED+"*******Find the top N employees with the highest salaries.********"+RESET);
		list.stream().sorted((o1, o2) -> -(int)(o1.getSalary()-o2.getSalary()))
		.limit(5).forEach(System.out::println);

		list.stream()
		.sorted(Comparator.comparingDouble(Employee::getSalary).reversed())
		.limit(3)
		.forEach(System.out::println);

//		20. Retrieve Distinct Age Values:
//		    - Get a list of distinct ages of all employees.
		System.out.println(RED+"*********Get a list of distinct ages of all employees.*********"+RESET);

		list.stream().filter(k->!set.add(k.getAge())).forEach(System.out::println);

//		21. Find the Three Lowest-Paid Employees:
//			   - Find and display the names of the three employees with the lowest salaries.
		System.out.println(RED+"*******Find and display the names of the three employees with the lowest salaries.********"+RESET);
		list.stream()
		.sorted((o1,o2)->(int)(o1.getSalary()-o2.getSalary()))
		.map(k->k.getName())
		.limit(3)
		.forEach(System.out::println);

//		22. Sort Employees by Name Length:
//			   - Sort employees by the length of their names (shortest to longest).
		System.out.println(RED+"***********Sort employees by the length of their names (shortest to longest).*******"+RESET);
		list.stream()
		.sorted((o1, o2) ->(o1.getName().length()-o2.getName().length()))
		.forEach(System.out::println);

//		23. Group Employees by Age Range:
//			   - Group employees into custom
//			   age ranges (e.g., 20-29, 30-39, etc.) and
//			   return a map with the age range as the key and a list of employees as the value.
		System.out.println(RED+"*********Group employees into custom age ranges (e.g., 20-29, 30-39, etc.)*********"+RESET);
		list.stream()
		.collect(Collectors.groupingBy((t)->
		{
			int age = (t).getAge();
			if(age>=20 && age<=29)
				return "20-29";
			else if(age>=30 && age <= 39)
				return "30-39";
			else
				return "40+";
		}))
		.forEach((key,value)->System.out.println(key+" - "+value));

//		24. Find the Average Salary of Employees Aged 30 or Younger:
//			   - Calculate the average salary of employees aged 30 or younger.

		System.out.println(RED+"********Calculate the average salary of employees aged 30 or younger.******"+RESET);
		double orElseThrow2 = list.stream()
		.filter(emp->emp.getAge()<=30).mapToDouble(k->k.getSalary()).average().orElseThrow();
		System.out.println(orElseThrow2);

//		25. Find the Names of Male Employees with Salaries Over $60,000:
//			   - Retrieve the names of male employees with salaries over $60,000.
		System.out.println(RED+"**********Retrieve the names of male employees with salaries over $53,000.***********"+RESET);
		list.stream()
		.filter(e->e.getSalary()>=53000 && e.getGender().equals("Male"))
		.map(k->k.getName())
		.forEach(System.out::println);

//		26. Find the Youngest Female Employee:
//			   - Find the youngest female employee.
		System.out.println(RED+"**********Find the youngest female employee.**********"+RESET);
		Employee employee2 = list.stream()
		.filter(k->k.getGender().equals("Female"))
		.collect(Collectors.minBy((o1, o2) -> o1.getAge()-o2.getAge())).get();
		System.out.println(employee2);

//		27. Retrieve the Names of Employees in Reverse Order:
//			   - Get a list of employee names in reverse order (from the last employee to the first).
		System.out.println(RED+"******Get a list of employee names in reverse order*******"+RESET);
		List<String> collect = list.stream().map(k->k.getName()).collect(Collectors.toList());
		Collections.reverse(collect);
		System.out.println(collect);

//		28. Find the Highest Salary Among Female Employees:
//			   - Find the highest salary among female employees.
		System.out.println(RED+"******Find the highest salary among female employees."+RESET);
		Employee employee3 = list.stream()
		.filter(k->k.getGender().equals("Female"))
		.collect(Collectors.maxBy((o1, o2) -> (int)(o1.getSalary()-o2.getSalary()))).get();
		System.out.println(employee3);

//		29. Group Employees by Age and Gender:
//			   - Group employees by both age and gender and return a multi-level map.
		System.out.println(RED+"********Group employees by both age and gender and return a multi-level map.*****"+RESET);
		Map<String, Map<Integer, List<Employee>>> collect2 = list.stream()
		.collect(Collectors.groupingBy(Employee::getGender,Collectors.groupingBy(Employee::getAge)));

		collect2.forEach((key,value)->
		{
			value.forEach((k,v)->System.out.println(k+"-"+v));
			System.out.println(key+"-"+value);
		});

//		30. Find the Sum of Salaries for Employees with Names Containing "Smith":
//			   - Calculate the sum of salaries for employees whose names contain the substring "Smith."
		System.out.println(RED+"******* Calculate the sum of salaries for employees whose names contain the substring Smith***"+RESET);
		double sum2 = list.stream().filter(k->k.getName().contains("Smith")).mapToDouble(k->k.getSalary()).sum();
		System.out.println(sum2);

//		31. Find the Names of Employees Aged 30-40 with Salaries Between $50,000 and $60,000:
//			   - Retrieve the names of employees aged 30-40 with salaries between $50,000 and $60,000.
		System.out.println(RED+"******Retrieve the names of employees aged 30-40 with salaries between $50,000 and $60,000.*******"+RESET);
		list.stream()
		.filter(k->(k.getAge()>=30 && k.getAge()<=40)&&(k.getSalary()>=52000&&k.getSalary()<=60000))
		.forEach(System.out::println);

//		32. Calculate the Total Number of Employees:
//			   - Determine the total count of employees.

		System.out.println(RED+"******** Determine the total count of employees.*******"+RESET);
		System.out.println("Total Count of employess : "+list.stream().count());

//		33. Find the Most Common Age Among Employees:
//			   - Determine the age that is most common among the employees.
		System.out.println(RED+"******Determine the age that is most common among the employees.***"+RESET);
		Integer orElseThrow3 = list.stream()
		.collect(Collectors.groupingBy(Employee::getAge,Collectors.counting())) // grouping ages and count
		.entrySet() // converting to set
		.stream()
		.max(Map.Entry.comparingByValue()) // finding max value in map
		.map(Map.Entry::getKey) // getting key of max value
		.orElseThrow(); // getting the key
		System.out.println(orElseThrow3);

//		34. Find the Median Salary:
//			   - Calculate the median salary of all employees.

		System.out.println(RED+"********Calculate the median salary of all employees.******"+RESET);
		List<Employee> list2 = list.stream()
		.sorted(Comparator.comparingDouble(Employee::getSalary)).toList();
		int size = list2.size();
		if(size%2==0)
		{
			double s = list2.get(size/2-1).getSalary();
			double s1 = list2.get(size/2).getSalary();
			System.out.println((s+s1)/2.0);
		}
		else {
			System.out.println(list2.get(size/2).getSalary());
		}


//		35. Group Employees by Age and Count:
//		   - Group employees by age and count the number of employees in each age group.
		System.out.println(RED+"*******Group employees by age and count******"+RESET);
		list.stream().collect(Collectors.groupingBy(Employee::getAge,Collectors.counting()))
		.forEach((key,value)->System.out.println(key+" - "+value));

//		36. Find the Employee with the Longest Name:
//			   - Find the employee with the longest name.
		System.out.println(RED+"********Find the employee with the longest name.****"+RESET);
		Employee employee4 = list.
							stream()
							.max((o1, o2) -> o1.getName().length() - o2.getName().length())
							.get();
		System.out.println(employee4);

//		37. Calculate the Sum of Salaries for Each Age:
//			   - Calculate the sum of salaries for each distinct age in a map.
		System.out.println(RED+"***********Calculate the sum of salaries for each distinct age in a map*******"+RESET);
		set.clear();
		list.stream()
		.filter(k->!set.add(k.getAge()))
		.collect(Collectors.groupingBy(Employee::getAge,Collectors.summingDouble(Employee::getSalary)))
		.forEach((key,value)->System.out.println(key+" - "+value));

//		38. Sort Employees by Age, Then by Salary:
//			   - Sort employees first by age in ascending order, and then by salary in descending order.
		System.out.println(RED+"**********Sort employees first by age in ascending order, and then by salary in descending order*******"+RESET);
		list.stream()
		.sorted(Comparator.comparingInt(Employee::getAge)
				.thenComparing(Comparator.comparingDouble(Employee::getSalary).reversed()))
		.forEach(System.out::println);

//		39. Find Employees Whose Names Contain More Than One Word:
//			   - Retrieve employees whose names consist of more than one word.
		System.out.println(RED+"***********Retrieve employees whose names consist of more than one word.*****"+RESET);
		list.stream()
		.filter(k->k.getName().length()>1)
		.forEach(System.out::println);

//		40. Find the Two Highest Paid Female Employees:
//			   - Find and display the names of the two highest-paid female employees.
		System.out.println(RED+"**********Find and display the names of the two highest-paid female employees.*****"+RESET);
		list.stream()
		.filter(k->k.getGender().equals("Female"))
		.sorted(Comparator.comparingDouble(Employee::getSalary).reversed())
		.limit(2)
		.forEach(System.out::println);

//		41. Find the Employee with the Highest Salary in Each Gender:
//			   - Find the employee with the highest salary for each gender (male and female).
		System.out.println(RED+"******Find the employee with the highest salary for each gender (male and female).*****"+RESET);
		list.stream()
		.collect(Collectors.toMap(Employee::getGender, k->k,(e1, e2) -> e1.getSalary()>=e2.getSalary()?e1:e2))
		.forEach((key,value)->System.out.println(key+"-"+value));

//		42. Retrieve Employees with Unique Names:
//			   - Find employees with unique names (no duplicate names in the list).
		System.out.println(RED+"*******Find employees with unique names (no duplicate names in the list).****"+RESET);
		list.stream().filter(k->set2.add(k.getName()))
		.forEach(System.out::println);
		set2.clear();

//		43. Find the Names of Employees in Uppercase:
//			   - Get a list of employee names in uppercase.
		System.out.println(RED+"*******Get a list of employee names in uppercase.*****"+RESET);
		list.stream()
		.filter(k->k.getName().equals(k.getName().toUpperCase()))
		.forEach(System.out::println);

//		44. Calculate the Salary Range (Min-Max) for Each Age Group:
//			   - Calculate the salary range (minimum and maximum) for each distinct age group.
		System.out.println(RED+"******Calculate the salary range (minimum and maximum) for each distinct age group.****"+RESET);
		list.stream()
		.collect(Collectors.
				groupingBy(Employee::getAge,
						Collectors.collectingAndThen(Collectors.toList(),
								employees->
						{
							double min = employees.stream()
									.mapToDouble(Employee::getSalary)
									.min().orElseThrow();
							double maxs = employees.stream()
									.mapToDouble(Employee::getSalary)
									.max().orElseThrow();
							Map<String,Double> map = new HashMap<>();
							map.put("min", min);
							map.put("max", maxs);
							return map;
						}))).
		forEach((age,salary)->
		System.out.println
		("Age : "+age+" - "+"Min Salary : "+salary.get("min")+" Max Salary : "+salary.get("max")));

//		45. Filter Employees by First Name Initial:
//			   - Retrieve employees whose first name starts with a specific initial (e.g., 'A').
		System.out.println(RED+"********Retrieve employees whose first name starts with a specific initial (e.g., 'E').******"+RESET);
		list.stream()
		.filter(k->k.getName().startsWith("E"))
		.forEach(System.out::println);

//		46. Group Employees by Age and List Only Unique Salaries:
//			   - Group employees by age and display a list of unique salaries for each age group.
		System.out.println(RED+"********Group employees by age and display a list of unique salaries for each age group.*****"+RESET);
		list.stream()
		.collect(Collectors
				.groupingBy(Employee::getAge,
						Collectors.mapping(Employee::getSalary, Collectors.toSet())))
							.forEach((key,value)->System.out.println("Age : "+key +" Salary : "+value));

//		47. Find Employees with the Same Salary:
//			   - Identify and display employees who have the same salary.
		System.out.println(RED+"*****Identify and display employees who have the same salary.****"+RESET);
		list.stream()
		.collect(Collectors.groupingBy(Employee::getSalary))
		.entrySet()
		.stream() // k is entry
		.filter(k -> k.getValue().size()>1)
		.forEach(entry ->  // Map (Double , List<>)
		{
			System.out.println(entry.getKey());
			entry.getValue().forEach(System.out::println);

		});


//		48. Find the Employee with the Shortest Name Among Male Employees:
//		   - Find the male employee with the shortest name.
		System.out.println(RED+"******Find the male employee with the shortest name.******"+RESET);
		Employee employee5 = list.stream()
		.filter(k->k.getGender().equals("Male"))
		.min((o1, o2) -> Integer.compare(o1.getName().length(), o2.getName().length()))
		.orElseThrow();
		System.out.println(employee5);

//		49. Find the Most Common Salary Value:
//			   - Determine the salary value that appears most frequently among the employees.
		System.out.println(RED+"************Determine the salary value that appears most frequently among the employees.********"+RESET);
		Double orElseThrow4 = list.stream()
		.collect(Collectors.groupingBy(Employee::getSalary , Collectors.counting()))
		.entrySet()
		.stream()
		.max(Map.Entry.comparingByValue())
		.map(Map.Entry::getKey).orElseThrow();
		System.out.println(orElseThrow4);

//		50. Find the Oldest Employee with the Lowest Salary:
//			   - Find the oldest employee with the lowest salary.
		System.out.println(RED+"*******Find the oldest employee with the lowest salary.******"+RESET);
		Employee employee6 = list.stream()
		.filter(k-> k.getAge()==list.stream().mapToInt(Employee::getAge).max().orElseThrow())
		.min(Comparator.comparingDouble(Employee::getSalary)).get();
		System.out.println(employee6);
		
//		51. Filter Employees by Gender:
//			   - Retrieve a list of all female employees.
		System.out.println(RED+"****** Retrieve a list of all female employees.****"+RESET);
		list
		.stream()
		.filter(k->k.getGender().equals("Female"))
		.forEach(System.out::println);
		
//		52. Filter Employees by Age:
//			   - Get a list of employees older than 30 years.
		System.out.println(RED+"*************Get a list of employees older than 30 years.********"+RESET);
		list
		.stream()
		.filter(k->k.getAge()>30)
		.forEach(System.out::println);
		
//		53. Filter Employees by Salary:
//			   - Find employees with a salary greater than $50,000.
		System.out.println(RED+"******Find employees with a salary greater than $50,000.******"+RESET);
		list.stream()
		.filter(k->k.getSalary()>50000)
		.forEach(System.out::println);
		

//		54. Map Employee Names:
//		   - Create a list of employee names (Strings).
		System.out.println(RED+"******Create a list of employee names (Strings).******"+RESET);
		list.stream()
		.map(k->k.getName())
		.toList().forEach(System.out::println);
		

//		55. Calculate Average Salary:
//		   - Calculate the average salary of all employees.
		System.out.println(RED+"*********Calculate the average salary of all employees.****"+RESET);
		Double collect3 = list.stream()
		.collect(Collectors.averagingDouble(Employee::getSalary));
		System.out.println(collect3);
		
//		56. Find Maximum Salary:
//			   - Find the employee with the highest salary.
		System.out.println(RED+"********Find the employee with the highest salary.********"+RESET);
		Employee employee7= list.stream()
		.collect(Collectors.maxBy(Comparator.comparingDouble(Employee::getSalary))).get();
		System.out.println(employee7);
		
//		57. Group Employees by Gender:
//			   - Group employees by gender
//			   and return a map with gender as the key and a list of employees as the value.
		System.out.println(RED+"*********return a map with gender as the key and a list of employees*****"+RESET);
		list.stream()
		.collect(Collectors.groupingBy(Employee::getGender))
		.forEach((k,v)->System.out.println(k+" - "+v));
		
//		58. Count Male Employees:
//			   - Count the number of male an female employees.
		System.out.println(RED+"****Count the number of male and female employees.*****"+RESET);
		list.stream()
		.collect(Collectors.groupingBy(Employee::getGender , Collectors.counting()))
		.forEach((k,v)->System.out.println(k+" - "+v));
		
//		59. Sum of All Salaries:
//			   - Calculate the total sum of salaries for all employees.
		System.out.println(RED+"******Calculate the total sum of salaries for all employees.*****"+RESET);
		Double collect4 = list.stream()
		.collect(Collectors.summingDouble(Employee::getSalary));
		System.out.println(collect4);
		
//		60. Sort Employees by Name:
//			   - Sort the employees by their names in alphabetical order.
		System.out.println(RED+"****** Sort the employees by their names in alphabetical order.******"+RESET);
		list.stream()
		.sorted(Comparator.comparing(Employee::getName)).forEach(System.out::println);
		
//		61. Find the Employee with the Highest Salary in Each Gender:
//			   - Find the employee with the highest salary for each gender (male and female).
		System.out.println(RED+"*******Find the employee with the highest salary for each gender (male and female).*****"+RESET);
		list.stream()
		.collect(Collectors.toMap(Employee::getGender, t -> t,(t, u) -> t.getSalary()>=u.getSalary() ? t : u))
		.forEach((k,v)->System.out.println(k+" - "+v));
		
//		62. Retrieve Employees with Unique Names:
//			   - Find employees with unique names (no duplicate names in the list).
		System.out.println(RED+"*******Find employees with unique names (no duplicate names in the list).******"+RESET);
		list
		.stream()
		.collect(Collectors.groupingBy(Employee::getName , Collectors.counting()))
		.entrySet()
		.stream()
		.filter(k->k.getValue()==1)
		.forEach(k->System.out.println(k.getKey()));
		
//		63. Find the Names of Employees in Uppercase:
//			   - Get a list of employee names in uppercase.
		System.out.println(RED+"******Get a list of employee names in uppercase.******"+RESET);
		list
		.stream()
		.filter(k->k.getName().equals(k.getName().toUpperCase()))
		.forEach(System.out::println);
		
//		64. Calculate the Salary Range (Min-Max) for Each Age Group:
//			   - Calculate the salary range (minimum and maximum) for each distinct age group.
		System.out.println(RED+"*******Calculate the salary range (minimum and maximum) for each distinct age group.******"+RESET);
		Map<Integer,Map<String,Double>> collect5 = list.stream()
		.collect(Collectors.groupingBy(Employee::getAge,
				Collectors.collectingAndThen(Collectors.toList(), k ->
		{
			Double maxx = k.stream().mapToDouble(k2->k2.getSalary()).max().getAsDouble();
			Double min = k.stream().mapToDouble(k1->k1.getSalary()).min().getAsDouble();
			Map<String, Double> map =  new HashMap<>();
			map.put("max", maxx);
			map.put("min", min);
			return map;
			
		})));
		collect5.forEach((age,map)->
		{
			System.out.print("Age : "+age+" - ");
			System.out.println("Minimum : "+map.get("min")+" Maximum : "+map.get("max"));
		});
		
//		65. Filter Employees by First Name Initial:
//			   - Retrieve employees whose first name starts with a specific initial (e.g., 'E').
		System.out.println(RED+"**********Retrieve employees whose first name starts with a specific initial *******"+RESET);
		list.stream()
		.filter(k->k.getName().startsWith("E"))
		.forEach(System.out::println);
		
//		66. Group Employees by Age and List Only Unique Salaries:
//			   - Group employees by age and display a list of unique salaries for each age group.
		System.out.println(RED+"*******Group employees by age and display a list of unique salaries for each age group.******"+RESET);
		list.stream()
		.collect(Collectors.groupingBy(Employee::getAge,
				Collectors.mapping(Employee::getSalary, Collectors.toSet())))
		.forEach((k,v)->System.out.println(k+" - "+v));
		
//		67. Find Employees with the Same Salary:
//			   - Identify and display employees who have the same salary.
		System.out.println(RED+"********Identify and display employees who have the same salary.****"+RESET);
		list.stream()
		.collect(Collectors.groupingBy(Employee::getSalary))
		.entrySet()
		.stream()
		.filter(k->k.getValue().size()>1)
		.forEach(t -> 
		{
			System.out.println(t.getKey() + " " + t.getValue());
		});
		
//		68. Find the Employee with the Shortest Name Among Male Employees:
//			   - Find the male employee with the shortest name.
		System.out.println(RED+"********Find the male employee with the shortest name.*****"+RESET);
		Employee employee8 = list.stream().filter(k->k.getGender().equals("Male"))
		.min(Comparator.comparing(Employee::getName)).get();
		System.out.println(employee8);
		
//		69. Find the Most Common Salary Value:
//			   - Determine the salary value that appears most frequently among the employees.
		System.out.println(RED+"*******Determine the salary value that appears most frequently among the employees.********"+RESET);
		Double double1 = list.stream()
		.collect(Collectors.groupingBy(Employee::getSalary , Collectors.counting()))
		.entrySet()
		.stream()
		.max(Map.Entry.comparingByValue())
		.map(Map.Entry::getKey).get();
		System.out.println(double1);
		
//		70. Find the Oldest Employee with the Lowest Salary:
//			   - Find the oldest employee with the lowest salary.
		System.out.println(RED+"*******Find the oldest employee with the lowest salary.*****"+RESET);
		Employee employee9 = list.stream()
		.filter(k->k.getAge()==list.stream().mapToInt(Employee::getAge).max().getAsInt())
		.min(Comparator.comparingDouble(Employee::getSalary)).get();
		System.out.println(employee9);
		
//		71. Find the Most Common Age Among Employees:
//			   - Determine the age that is most common among the employees.
		System.out.println(RED+"*******Determine the age that is most common among the employees.*****"+RESET);
		Integer integer = list.stream()
		.collect(Collectors.groupingBy(Employee::getAge , Collectors.counting()))
		.entrySet()
		.stream()
		.max(Map.Entry.comparingByValue())
		.map(Map.Entry::getKey)
		.get();
		System.out.println(integer);
		
//		72. Find the Employee with the Longest Name:
//			   - Find the employee with the longest name.
		System.out.println(RED+"******Find the employee with the longest name.****"+RESET);
		Employee employee10 = list.stream()
		.max(Comparator.comparingInt(value -> value.getName().length())).get();
		System.out.println(employee10);
		
//		73. Find Employees with Palindromic Names:
//			   - Retrieve employees whose names are palindromes (e.g., "Anna" or "Bob").
		System.out.println(RED+"******Retrieve employees whose names are palindromes*****"+RESET);
		list.stream()
		.filter(k->
		{
			String mainString = k.getName().toLowerCase();
			StringBuffer sr = new StringBuffer(mainString);
			return mainString.contentEquals(sr.reverse());
		}).forEach(System.out::println);
		
//		74. Calculate the Sum of Salaries for Employees with Odd Ages:
//			   - Calculate the sum of salaries for employees with odd ages.
		System.out.println(RED+"*********the sum of salaries for employees with odd ages.******"+RESET);
		double sum3 = list.stream()
		.filter(k->k.getAge()%2!=0)
		.mapToDouble(Employee::getSalary)
		.sum();
		System.out.println(sum3);
		
//		75. Find the Employee with the Highest Salary Whose Name Contains "Smith":
//			   - Find the employee with the highest salary whose name contains the word "Smith."
		System.out.println(RED+"******Find the employee with the highest salary whose name contains the word \"Smith.\"*******"+RESET);
		Employee employee11 = list.stream()
		.filter(k->k.getName().contains("Smith"))
		.max(Comparator.comparingDouble(Employee::getSalary)).get();
		System.out.println(employee11);
		
//		76. Group Employees by the First Letter of Their Names:
//			   - Group employees by the first letter 
//			   of their names and return a map with
//					   the letter as the key and a list of employees as the value.
		System.out.println(RED+"*****Group employees by the first letter of their names****"+RESET);
		list.stream()
		.collect(Collectors.groupingBy(t -> t.getName().charAt(0)))
		.forEach((k,v)->System.out.println(k+" - "+v));
		
//		77. Find the Employee with the Shortest Name:
//			   - Find the employee with the shortest name.
		System.out.println(RED+"*******Find the employee with the shortest name.*****"+RESET);
		Employee employee12 = list.stream()
		.min(Comparator.comparingInt(value -> value.getName().length()))
		.get();
		System.out.println(employee12);
		
//		78. Calculate the Average Salary of Employees Whose Names Start with "E":
//			   - Calculate the average salary of employees whose names start with the letter "E."
		System.out.println(RED+"******Calculate the average salary of employees whose names start with the letter \"E.\""+RESET);
		Double collect6 = list.stream()
		.filter(k->k.getName().startsWith("E"))
		.collect(Collectors.averagingDouble(Employee::getSalary));
		System.out.println(collect6);
		
//		79. Filter Employees by Age Range:
//			   - Filter employees 
//			   based on a custom age range (e.g., between 25 and 35 years old).
		System.out.println(RED+"*******based on a custom age range (e.g., between 25 and 35 years old)*****"+RESET);
		list.stream()
		.filter(k->k.getAge()>=25 && k.getAge()<=35)
		.forEach(System.out::println);
		
//		80. Group Employees by the First Two Letters of Their Names:
//			   - Group employees by the first two letters 
//			   of their names and 
//			   return a map with the letters as the key and a list of employees as the value.
		System.out.println(RED+"*****Group employees by the first two letters*****"+RESET);
		list.stream()
		.collect(Collectors.groupingBy(k->k.getName().substring(0, 2)))
		.forEach((k,v)->System.out.println(k+" - "+v));
		
//		81. Find the Employee with the Longest Name Whose Salary Is Below $70,000:
//			   - Find the employee with the longest name whose salary is below $70,000.
		System.out.println(RED+"*******Find the employee with the longest name whose salary is below $70,000.**"+RESET);
		Employee employee13 = list.stream().filter(k->k.getSalary()<70000)
		.max(Comparator.comparingInt(k->k.getName().length())).get();
		System.out.println(employee13);
		
//		82. Calculate the Average Salary of Employees Whose Names End with "son":
//			   - Calculate the average salary of employees whose names end with the suffix "son."
		System.out.println(RED+"*******Calculate the average salary of employees whose names end with the suffix \"son.\""+RESET);
		Double collect7 = list.stream()
		.filter(k->k.getName()
				.endsWith("na")).collect(Collectors.averagingDouble(Employee::getSalary));
		System.out.println(collect7);
		
//		83. Group employees by the number of 
//		words in their names (e.g., one-word names, two-word names, etc.) 
//		and return a map with the count as the key and a list of employees as the value.
		list.stream()
		.collect(Collectors.groupingBy(k->k.getName().length()))
		.forEach((k,v)->System.out.println(k+" - "+v));
		
//		84. Calculate the Average Salary of Employees Whose Names Contain Both "A" and "E":
//			   - Calculate the average salary of employees whose names contain both the letters "A" and "E."
		System.out.println(RED+"********the average salary of employees whose names contain both the letters \"A\" and \"E.\"**********"+RESET);
		double asDouble = list.stream()
		.filter(k->k.getName().contains("A")&&k.getName().contains("E"))
		.mapToDouble(Employee::getSalary).average().orElse(0.0);
		System.out.println(asDouble);
	}
		
}
























































































































































































 











































































































































































































































































































































































































     











































































































































































































































































































































































































































































































 






































































































































































































































































































































 










































            

   
































































